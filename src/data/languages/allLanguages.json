[{"id":31,"name":"Ada","slug":"ada","logo":"img/ada.png","desc":"Ada เป็นภาษาโปรแกรมที่มีโครงสร้างชัดเจนและแข็งแกร่ง (Strongly-typed) พัฒนาขึ้นโดยกระทรวงกลาโหมสหรัฐฯ เน้นความน่าเชื่อถือและความปลอดภัยสูง เหมาะสำหรับระบบฝังตัว (Embedded Systems), ระบบควบคุมแบบเรียลไทม์ (Real-time Systems) และระบบที่มีความสำคัญด้านความปลอดภัยสูง เช่น การบินและอวกาศ, การทหาร, และการควบคุมการจราจรทางอากาศ","by":"Jean Ichbiah (ทีมงาน)","yr":"1980 (Ada 83)","level":"1","par":["Structured","Object-Oriented","Concurrent","Imperative"],"fields":["Embedded","Aero","Robot"],"rank":"45+ (Niche ในตลาดเฉพาะทาง)","salary_range":"฿40,000-70,000 บาท/เดือน (Junior), ฿70,000-120,000 บาท/เดือน (Senior) - เป็นที่ต้องการสูงในอุตสาหกรรมเฉพาะทาง","salary":["high","veryhigh"],"pros":["ความน่าเชื่อถือและความปลอดภัยสูงมาก (built-in checks)","เหมาะสำหรับระบบขนาดใหญ่และซับซ้อน","มีคุณสมบัติ Concurrency ในตัว (Tasks)","Strongly-typed ช่วยลดข้อผิดพลาด","Modular Design ที่ดี"],"cons":["Learning Curve สูง","ชุมชนนักพัฒนาเล็กและเฉพาะทาง","ไม่เหมาะกับแอปพลิเคชันทั่วไปหรือเว็บ","เวลาในการคอมไพล์นาน","ขาด Library ที่หลากหลายเมื่อเทียบกับภาษาอื่น"],"frameworks":[],"learn":["AdaCore","Wikibooks: Ada Programming","Learn Ada"],"variables":{"declaration (การประกาศ)":["Variable_Name : Type_Name := Initial_Value; -- การประกาศตัวแปรพร้อมค่าเริ่มต้น","Constant_Name : constant Type_Name := Value; -- การประกาศค่าคงที่"],"types (ประเภท)":["Integer // จำนวนเต็ม","Float // ทศนิยม","Boolean // ค่าตรรกะ (True, False)","Character // ตัวอักขระ","String // ข้อความ","Enumeration Types // ประเภทข้อมูลแบบแจงนับ (เช่น (Red, Green, Blue))","Record Types // ประเภทข้อมูลแบบ Record (คล้าย Struct ใน C)","Array Types // ประเภทข้อมูลแบบ Array","Access Types (Pointers) // ประเภทข้อมูลแบบ Pointer"],"examples (ตัวอย่าง)":["My_Integer : Integer := 10; -- ประกาศตัวแปร Integer พร้อมค่าเริ่มต้น","Is_Active : Boolean := True; -- ประกาศตัวแปร Boolean","PI : constant Float := 3.14159; -- ประกาศค่าคงที่ Float","My_Array : array (1 .. 5) of Integer := (1, 2, 3, 4, 5); -- ประกาศ Array","type Color is (Red, Green, Blue); -- การประกาศ Enumeration Type\nMy_Color : Color := Red; -- การใช้ Enumeration Type"]},"functions":{"declaration (การประกาศ)":["function Function_Name (Parameters) return Return_Type is\\n  -- body\\nend Function_Name; -- การประกาศ Function (มีค่าคืนกลับ)","procedure Procedure_Name (Parameters) is\\n  -- body\\nend Procedure_Name; -- การประกาศ Procedure (ไม่มีค่าคืนกลับโดยตรง)"],"examples (ตัวอย่าง)":["function Add (A, B : Integer) return Integer is\\nbegin\\n  return A + B;\\nend Add; -- ฟังก์ชันบวกเลขสองจำนวน","procedure Greet (Name : String) is\\nbegin\\n  Put_Line (\"Hello \" & Name); -- แสดงผลข้อความ\\nend Greet; -- Procedure ทักทาย","// การเรียกใช้ฟังก์ชัน/Procedure\n-- ใน Main Program:\n-- with Ada.Text_IO;\n-- use Ada.Text_IO;\n--\n-- procedure Main is\n--   Result : Integer;\n-- begin\n--   Result := Add(5, 5); -- Result จะมีค่า 10\n--   Put_Line (\"Sum is: \" & Integer'Image(Result)); -- แสดงผล 'Sum is: 10'\n--   Greet(\"Ada User\"); -- แสดงผล 'Hello Ada User'\n-- end Main;\n","function Get_Max (A, B : Integer) return Integer is\\nbegin\\n  if A > B then\\n    return A;\\n  else\\n    return B;\\n  end if;\\nend Get_Max; -- ฟังก์ชันหาค่าสูงสุด","procedure Swap (A, B : in out Integer) is\\n  Temp : Integer;\\nbegin\\n  Temp := A;\\n  A := B;\\n  B := Temp;\\nend Swap; -- Procedure สลับค่า (ใช้ in out parameter)"],"built_in (ในตัว)":["Put_Line (from Text_IO) // ใช้แสดงผลข้อความออก Console","Get_Line (from Text_IO) // ใช้รับข้อความจาก Console","Integer'Image // Attribute สำหรับแปลง Integer เป็น String","Float'Image // Attribute สำหรับแปลง Float เป็น String","Integer'Value // Attribute สำหรับแปลง String เป็น Integer","Float'Value // Attribute สำหรับแปลง String เป็น Float"],"async (Concurrency)":["task Task_Name is\\n  -- entry points (interfaces to other tasks)\\nend Task_Name;\\n\\n-- task body Task_Name is\\n-- begin\\n--   -- task logic\\n--   accept Entry_Point (Parameter : in Integer) do\\n--     -- handle parameter\\n--   end Entry_Point;\\n-- end Task_Name; -- การประกาศ Task (สำหรับ Concurrency)"]},"syntax":{"comments (คอมเมนต์)":["-- This is an Ada comment -- คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["if Condition then\\n  -- statements\\nelsif Another_Condition then\\n  -- statements\\nelse\\n  -- statements\\nend if; -- คำสั่ง if-elsif-else","case Expression is\\n  when Value1 =>\\n    -- statements\\n  when Value2 | Value3 =>\\n    -- statements (หลายค่า)\\n  when others =>\\n    -- statements (กรณีอื่นๆ)\\nend case; -- คำสั่ง case (คล้าย switch)"],"loops (การวนซ้ำ)":["loop\\n  -- statements\\n  exit when Condition;\\nend loop; -- Infinite loop พร้อมเงื่อนไขออก","while Condition loop\\n  -- statements\\nend loop; -- ลูป while","for Loop_Variable in Range loop\\n  -- statements\\nend loop; -- ลูป for (สำหรับช่วงตัวเลข)"],"operators (ตัวดำเนินการ)":["+, -, *, /, mod, rem // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, Modulo, Remainder","** // ยกกำลัง","and, or, xor, not // ตัวดำเนินการตรรกะ: AND, OR, XOR, NOT","& // Concatenation (เชื่อมสตริง)","// Comparison: =, /=, <, <=, >, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, น้อยกว่าหรือเท่ากับ, มากกว่า, มากกว่าหรือเท่ากับ"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else\nprocedure If_Example is\n  My_Integer : Integer := 10;\nbegin\n  if My_Integer > 0 then\n    Put_Line (\"Positive\");\n  else\n    Put_Line (\"Non-positive\");\n  end if;\nend If_Example;\n","// ตัวอย่างที่ 2: การใช้วงลูป For\nprocedure For_Loop_Example is\nbegin\n  for I in 1 .. 3 loop\n    Put_Line (\"Loop: \" & Integer'Image(I));\n  end loop;\nend For_Loop_Example;\n","// ตัวอย่างที่ 3: การใช้ Case Statement\nprocedure Case_Example is\n  type Day_Type is (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday);\n  Today : Day_Type := Monday;\nbegin\n  case Today is\n    when Monday .. Friday =>\n      Put_Line (\"It's a weekday.\");\n    when Saturday | Sunday =>\n      Put_Line (\"It's the weekend!\");\n  end case;\nend Case_Example;\n","// ตัวอย่างที่ 4: การใช้งาน Record Types (Structs)\nprocedure Record_Example is\n  type Person_Type is record\n    Name : String(1 .. 20);\n    Age  : Integer;\n  end record;\n  John : Person_Type;\nbegin\n  John.Name := \"John Doe            \"; -- ต้องกำหนดความยาวให้ตรง\n  John.Age := 30;\n  Put_Line (\"Name: \" & John.Name & \", Age: \" & Integer'Image(John.Age));\nend Record_Example;\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nprocedure Exception_Example is\n  Numerator   : Integer := 10;\n  Denominator : Integer := 0;\n  Result      : Integer;\nbegin\n  Result := Numerator / Denominator; -- จะเกิด Constraint_Error\n  Put_Line (\"Result: \" & Integer'Image(Result));\nexception\n  when Constraint_Error =>\n    Put_Line (\"Error: Division by zero or other constraint violation.\");\n  when others =>\n    Put_Line (\"An unexpected error occurred.\");\nend Exception_Example;\n"]}},{"id":61,"name":"APL","slug":"apl","logo":"img/apl.png","desc":"APL (A Programming Language) เป็นภาษาโปรแกรมเชิง Array-oriented ที่มีชื่อเสียงจากการใช้สัญลักษณ์เฉพาะตัว (Special Symbols) เพื่อดำเนินการกับ Array ได้อย่างมีประสิทธิภาพสูง เหมาะสำหรับการคำนวณทางคณิตศาสตร์, สถิติ, วิทยาศาสตร์ และงานที่เกี่ยวข้องกับข้อมูลเชิงตัวเลขจำนวนมาก","by":"Kenneth E. Iverson","yr":"1960s (พัฒนา), 1966 (เผยแพร่)","level":"1","par":["Array-oriented","Functional","Procedural"],"fields":["Math","Scientific"],"rank":"45+ (Niche ในตลาดเฉพาะทาง)","salary_range":"฿35,000-58,000 บาท/เดือน (Junior), ฿58,000-95,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ความสามารถในการประมวลผล Array ที่ทรงพลังและกระชับ","ช่วยลดปริมาณโค้ดที่ต้องเขียนลงอย่างมาก (Conciseness)","ประสิทธิภาพสูงสำหรับการคำนวณเชิงตัวเลข","เหมาะสำหรับงานวิเคราะห์ข้อมูลขนาดใหญ่","มี Interactive Environment ที่ดี"],"cons":["ใช้สัญลักษณ์พิเศษที่ต้องเรียนรู้และจดจำจำนวนมาก","Learning Curve สูงมากสำหรับผู้เริ่มต้น","โค้ดอ่านยากมากสำหรับผู้ที่ไม่คุ้นเคย ('write-only language')","ชุมชนนักพัฒนาเล็กและเฉพาะทาง","ไม่เหมาะสำหรับการพัฒนาแอปพลิเคชันทั่วไป"],"frameworks":["None (เป็นภาษาพื้นฐาน)","Dyalog APL","GNU APL"],"learn":["Dyalog APL Documentation","APL Wiki","Mastering Dyalog APL","Array-oriented Programming"],"variables":{"declaration (การประกาศ)":["X ← 10     ⍝ กำหนดค่า 10 ให้ตัวแปร X","ARRAY ← 1 2 3 4 5  ⍝ กำหนด Array ด้วยค่าต่างๆ"],"types (ประเภท)":["Numeric (Integer, Float, Complex) // ตัวเลข (จำนวนเต็ม, ทศนิยม, จำนวนเชิงซ้อน)","Character // ตัวอักขระ","Boolean (0, 1) // ค่าตรรกะ (0 คือ False, 1 คือ True)","Array // โครงสร้างข้อมูลหลักใน APL (สามารถมีได้หลายมิติ)"],"examples (ตัวอย่าง)":["Salary ← 50000        ⍝ ตัวแปร Scalar (เงินเดือน)","Names ← 'Alice' 'Bob' 'Charlie' ⍝ Array ของสตริง","Matrix ← 2 3 ⍴ ⍳6    ⍝ สร้าง Matrix ขนาด 2x3 จากเลข 1 ถึง 6 (1 2 3)(4 5 6)","IsActive ← 1          ⍝ ตัวแปร Boolean (True)"]},"functions":{"declaration (การประกาศ)":["∇ Z ← A FunctionName B  ⍝ ฟังก์ชัน Binary (รับ 2 Argument)","∇ Z ← FunctionName A    ⍝ ฟังก์ชัน Monadic (รับ 1 Argument)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน (Binary Function)\\n∇ Z ← A ADD B\\n  Z ← A + B\\n∇\\n","// ฟังก์ชันคูณด้วย 2 (Monadic Function)\\n∇ Z ← DOUBLE A\\n  Z ← 2 × A\\n∇\\n","// การเรียกใช้ฟังก์ชัน\\n10 ADD 20   ⍝ ผลลัพธ์ 30\\nDOUBLE 5    ⍝ ผลลัพธ์ 10\\n","// ฟังก์ชันหาผลรวมของ Array\\n∇ Z ← SUM_ARRAY A\\n  Z ← +/A   ⍝ ใช้ Reduction Operator (+/) เพื่อหาผลรวม\\n∇\\nSUM_ARRAY 1 2 3 4 5 ⍝ ผลลัพธ์ 15\\n","// ฟังก์ชันหาค่าเฉลี่ยของ Array\\n∇ Z ← AVG_ARRAY A\\n  Z ← (+/A) ÷ (⍴A)  ⍝ ผลรวมหารด้วยจำนวนสมาชิก (⍴A คือ Shape หรือจำนวนสมาชิก)\\n∇\\nAVG_ARRAY 1 2 3 4 5 ⍝ ผลลัพธ์ 3\\n"],"built_in (ในตัว)":["+ // บวก (Monadic: Positive, Binary: Addition)","- // ลบ (Monadic: Negative, Binary: Subtraction)","× // คูณ (Monadic: Signum, Binary: Multiplication)","÷ // หาร (Monadic: Reciprocal, Binary: Division)","⍳ // Index Generator (สร้างลำดับตัวเลข)","⍴ // Reshape (เปลี่ยนรูปร่าง Array) หรือ Shape (หาขนาด Array)","↑ // Take (เลือก Element จาก Array)","↓ // Drop (ละทิ้ง Element จาก Array)","? // Roll (สุ่ม) หรือ Deal (สุ่มไม่ซ้ำ)","⌹ // Matrix Inverse (ผกผันเมทริกซ์) หรือ Matrix Division (หารเมทริกซ์)",", // Ravel (เปลี่ยน Array หลายมิติเป็น Vector) หรือ Concatenate (เชื่อม Array)","⍪ // Laminate (เชื่อม Array เป็นมิติใหม่)"],"async (แนวคิด)":["// APL โดยพื้นฐานเป็นภาษาที่เน้นการประมวลผลแบบ Synchronous และ Vectorized\n// การทำงานแบบ Asynchronous หรือ Concurrency มักถูกจัดการโดยสภาพแวดล้อม APL Implementation นั้นๆ\n// เช่น Dyalog APL มีคุณสมบัติสำหรับ Parallel Computing (Multithreading) และการทำงานแบบ Non-blocking I/O ผ่าน Extensions หรือ Primitives เฉพาะ"]},"syntax":{"comments (คอมเมนต์)":["⍝ Single line comment // คอมเมนต์บรรทัดเดียว (เริ่มต้นด้วย Symbol '⍝')"],"conditions (เงื่อนไข)":["→ (Condition) / Label // Go-to based conditional branch","→ (Condition) LABEL_TRUE ⋄ 'Statement if true' ⋄ → 0  ⍝ If true then goto LABEL_TRUE, else print statement and exit","→ (Condition) LABEL_TRUE LABEL_FALSE // If true then goto LABEL_TRUE else goto LABEL_FALSE"],"loops (การวนซ้ำ)":["// APL ไม่ได้มีโครงสร้างลูป (for, while) โดยตรงเหมือนภาษาอื่นที่เน้น Imperative\n// แต่จะใช้การดำเนินการกับ Array โดยตรง (Vectorized Operations) หรือ Recursion แทน\n// For: (+/⍳N)  ⍝ ผลรวมของตัวเลข 1 ถึง N (Vectorized approach)\n// While: มักใช้ร่วมกับ Branching (→) หรือการทำซ้ำแบบ Recursive"],"operators (ตัวดำเนินการ)":["Monadic Operators (รับ 1 Argument, วางทางขวา): + (Positive), - (Negative), × (Signum), ÷ (Reciprocal), ⍳ (Iota)","Binary Operators (รับ 2 Arguments, วางตรงกลาง): + (Addition), - (Subtraction), × (Multiplication), ÷ (Division)","Scalar Functions: ทำงานแบบ Element-wise บน Array (เช่น 2 + 1 2 3 จะได้ 3 4 5)","Reduction Operators: +/ (Sum Reduction), ×/ (Product Reduction)","Scan Operators: +\\ (Cumulative Sum), ×\\ (Cumulative Product)","Outer Product: ∘. (เช่น A ∘.+ B จะได้ Matrix การบวกทุก Element ของ A กับ B)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การคำนวณ Array แบบ Vectorized (โดยไม่ต้องวนลูป)\\nC ← A + B  ⍝ บวก Array A กับ Array B แบบ Element-wise","// ตัวอย่างที่ 2: การสร้างลำดับตัวเลขและหาผลรวม\\n+/⍳10  ⍝ ผลลัพธ์ 55 (ผลรวมของตัวเลข 1 ถึง 10)\\n","// ตัวอย่างที่ 3: การเปลี่ยนรูปร่าง Array (Reshape) และการดำเนินการ Element-wise\\nMATRIX ← 2 3 ⍴ ⍳6 ⍝ สร้าง Matrix 2x3 จาก 1-6\n      MATRIX\n1 2 3\n4 5 6\n\nMATRIX × 10 ⍝ คูณทุก Element ด้วย 10\n10 20 30\n40 50 60\n","// ตัวอย่างที่ 4: การใช้งาน Reduction และ Scan Operations\\nNUMBERS ← 1 2 3 4 5\n+/NUMBERS ⍝ ผลรวม 15\n+\\NUMBERS ⍝ Cumulative Sum (1 3 6 10 15)\n","// ตัวอย่างที่ 5: การทำงานกับสตริง\\nMESSAGE ← 'Hello, APL'\n⍴MESSAGE ⍝ ความยาวของสตริง (10)\n","// ตัวอย่างที่ 6: การจัดการข้อผิดพลาด (Error Handling)\\n// APL มีกลไกการจัดการข้อผิดพลาดที่เรียกว่า 'Error Trapping' หรือ 'Monadic Error Function'\n// (⎕TRAP 'SYNTAX ERROR' 'Your_Error_Handler')\n// ซึ่งช่วยให้โปรแกรมสามารถดักจับและจัดการข้อผิดพลาดได้"]}},{"id":20,"name":"Assembly","slug":"assembly","logo":"img/asm.png","desc":"Assembly Language เป็นภาษาโปรแกรมระดับต่ำสุดที่มนุษย์อ่านได้ มีความสัมพันธ์โดยตรงกับสถาปัตยกรรมของ Processor ใช้ในการเขียนโปรแกรมที่ต้องการการควบคุมฮาร์ดแวร์อย่างสมบูรณ์แบบและประสิทธิภาพสูงสุด","by":"Various (Machine-specific)","yr":"1940s-1950s","level":"1","par":["Imperative","Procedural"],"fields":["Embedded","System","OS","Security","Digital"],"rank":"40+ Niche แต่จำเป็นสำหรับ Low-level Programming","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-95,000 บาท/เดือน (Senior)","pros":["ประสิทธิภาพสูงสุด","ควบคุมฮาร์ดแวร์ได้สมบูรณ์","ขนาดโปรแกรมเล็กมาก","ใช้ในการทำ Reverse Engineering และ Malware Analysis"],"cons":["เรียนรู้และใช้งานยากที่สุด","ต้องมีความรู้เรื่องสถาปัตยกรรม Processor อย่างลึกซึ้ง","เขียนโปรแกรมซับซ้อนได้ยากและใช้เวลานาน","โค้ดไม่สามารถนำไปใช้กับ Processor ต่างชนิดกันได้","การดีบักซับซ้อน"],"frameworks":["None"],"learn":["Assembly Language for x86 Processors","The Art of Assembly Language","NASM Documentation","MASM Documentation"],"variables":{"declaration (การประกาศ)":["section .data\n  my_var db 10 ; define byte (กำหนดค่า 1 ไบต์)\n  message db 'Hello', 0 ; define byte string (กำหนดสตริงพร้อม null terminator)"],"types (ประเภท)":["BYTE (db) // กำหนด 1 ไบต์ (8 บิต)","WORD (dw) // กำหนด 1 คำ (2 ไบต์ / 16 บิต)","DWORD (dd) // กำหนด 1 คำคู่ (4 ไบต์ / 32 บิต)","QWORD (dq) // กำหนด 1 คำสี่เท่า (8 ไบต์ / 64 บิต)","Registers (EAX, EBX, ECX, EDX, etc.) // Register ของ CPU สำหรับเก็บข้อมูลชั่วคราว"],"examples (ตัวอย่าง)":["section .data ; ส่วนสำหรับประกาศข้อมูล (data section)\n  num_val dw 1234 ; ตัวแปร num_val ขนาด Word (16-bit) ค่า 1234\n  text_msg db 'Assembly is fun!', 0 ; ตัวแปร text_msg เป็นสตริงพร้อม null terminator","section .text ; ส่วนสำหรับโค้ดคำสั่ง (code section)\n_start:\n  mov eax, 1 ; ย้ายค่า 1 ไปยัง Register EAX (สำหรับ sys_exit call)\n  mov ebx, 0 ; ย้ายค่า 0 ไปยัง Register EBX (Exit Code)\n  int 0x80 ; เรียก System Interrupt (Linux syscall)"]},"functions":{"declaration (การประกาศ)":["my_function: ; ชื่อของฟังก์ชันหรือ Subroutine\n  ; function body (เนื้อหาของฟังก์ชัน)\n  ret ; คำสั่งคืนค่าจากการเรียกใช้ฟังก์ชัน"],"examples (ตัวอย่าง)":["section .text\n  global _start\n\n_start:\n  ; Hello World ใน NASM (สำหรับ Linux x86-64)\n  mov rax, 1             ; sys_write (Linux syscall number for write)\n  mov rdi, 1             ; file descriptor 1 (stdout)\n  mov rsi, msg           ; address of string to output\n  mov rdx, len           ; length of string\n  syscall                ; Call the kernel\n\n  mov rax, 60            ; sys_exit (Linux syscall number for exit)\n  mov rdi, 0             ; exit code 0\n  syscall                ; Call the kernel\n\nsection .data\n  msg db 'Hello, World!', 0xA ; The string to print, 0xA is newline\n  len equ $ - msg           ; Length of the string"],"built_in (ในตัว)":["mov // ย้ายข้อมูลจาก Source ไป Destination","add // บวกค่า","sub // ลบค่า","jmp // กระโดดไปยังตำแหน่งโค้ดที่ระบุ (Unconditional Jump)","call // เรียก Subroutine (Push Address ไปยัง Stack แล้ว Jump)","ret // คืนค่าจากการเรียก Subroutine (Pop Address จาก Stack แล้ว Jump)","int // เรียก Software Interrupt","push // เพิ่มค่าลงใน Stack","pop // ดึงค่าออกจาก Stack","cmp // เปรียบเทียบค่าสองค่า (ตั้งค่า Flag Register)","test // ทดสอบ Bit (ตั้งค่า Flag Register)"]},"syntax":{"comments (คอมเมนต์)":["; Single line comment // คอมเมนต์บรรทัดเดียว (ขึ้นต้นด้วยเซมิโคลอน)"],"conditions (เงื่อนไข)":["cmp reg, value ; เปรียบเทียบค่าใน Register กับ Value\nje label (Jump if Equal) ; กระโดดถ้าเท่ากัน\njne label (Jump if Not Equal) ; กระโดดถ้าไม่เท่ากัน\njg label (Jump if Greater) ; กระโดดถ้ามากกว่า\njl label (Jump if Less) ; กระโดดถ้าน้อยกว่า"],"loops (การวนซ้ำ)":["loop_start: ; จุดเริ่มต้นของลูป\n  ; loop body (เนื้อหาของลูป)\n  dec ecx ; ลดค่า Register ECX ลง 1\n  jnz loop_start ; กระโดดกลับไป loop_start ถ้า ECX ไม่เท่ากับศูนย์"],"operators (ตัวดำเนินการ)":["Arithmetic: add, sub, mul, div // คำสั่งทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร","Logical: and, or, xor, not // คำสั่งตรรกะ: AND, OR, XOR, NOT","Bitwise: shl, shr, rol, ror // คำสั่ง Bitwise Shift (เลื่อนบิตซ้าย/ขวา), Rotate (หมุนบิตซ้าย/ขวา)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (Conditional Jump)\n  cmp eax, 10      ; เปรียบเทียบ EAX กับ 10\n  jg  greater_than_10 ; ถ้า EAX > 10 ให้กระโดดไป greater_than_10\n  ; code if eax <= 10 ; โค้ดส่วนนี้จะทำงานถ้า EAX น้อยกว่าหรือเท่ากับ 10\n  jmp end_if       ; กระโดดข้ามส่วน greater_than_10\ngreater_than_10:  ; Label สำหรับเมื่อ EAX > 10\n  ; code if eax > 10 ; โค้ดส่วนนี้จะทำงานถ้า EAX มากกว่า 10\nend_if:           ; จุดสิ้นสุดของเงื่อนไข","// ตัวอย่างที่ 2: การใช้วงลูป (Loop)\n  mov ecx, 3       ; กำหนดให้ Register ECX เป็น 3 (จำนวนรอบของลูป)\nloop_count:\n  ; your code here ; โค้ดที่คุณต้องการให้วนซ้ำ\n  loop loop_count  ; คำสั่ง 'loop' จะลดค่า ECX ลง 1 และกระโดดกลับไปที่ Label 'loop_count' ถ้า ECX ยังไม่เป็นศูนย์"]}},{"id":41,"name":"AWK","slug":"awk","logo":"img/awk.jpg","desc":"AWK เป็นภาษาโปรแกรมสำหรับประมวลผลข้อความและข้อมูลที่เน้นรูปแบบ (pattern-scanning and processing language) โดยเฉพาะไฟล์ข้อความหรือ Stream ของข้อมูล มีความสามารถในการอ่านไฟล์ทีละบรรทัด วิเคราะห์ตามรูปแบบที่กำหนด และดำเนินการกับข้อมูลในแต่ละ Field หรือ Record","by":"Alfred Aho, Peter Weinberger, Brian Kernighan","yr":"1977","level":"2","par":["Declarative","Procedural","Pattern-Action"],"fields":["Script","Text"],"rank":"40+ Niche ใน Text Processing และ Unix-like Systems","salary_range":"฿25,000-40,000 บาท/เดือน (Junior), ฿40,000-65,000 บาท/เดือน (Senior)","salary":["low","mid"],"pros":["ทรงพลังสำหรับการประมวลผลไฟล์ข้อความและ Log","ไวยากรณ์กระชับ เหมาะสำหรับ Scripting สั้นๆ","สามารถทำงานร่วมกับ Command Line Tools อื่นๆ ได้ดี","เป็นมาตรฐานบนระบบ Unix-like","ไม่ต้อง Compile (Interpreter-based)"],"cons":["ไม่เหมาะสำหรับงาน General-purpose programming","ไวยากรณ์อาจดูแปลกและยากสำหรับผู้เริ่มต้น","การดีบักอาจทำได้ยากสำหรับ Script ที่ซับซ้อน","ประสิทธิภาพอาจไม่สูงเท่าภาษา Compiled สำหรับงานขนาดใหญ่"],"frameworks":[],"learn":["AWK Manual","Gawk User's Guide","Awk by Example","Unix/Linux Text Processing Tutorials"],"variables":{"declaration (การประกาศ)":["// ใน AWK ไม่มีการประกาศตัวแปรล่วงหน้า ตัวแปรจะถูกสร้างขึ้นเมื่อมีการกำหนดค่าครั้งแรก","field_variable // ตัวแปรสำหรับ Field เช่น $1, $2, $NF","built-in_variables // ตัวแปร Built-in เช่น NR, NF, FILENAME, RS, FS, OFS, ORS"],"types (ประเภท)":["String // สตริง (ข้อความ)","Number (Implicit) // ตัวเลข (AWK จะแปลงเป็นตัวเลขหรือสตริงตามบริบท)"],"examples (ตัวอย่าง)":["BEGIN { total = 0; } // กำหนดตัวแปร total เป็น 0 ในบล็อก BEGIN","{ print $1, $3; } // พิมพ์ Field แรกและ Field ที่สามของแต่ละบรรทัด","{ sum = sum + $NF; } // บวกค่าใน Field สุดท้ายของแต่ละบรรทัดเข้ากับตัวแปร sum","// Built-in Variables:\n// NR (Number of Record): หมายเลขบรรทัดปัจจุบัน\n// NF (Number of Fields): จำนวน Field ในบรรทัดปัจจุบัน\n// FILENAME: ชื่อไฟล์ปัจจุบันที่กำลังประมวลผล\n// FS (Field Separator): ตัวคั่น Field (ค่าเริ่มต้นคือช่องว่าง/Tab)\n// OFS (Output Field Separator): ตัวคั่น Field สำหรับ Output (ค่าเริ่มต้นคือช่องว่าง)\n// RS (Record Separator): ตัวคั่น Record (ค่าเริ่มต้นคือ Newline)\n// ORS (Output Record Separator): ตัวคั่น Record สำหรับ Output (ค่าเริ่มต้นคือ Newline)"]},"functions":{"declaration (การประกาศ)":["function function_name(param1, param2, ...) { ... } // การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfunction add(a, b) {\n  return a + b;\n}\n","// ฟังก์ชันนับจำนวนคำในสตริง\nfunction count_words(s) {\n  return split(s, words, \" \"); // split() คืนค่าจำนวน Element ที่แบ่งได้\n}\n","// การเรียกใช้ฟังก์ชันใน AWK (จาก Action Block หรืออื่น ๆ)\n// { result = add($1, $2); print result; } // เรียกใช้ฟังก์ชัน add ด้วย Field $1 และ $2\n// { word_count = count_words($0); print \"Word count: \" word_count; } // เรียกใช้ฟังก์ชันนับคำ\n","// Built-in String Functions\n// length(string) : ความยาวของสตริง\n// substr(string, start, length) : ดึงสตริงย่อย\n// index(string, substring) : หาตำแหน่งของ substring\n// match(string, regexp) : ตรวจสอบว่าสตริงตรงกับ Regular Expression หรือไม่\n// sub(regexp, replacement, string) : แทนที่ครั้งแรกที่พบ Regular Expression\n// gsub(regexp, replacement, string) : แทนที่ทั้งหมดที่พบ Regular Expression\n// tolower(string) : แปลงเป็นตัวพิมพ์เล็ก\n// toupper(string) : แปลงเป็นตัวพิมพ์ใหญ่\n"],"built_in (ในตัว)":["print // ใช้แสดงผลข้อมูล","printf // ใช้แสดงผลข้อมูลแบบจัดรูปแบบ","getline // อ่านบรรทัดถัดไปจาก Input","next // ข้ามไปยัง Record ถัดไป","exit // ออกจากโปรแกรม AWK","split // ใช้แบ่งสตริงออกเป็น Array","length // ใช้หาความยาวของสตริง","substr // ใช้ดึงสตริงย่อย","system // ใช้รัน Command ของ Shell","close // ปิดไฟล์หรือ Pipe"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["pattern { action } // รูปแบบทั่วไป: ถ้า pattern ตรง ให้ทำ action","if (condition) { action } else { action } // คำสั่ง if-else","condition ? true_action : false_action // Ternary operator"],"loops (การวนซ้ำ)":["for (init; cond; incr) { action } // ลูป for แบบ C-style","for (var in array) { action } // ลูป for-in สำหรับวนซ้ำ Array","while (condition) { action } // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Concatenation: (space between strings) // การเชื่อมสตริง (ใช้ช่องว่าง)","~ (match), !~ (not match) // ตัวดำเนินการ Match Regular Expression"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การพิมพ์บรรทัดทั้งหมด\n// awk '{ print }' filename.txt\n","// ตัวอย่างที่ 2: การพิมพ์บรรทัดที่มีคำว่า 'error'\n// awk '/error/ { print }' logfile.log\n","// ตัวอย่างที่ 3: การประมวลผล Field (พิมพ์ Field แรกและ Field สุดท้าย)\n// awk '{ print $1, $NF }' data.txt\n","// ตัวอย่างที่ 4: การใช้ BEGIN และ END Block (คำนวณผลรวม)\n// awk 'BEGIN { sum = 0; print \"Starting sum...\"; }\n// { sum += $1; } // บวก Field แรกของแต่ละบรรทัด\n// END { print \"Total sum: \", sum; }' numbers.txt\n","// ตัวอย่างที่ 5: การตั้งค่า Field Separator (FS) และ Output Field Separator (OFS)\n// awk 'BEGIN { FS = \":\"; OFS = \" | \"; } { print $1, $NF; }' /etc/passwd\n// (จะแยก Field ด้วย ':' และพิมพ์ Field แรกกับ Field สุดท้ายโดยคั่นด้วย ' | ')\n","// ตัวอย่างที่ 6: การใช้เงื่อนไข IF-ELSE\n// awk '{ if ($2 > 100) { print $1 \" is expensive\" } else { print $1 \" is affordable\" } }' prices.txt\n","// ตัวอย่างที่ 7: การใช้วงลูป FOR\n// awk '{ for (i=1; i<=NF; i++) { print \"Field \" i \": \" $i } }' data.txt\n"]}},{"id":36,"name":"Bash","slug":"bash","logo":"img/bash.png","desc":"Bash (Bourne-Again SHell) เป็น Command Language Interpreter และ Shell Scripting Language ที่ใช้กันอย่างแพร่หลายในระบบปฏิบัติการ Linux, Unix และ macOS สำหรับการทำงานอัตโนมัติ, การจัดการระบบ, การประมวลผลไฟล์ และการทำงานผ่าน Command Line Interface (CLI)","by":"Brian Fox","yr":"1989","level":"2","par":["Imperative","Procedural","Scripting"],"fields":["Script","System","Cloud"],"rank":"ใช้โดย 28.1% ของนักพัฒนา System Administration","salary_range":"฿25,000-40,000 บาท/เดือน (Junior), ฿40,000-68,000 บาท/เดือน (Senior)","salary":["low","mid"],"pros":["ใช้งานง่ายสำหรับการจัดการระบบและไฟล์","เป็นมาตรฐานบนระบบ Unix-like ส่วนใหญ่","มีเครื่องมือ CLI จำนวนมากให้ใช้ร่วมกัน","เหมาะสำหรับงาน Automation ขนาดเล็กถึงกลาง"],"cons":["ไวยากรณ์อาจซับซ้อนและผิดพลาดได้ง่ายสำหรับงานใหญ่ๆ","ประสิทธิภาพไม่สูงเท่าภาษา Compiled","การจัดการ Error ที่ซับซ้อนอาจทำได้ยาก","ไม่เหมาะกับงานที่ต้องมีการคำนวณซับซ้อน"],"frameworks":[],"learn":["Bash Manual","Linux Command Line Basics","Shell Scripting Tutorial"],"variables":{"declaration (การประกาศ)":["variable_name=value // รูปแบบการประกาศตัวแปร"],"types (ประเภท)":["String // สตริง (ข้อความ)","Number (Implicit) // ตัวเลข (ไม่ได้มีประเภทตัวเลขชัดเจน จะถือเป็นสตริงหากไม่ระบุการคำนวณ)","Array // อาร์เรย์ (ชุดข้อมูล)"],"examples (ตัวอย่าง)":["name=\"John Doe\" // กำหนดตัวแปร name เก็บสตริง 'John Doe'","age=30 // กำหนดตัวแปร age เก็บตัวเลข 30","files=(file1.txt file2.txt) // กำหนดอาร์เรย์ files","my_path=\"/home/user/docs\" // ตัวอย่างการกำหนด Path"]},"functions":{"declaration (การประกาศ)":["function_name() { ... } // รูปแบบการประกาศฟังก์ชันแบบมี keyword 'function'","name() { ... } // รูปแบบการประกาศฟังก์ชันแบบสั้น"],"examples (ตัวอย่าง)":["// ฟังก์ชันทักทายรับพารามิเตอร์แรก\ngreet() {\n    echo \"Hello, $1!\";\n}\n","// ฟังก์ชันบวกเลขสองจำนวน\ncalculate_sum() {\n    sum=$(($1 + $2));\n    echo \"Sum: $sum\";\n}\n","// ฟังก์ชันแสดงวันที่และเวลาปัจจุบัน\nshow_datetime() {\n    date;\n}\n"],"built_in (ในตัว)":["echo // แสดงข้อความออกหน้าจอ","cd // เปลี่ยนไดเรกทอรี","ls // แสดงรายการไฟล์และไดเรกทอรี","grep // ค้นหาข้อความในไฟล์","cat // แสดงเนื้อหาไฟล์","find // ค้นหาไฟล์และไดเรกทอรี","cp // คัดลอกไฟล์/ไดเรกทอรี","mv // ย้าย/เปลี่ยนชื่อไฟล์/ไดเรกทอรี","rm // ลบไฟล์/ไดเรกทอรี","mkdir // สร้างไดเรกทอรี","pwd // แสดง Path ของไดเรกทอรีปัจจุบัน"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["if [ condition ]; then ... fi // คำสั่ง if-then-fi","if [[ condition ]]; then ... fi // คำสั่ง if-then-fi (แบบใหม่และปลอดภัยกว่า)","case value in pattern) ... ;; esac // คำสั่ง case"],"loops (การวนซ้ำ)":["for variable in list; do ... done // ลูป for สำหรับวนซ้ำในรายการ","for (( i=0; i<10; i++ )); do ... done // ลูป for สไตล์ C-like","while [ condition ]; do ... done // ลูป while"],"operators (ตัวดำเนินการ)":["Numeric Comparison: -eq (เท่ากับ), -ne (ไม่เท่ากับ), -gt (มากกว่า), -lt (น้อยกว่า), -ge (มากกว่าหรือเท่ากับ), -le (น้อยกว่าหรือเท่ากับ)","String Comparison: == (เท่ากับ), != (ไม่เท่ากับ), < (น้อยกว่า), > (มากกว่า)","Logical: && (AND), || (OR), ! (NOT)","File Test: -f (เป็นไฟล์), -d (เป็นไดเรกทอรี), -e (มีอยู่)","String Test: -z (สตริงว่าง), -n (สตริงไม่ว่าง)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nif [ $age -ge 18 ]; then\n    echo \"Adult\";\nelse\n    echo \"Minor\";\nfi\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nfor file in *.txt; do\n    echo \"Processing $file\";\ndone\n","// ตัวอย่างที่ 3: การรับอินพุตจากผู้ใช้\nread -p \"Enter your name: \" user_name;\necho \"Welcome, $user_name!\";\n","// ตัวอย่างที่ 4: การทำงานกับไฟล์ (ตรวจสอบและสร้างไดเรกทอรี)\nfolder_name=\"my_scripts\"\nif [ ! -d \"$folder_name\" ]; then\n    mkdir \"$folder_name\";\n    echo \"Directory '$folder_name' created.\";\nelse\n    echo \"Directory '$folder_name' already exists.\";\nfi\n"]}},{"id":1,"name":"C","slug":"c","logo":"img/c.png","desc":"C คือภาษาโปรแกรมที่มีประสิทธิภาพสูง ใช้สำหรับพัฒนาซอฟต์แวร์ระบบ เช่น ระบบปฏิบัติการ, ไดรเวอร์ และโปรแกรมที่ต้องการความเร็วสูง เหมาะสำหรับงานที่ต้องควบคุมฮาร์ดแวร์โดยตรง","by":"Dennis Ritchie","yr":"1972","level":"2","par":["Procedural","Imperative"],"fields":["System","Embedded","OS","Robot","Compiler","Security","Network","Tele","Graphics","HPC","Aero","Digital"],"rank":"4 ใน TIOBE Index 2025 (9.84% แต่ลดลง)","salary_range":"฿30,000-50,000 บาท/เดือน (Junior), ฿65,000-120,000 บาท/เดือน (Senior)","salary":["low","mid","high","veryhigh"],"pros":["ประสิทธิภาพสูงมาก (ใกล้เคียงภาษาเครื่อง)","ควบคุมฮาร์ดแวร์ได้ละเอียด","มีไลบรารีขนาดใหญ่และหลากหลาย","พื้นฐานสำคัญสำหรับภาษาอื่นๆ","ขนาดโปรแกรมเล็ก ประหยัดทรัพยากร"],"cons":["เรียนรู้และใช้งานยากกว่าภาษาอื่นๆ","ไม่มีการจัดการหน่วยความจำอัตโนมัติ (ต้องจัดการเอง)","โค้ดอาจอ่านยากและเข้าใจยากสำหรับผู้เริ่มต้น","ไม่มีคุณสมบัติ Object-Oriented โดยตรง","ใช้เวลาในการพัฒนาค่อนข้างนาน"],"frameworks":["None (เป็นภาษาพื้นฐาน)","OpenGL (Graphics)","GTK+ (GUI)"],"learn":["The C Programming Language (K&R)","GeeksforGeeks C Tutorial","Learn C The Hard Way","C Programming Tutorial by Tutorials Point"],"variables":{"declaration (การประกาศ)":["int age; // ประกาศตัวแปร age ชนิด int","float salary; // ประกาศตัวแปร salary ชนิด float","char initial; // ประกาศตัวแปร initial ชนิด char","double temperature; // ประกาศตัวแปร temperature ชนิด double"],"types (ประเภท)":["int // integer (จำนวนเต็ม)","float // single-precision floating-point (ทศนิยมความแม่นยำเดี่ยว)","double // double-precision floating-point (ทศนิยมความแม่นยำคู่)","char // character (ตัวอักขระ)","void // no type (ไม่มีประเภท)","short // short integer (จำนวนเต็มขนาดสั้น)","long // long integer (จำนวนเต็มขนาดยาว)","signed // signed integer (จำนวนเต็มแบบมีเครื่องหมาย)","unsigned // unsigned integer (จำนวนเต็มแบบไม่มีเครื่องหมาย)"],"examples (ตัวอย่าง)":["int count = 10; // กำหนดตัวแปร count เก็บตัวเลข 10","float price = 99.99f; // กำหนดตัวแปร price เก็บเลขทศนิยม","char grade = 'A'; // กำหนดตัวแปร grade เก็บตัวอักษร","double pi = 3.14159; // กำหนดตัวแปร pi เก็บเลขทศนิยมความละเอียดสูง","int numbers[5]; // ประกาศอาร์เรย์ของตัวเลขจำนวนเต็มขนาด 5","int *ptr; // ประกาศตัวแปร pointer ที่ชี้ไปยัง int"]},"functions":{"declaration (การประกาศ)":["return_type function_name(parameters) { /* ... */ } // การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nint add(int a, int b) {\n  return a + b;\n}\n","// ฟังก์ชันแสดงข้อความ\nvoid print_message(char *msg) {\n  printf(\"%s\\n\", msg);\n}\n","// การเรียกใช้ฟังก์ชัน\nint sum = add(5, 3); // sum จะมีค่า 8\nprint_message(\"Hello, C!\\n\"); // แสดงผล 'Hello, C!\\n'\n","// ฟังก์ชันคำนวณ factorial แบบ recursive\nlong long factorial(int n) {\n  if (n == 0)\n    return 1;\n  else\n    return n * factorial(n - 1);\n}\n","// การเรียกใช้ factorial\nlong long fact_5 = factorial(5); // fact_5 จะมีค่า 120"],"built_in (ในตัว)":["printf() // แสดงผลข้อมูล","scanf() // รับข้อมูลจากผู้ใช้","malloc() // จัดสรรหน่วยความจำแบบไดนามิก","free() // คืนหน่วยความจำที่จัดสรรไว้","strlen() // หาความยาวของสตริง","strcpy() // คัดลอกสตริง"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { /* ... */ } // ลูป for","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: &, |, ^, ~, <<, >> // ตัวดำเนินการบิตไวส์","sizeof() // ตัวดำเนินการหาขนาดของตัวแปร/ประเภทข้อมูล","& // ตัวดำเนินการ Address-of (ใช้หาที่อยู่หน่วยความจำ)","* // ตัวดำเนินการ Dereference (ใช้เข้าถึงค่าที่ pointer ชี้ไป)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nint x = 10;\nif (x > 5) {\n  printf(\"x is greater than 5\\n\");\n} else {\n  printf(\"x is not greater than 5\\n\");\n}","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (int i = 0; i < 3; i++) {\n  printf(\"Loop: %d\\n\", i);\n}","// ตัวอย่างที่ 3: การใช้ Switch Statement\nchar grade = 'B';\nswitch (grade) {\n  case 'A':\n    printf(\"Excellent!\\n\");\n    break;\n  case 'B':\n    printf(\"Very Good!\\n\");\n    break;\n  case 'C':\n    printf(\"Good!\\n\");\n    break;\n  default:\n    printf(\"Pass\\n\");\n}","// ตัวอย่างที่ 4: การใช้วงลูป (while loop)\nint count = 0;\nwhile (count < 3) {\n  printf(\"Count is: %d\\n\", count);\n  count++;\n}","// ตัวอย่างที่ 5: การใช้วงลูป (do-while loop)\nint i = 0;\ndo {\n  printf(\"Do-While Count: %d\\n\", i);\n  i++;\n} while (i < 3);","// ตัวอย่างที่ 6: การใช้งาน Structure (โครงสร้างข้อมูล)\nstruct Person {\n  char name[50];\n  int age;\n};\nstruct Person p1; // ประกาศตัวแปร struct\nstrcpy(p1.name, \"Alice\"); // กำหนดค่าให้กับสมาชิก name\np1.age = 30; // กำหนดค่าให้กับสมาชิก age\nprintf(\"Person: %s, %d years old.\\n\", p1.name, p1.age);","// ตัวอย่างที่ 7: การใช้งาน Pointer\nint num = 100;\nint *ptr = &num; // ptr เก็บที่อยู่ของ num\nprintf(\"Value of num: %d\\n\", num); // 100\nprintf(\"Address of num: %p\\n\", &num); // ที่อยู่หน่วยความจำของ num\nprintf(\"Value using pointer: %d\\n\", *ptr); // 100 (เข้าถึงค่าผ่าน pointer)","// ตัวอย่างที่ 8: การจัดการไฟล์ (File I/O) - การเขียนไฟล์\n#include <stdio.h>\nint main() {\n  FILE *fp;\n  fp = fopen(\"example.txt\", \"w\"); // เปิดไฟล์เพื่อเขียน\n  if (fp == NULL) {\n    printf(\"Error opening file!\\n\");\n    return 1;\n  }\n  fprintf(fp, \"Hello from C file!\\n\"); // เขียนข้อมูลลงไฟล์\n  fclose(fp); // ปิดไฟล์\n  printf(\"File 'example.txt' created.\\n\");\n  return 0;\n}","// ตัวอย่างที่ 9: การจัดการสตริง (String Manipulation)\n#include <string.h>\nint main() {\n  char str1[20] = \"Hello\";\n  char str2[20];\n  strcpy(str2, str1); // คัดลอก str1 ไปยัง str2\n  printf(\"Copied string: %s\\n\", str2); // แสดงผล 'Hello'\n  int len = strlen(str1); // หาความยาวของ str1\n  printf(\"Length of str1: %d\\n\", len); // แสดงผล 5\n  return 0;\n}"]}},{"id":56,"name":"Chisel","slug":"chisel","logo":"img/chisel.jfif","desc":"Chisel (Constructing Hardware In a Scala Embedded Language) เป็นภาษา Hardware Description Language (HDL) แบบ Open-source ที่ฝังอยู่ใน Scala ใช้สำหรับออกแบบวงจรดิจิทัลและสร้าง Generator ของฮาร์ดแวร์แบบ Parameterized มีจุดเด่นในการนำแนวคิดของภาษาโปรแกรมสมัยใหม่มาใช้ในการออกแบบฮาร์ดแวร์ เช่น OOP และ Functional Programming ช่วยให้การออกแบบที่ซับซ้อนทำได้ง่ายขึ้นและสามารถนำโค้ดกลับมาใช้ใหม่ได้","by":"UC Berkeley (คณะวิจัยของ Krste Asanović)","yr":"2010","level":"2","par":["Hardware Description","Functional","Object-Oriented","Metaprogramming"],"fields":["Hardware","Digital"],"rank":"Niche ในงานวิจัยและออกแบบ Hardware ที่ทันสมัย","salary_range":"฿50,000-90,000 บาท/เดือน (Junior), ฿90,000-180,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["นำเสนอการออกแบบฮาร์ดแวร์ในระดับ Abstraction ที่สูงขึ้น","ใช้ประโยชน์จากคุณสมบัติของ Scala (OOP, Functional, Metaprogramming)","ช่วยให้สร้าง Hardware Generator ที่ยืดหยุ่นและ Parameterized ได้ง่าย","ลดข้อผิดพลาดในการออกแบบฮาร์ดแวร์ที่ซับซ้อน","สามารถ Compile เป็น Verilog (หรือ FIRRTL) เพื่อสังเคราะห์ได้"],"cons":["ต้องมีความรู้ทั้ง Scala และแนวคิดการออกแบบฮาร์ดแวร์","Learning Curve สูงมากสำหรับผู้เริ่มต้น","Ecosystem และ Community ยังเล็กกว่า Verilog/VHDL","การดีบักซับซ้อนเมื่อเกิดปัญหาทั้งในส่วน Scala และ Generated Hardware","เวลาในการสังเคราะห์อาจนานสำหรับ Designs ขนาดใหญ่"],"frameworks":["FIRRTL (Intermediate Representation)","RISC-V (Processor Architecture often designed with Chisel)"],"learn":["Chisel Website","Chisel Tutorial (UC Berkeley)","Digital Design with Chisel (book/online)"],"variables":{"declaration (การประกาศ)":["val myWire = Wire(UInt(8.W)) // การประกาศ Wire ขนาด 8 บิต","val myReg = RegInit(0.U(8.W)) // การประกาศ Register ขนาด 8 บิต พร้อมค่าเริ่มต้น 0","val myInput = IO(Input(UInt(4.W))) // การประกาศ Input Port ขนาด 4 บิต"],"types (ประเภท)":["UInt // Unsigned Integer (จำนวนเต็มบวก)","SInt // Signed Integer (จำนวนเต็มมีเครื่องหมาย)","Bool // Boolean (True/False)","FixedPoint // Fixed-point number","Bundle // กลุ่มของ Signals (คล้าย Struct)","Vec // Array ของ Signals (Vector)","Clock // สัญญาณ Clock","Reset // สัญญาณ Reset"],"examples (ตัวอย่าง)":["val dataIn = IO(Input(UInt(16.W))) // ประกาศ Input Port ชื่อ dataIn ขนาด 16 บิต (UInt)","val dataOut = IO(Output(UInt(16.W))) // ประกาศ Output Port ชื่อ dataOut ขนาด 16 บิต (UInt)","val counter = RegInit(0.U(8.W)) // ประกาศ Register ชื่อ counter ขนาด 8 บิต พร้อมค่าเริ่มต้น 0","val stateMachine = RegInit(Idle.Type) // ประกาศ Register สำหรับ State Machine"]},"functions":{"declaration (การออกแบบ Hardware)":["class MyModule extends Module { /* ... */ } // การประกาศ Module (บล็อกของฮาร์ดแวร์)","myOutput := myInput + 1.U // การกำหนดค่าแบบ Combinational Logic (:=)","when(condition) { /* ... */ } .elsewhen(anotherCondition) { /* ... */ } .otherwise { /* ... */ } // คำสั่ง Conditional (เมื่อเงื่อนไขเป็นจริง)","myReg := nextValue // การกำหนดค่าแบบ Sequential Logic (สำหรับ Register)"],"examples (ตัวอย่าง)":["// Module: Adder (วงจรบวก)\\nclass Adder extends Module {\\n  val io = IO(new Bundle {\\n    val a = Input(UInt(8.W))\\n    val b = Input(UInt(8.W))\\n    val sum = Output(UInt(8.W))\\n  })\\n  io.sum := io.a + io.b\\n}\\n","// Module: Counter (วงจรนับ)\\nclass MyCounter extends Module {\\n  val io = IO(new Bundle {\\n    val en = Input(Bool())\\n    val out = Output(UInt(8.W))\\n  })\\n  val counter = RegInit(0.U(8.W))\\n  when(io.en) {\\n    counter := counter + 1.U\\n  }\\n  io.out := counter\\n}\\n","// Conditional Logic: Multiplexer\\nclass Mux2 extends Module {\\n  val io = IO(new Bundle {\\n    val sel = Input(Bool())\\n    val in0 = Input(UInt(4.W))\\n    val in1 = Input(UInt(4.W))\\n    val out = Output(UInt(4.W))\\n  })\\n  when(io.sel) {\\n    io.out := io.in1\\n  } .otherwise {\\n    io.out := io.in0\\n  }\\n}\\n","// FSM (Finite State Machine) Example (Conceptual)\\n// val state = RegInit(Idle)\\n// when(state === Idle) {\\n//   when(inputReady) { state := Busy }\\n// } .elsewhen(state === Busy) {\\n//   when(taskDone) { state := Idle }\\n// }\\n"],"built_in (ในตัว)":["Module // Class พื้นฐานสำหรับ Module ของฮาร์ดแวร์","IO() // ฟังก์ชันสำหรับประกาศ Input/Output Port","Input() // กำหนด Input Port","Output() // กำหนด Output Port","Wire() // สร้าง Signal แบบ Combinational (ไม่เก็บสถานะ)","RegInit() // สร้าง Register พร้อมค่าเริ่มต้น (Sequential Logic)",":= // ตัวดำเนินการกำหนดค่า (Assign) Signal (Combinational)","<= // ตัวดำเนินการกำหนดค่า (Assign) Register (Sequential)","when() // เริ่มต้น Conditional Block","otherwise() // กรณีอื่นๆ ใน Conditional Block","printf() // (สำหรับ Simulation/Debugging) แสดงผลข้อความ","assert() // (สำหรับ Verification) ตรวจสอบเงื่อนไข"],"async (Parallelism inherent in Hardware)":["// Chisel เป็นภาษาสำหรับ Hardware Description ซึ่งโดยธรรมชาติแล้วการทำงานของ Hardware เป็นแบบขนาน (Parallel) อยู่แล้ว\\n// คำสั่งต่างๆ ใน Chisel จะถูกตีความเป็นการเชื่อมต่อวงจรที่ทำงานพร้อมกัน\\n// ดังนั้นจึงไม่มีแนวคิด 'Asynchronous Programming' เหมือนใน Software ที่ทำงานบน CPU ตัวเดียว\\n// Logic ทั้งหมดภายใน Module จะทำงานแบบ Concurrent (ขนานกัน) โดยตรง"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว (เหมือน Scala/Java)","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด (เหมือน Scala/Java)"],"conditions (เงื่อนไข)":["when(condition) { /* ... */ } .elsewhen(anotherCondition) { /* ... */ } .otherwise { /* ... */ } // คำสั่งเมื่อ (when/elsewhen/otherwise)","Mux(sel, in1, in0) // Multiplexer (เลือกค่าตามเงื่อนไข)"],"loops (การวนซ้ำ)":["for (i <- 0 until N) { /* ... */ } // ลูป for-in (สำหรับการสร้าง Hardware ซ้ำๆ เช่น Array ของ Logic Gates)","// Chisel มักจะใช้ Loops ในการสร้างโครงสร้าง Hardware ซ้ำๆ (Hardware Generation)\\n// ไม่ได้ใช้สำหรับการวนซ้ำในรันไทม์เหมือนภาษา Software"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Bitwise: &, |, ^, ~ // ตัวดำเนินการระดับบิต (AND, OR, XOR, NOT)","Shift: <<, >> // ตัวดำเนินการ Shift","Comparison: ===, =/=, <, <=, >, >= // ตัวดำเนินการเปรียบเทียบ (เท่ากับ, ไม่เท่ากับ, น้อยกว่า ฯลฯ)",":= // การกำหนดค่า Combinational (Continuous Assignment)","<= // การกำหนดค่า Sequential (Register Assignment)",".asUInt, .asSInt, .asBool // การแปลง Type",".io // เข้าถึง Input/Output Port ของ Module"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ when/otherwise (Conditional Logic)\\nval inputA = IO(Input(UInt(1.W)))\\nval inputB = IO(Input(UInt(1.W)))\\nval select = IO(Input(Bool()))\\nval outputZ = IO(Output(UInt(1.W)))\\nwhen(select) {\\n  outputZ := inputA\\n} .otherwise {\\n  outputZ := inputB\\n}\\n","// ตัวอย่างที่ 2: การใช้ Loops เพื่อสร้าง Array ของ Hardware\\n// สร้าง Adder 8 ตัวพร้อมกัน\\nclass VectorAdder extends Module {\\n  val io = IO(new Bundle {\\n    val inA = Input(Vec(8, UInt(4.W)))\\n    val inB = Input(Vec(8, UInt(4.W)))\\n    val sum = Output(Vec(8, UInt(4.W)))\\n  })\\n  for (i <- 0 until 8) {\\n    io.sum(i) := io.inA(i) + io.inB(i)\\n  }\\n}\\n","// ตัวอย่างที่ 3: การใช้ Mux (Multiplexer)\\nval control = IO(Input(Bool()))\\nval data0 = IO(Input(UInt(8.W)))\\nval data1 = IO(Input(UInt(8.W)))\\nval result = IO(Output(UInt(8.W)))\\nresult := Mux(control, data1, data0) // ถ้า control เป็น true ใช้ data1, ไม่งั้นใช้ data0\\n","// ตัวอย่างที่ 4: การทำงานกับ Registers และ Reset\\nval enableSignal = IO(Input(Bool()))\\nval outputReg = IO(Output(UInt(8.W)))\\nval myRegister = RegInit(0.U(8.W))\\nwhen(enableSignal) {\\n  myRegister := myRegister + 1.U\\n}\\noutputReg := myRegister\\n// เมื่อ Reset (Global Reset) myRegister จะถูกตั้งค่าเป็น 0"]}},{"id":30,"name":"Clojure","slug":"clojure","logo":"img/clojure.png","desc":"Clojure เป็นภาษา Functional Programming ในตระกูล Lisp ที่ทำงานบน JVM (Java Virtual Machine) มีจุดเด่นด้าน Persistent Data Structures, Concurrency ที่แข็งแกร่ง และการพัฒนาแบบ Interactive Development (REPL) เป็นที่นิยมใน Data Science, Web Development (ClojureScript) และ Distributed Systems สำหรับการสร้างแอปพลิเคชันที่ทนทานและมีประสิทธิภาพสูง","by":"Rich Hickey","yr":"2021","level":"3","par":["Functional","Concurrent","Dynamic","Lisp"],"fields":["Backend","Compiler"],"rank":"35-40 Niche ใน Functional Programming บน JVM","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-92,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["Functional Programming ที่บริสุทธิ์ ช่วยให้โค้ด Predictable","Concurrency ที่แข็งแกร่งและจัดการได้ง่าย","Persistent Data Structures ลด Mutability Bug","Interactive Development (REPL) ที่ยอดเยี่ยม","ทำงานร่วมกับ Java Ecosystem ได้อย่างสมบูรณ์","เหมาะสำหรับระบบที่ซับซ้อนและต้องการความทนทาน"],"cons":["Learning Curve สูงมาก (แนวคิด Functional Programming, Syntax แบบ Lisp)","ไวยากรณ์ (Parentheses) อาจดูแปลกสำหรับผู้เริ่มต้น","Community เล็กกว่าภาษาหลักทั่วไป","เวลาในการ Startup ของ JVM อาจช้าสำหรับ Script เล็กๆ","Debugging อาจท้าทายกว่า"],"frameworks":["Luminus (Web)","Reagent (Frontend with ClojureScript)","yada (Web API)"],"learn":["Clojure.org Official Guide","Brave Clojure (Book)","Clojure for the Brave and True","Practicalli Clojure"],"variables":{"declaration (การประกาศ)":["(def x 10) ; การประกาศตัวแปร Global (def)","(let [y 20] y) ; การประกาศตัวแปร Local (let)","(def name \"Alice\") ; การประกาศตัวแปรสตริง Global"],"types (ประเภท)":["Numbers (integers, floats) // ตัวเลข (จำนวนเต็ม, ทศนิยม)","Strings // ข้อความ","Booleans (true, false) // ค่าความจริง","Keywords (:keyword) // Keyword (มักใช้เป็น Key ใน Map)","Symbols (my-var) // Symbol (ใช้เป็นชื่อตัวแปร, ฟังก์ชัน)","Lists // รายการ (โครงสร้างข้อมูลแบบ Linked List)","Vectors // Vector (คล้าย Array, เข้าถึงด้วย Index)","Maps // Map (Key-Value store, คล้าย Hash/Dictionary)","Sets // Set (ชุดของค่าที่ไม่ซ้ำกัน)"],"examples (ตัวอย่าง)":["(def counter 0) ; กำหนดตัวแปร Global counter เป็น 0","(def message \"Hello, Clojure!\") ; กำหนดตัวแปร Global message เป็นสตริง","(def is-active true) ; กำหนดตัวแปร Global is-active เป็น Boolean","(def numbers [1 2 3]) ; สร้าง Vector ของตัวเลข","(def user-profile {:name \"Eve\", :age 35}) ; สร้าง Map ด้วย Keyword Keys"]},"functions":{"declaration (การประกาศ)":["(defn func-name [param1 param2] ; code ) ; การประกาศฟังก์ชัน (defn)","(def add (fn [a b] (+ a b))) ; Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\n(defn add [a b]\n  (+ a b))\n(def result (add 5 3)) ; result จะมีค่า 8\n(println (str \"Sum: \" result)) ; แสดงผล \"Sum: 8\"\n","// ฟังก์ชันทักทาย\n(defn greet [name]\n  (println (str \"Hello, \" name \"!\")))\n(greet \"World\") ; แสดงผล 'Hello, World!'\n","// ฟังก์ชันที่รับหลาย Arity (จำนวน Arguments)\n(defn multi-greet\n  ([] (println \"Hello, stranger!\")) ; ไม่มี arguments\n  ([name] (println (str \"Hello, \" name \"!\")))) ; หนึ่ง argument\n(multi-greet) ; Hello, stranger!\n(multi-greet \"Alice\") ; Hello, Alice!\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\n(defn operate [f a b]\n  (f a b))\n(def op-result (operate + 10 5)) ; op-result จะมีค่า 15\n(println (str \"Operation Result: \" op-result)) ; แสดงผล \"Operation Result: 15\"\n","// Asynchronous Programming (core.async)\n// Clojure ใช้ core.async library สำหรับ Asynchronous และ Concurrency\n// ซึ่งใช้แนวคิด CSP (Communicating Sequential Processes)\n/*\n(ns my-app.core\n  (:require [clojure.core.async :as a]))\n\n(defn long-task [ch]\n  (a/go\n    (println \"Starting long task...\")\n    (a/<! (a/timeout 1000)) ; รอ 1 วินาที\n    (println \"Long task finished!\")\n    (a/>! ch \"Data from async source\"))) ; ส่งข้อมูลไปยัง Channel\n\n(defn -main []\n  (let [result-chan (a/chan)]\n    (long-task result-chan)\n    (println \"Main program continues...\")\n    (let [result (a/<!! result-chan)] ; บล็อกเพื่อรอผลลัพธ์จาก Channel\n      (println (str \"Received: \" result)))))\n*/"],"built_in (ในตัว)":["println // ใช้แสดงผลข้อมูลออกทาง Console","str // ใช้เชื่อมสตริง","+, -, *, / // ตัวดำเนินการทางคณิตศาสตร์ (เป็นฟังก์ชัน)","map // ใช้แปลงทุก Element ใน Collection","filter // ใช้กรอง Element ใน Collection","reduce // ใช้ลด (Reduce) Collection","if // คำสั่งเงื่อนไข","cond // คำสั่งเงื่อนไขที่ยืดหยุ่นกว่า if","loop/recur // ใช้สร้างลูปแบบ Recursive (Tail Call Optimization)","def // กำหนด Global Variable/Function","defn // กำหนด Function"]},"syntax":{"comments (คอมเมนต์)":["; Single-line comment ; คอมเมนต์บรรทัดเดียว","(comment\\n  Multi-line\\n  comment) ; คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["(if condition ; true-branch ; false-branch ) ; คำสั่ง if-else (เป็น Expression ที่คืนค่า)","(cond\\n  (> x 10) \"Greater\"\\n  (< x 5) \"Smaller\"\\n  :else \"Middle\") ; คำสั่ง cond (หลายเงื่อนไข)"],"loops (การวนซ้ำ)":["(doseq [x [1 2 3]] (println x)) ; ลูป doseq (สำหรับ Side Effects)","(loop [i 0] (when (< i 3) (println i) (recur (inc i)))) ; ลูป loop/recur (Recursive Loop)","; Functional approaches like map, reduce are more common ; โดยทั่วไปจะใช้ map, reduce หรือ for comprehensions มากกว่า"],"operators (ตัวดำเนินการ)":["; Operators are functions: (+ 1 2), (- 5 3) ; ตัวดำเนินการคือฟังก์ชัน (Infix Notation แบบ Lisp)","Arithmetic: +, -, *, /, rem // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, เศษเหลือ","Comparison: =, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not // ตัวดำเนินการตรรกะ: AND, OR, NOT"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else\n(def age 20)\n(if (>= age 18)\n  (println \"Adult\")\n  (println \"Minor\"))\n","// ตัวอย่างที่ 2: การใช้วงลูป Dotimes\n(dotimes [i 3] (println (str \"Loop: \" i)))\n","// ตัวอย่างที่ 3: การใช้ Cond (Conditional)\n(def score 75)\n(cond\n  (>= score 90) (println \"Grade A\")\n  (>= score 70) (println \"Grade B\")\n  :else (println \"Grade C\"))\n","// ตัวอย่างที่ 4: การทำงานกับ List และ Vector\n(def my-list '(1 2 3))\n(def my-vector [\"a\" \"b\" \"c\"])\n(println (first my-list)) ; 1\n(println (nth my-vector 1)) ; \"b\"\n(println (conj my-list 0)) ; (0 1 2 3) (สร้าง List ใหม่)\n(println (conj my-vector 4)) ; [1 2 3 4] (สร้าง Vector ใหม่)\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\n(try\n  (/ 10 0) ; จะเกิด ArithmeticException\n  (catch ArithmeticException e\n    (println (str \"Caught error: \" (.getMessage e)))) ; ดักจับและพิมพ์ข้อความ error\n  (finally\n    (println \"Execution finished.\")))\n","// ตัวอย่างที่ 6: การทำงานกับ Map และ Destructuring\n(def user {:name \"Dave\", :age 40, :city \"Berlin\"})\n(println (:name user)) ; \"Dave\"\n(let [{:keys [name age]} user]\n  (println (str name \" is \" age \" years old.\"))) ; \"Dave is 40 years old.\"\n"]}},{"id":22,"name":"COBOL","slug":"cobol","logo":"img/cobol.png","desc":"COBOL (Common Business-Oriented Language) เป็นภาษาโปรแกรมที่เก่าแก่และถูกออกแบบมาเพื่อการประมวลผลข้อมูลทางธุรกิจโดยเฉพาะ มักใช้ในระบบ Mainframe ของธนาคารและหน่วยงานรัฐบาล","by":"CODASYL Committee","yr":"1959","level":"1","par":["Procedural","Imperative"],"fields":["Finance"],"rank":"45+ ลดลงแต่ยังจำเป็นใน Legacy Banking Systems","salary_range":"฿25,000-42,000 บาท/เดือน (Junior), ฿42,000-75,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["เสถียรและเชื่อถือได้สำหรับงาน Business Critical","มีประสิทธิภาพสูงในการประมวลผลข้อมูลจำนวนมาก (Batch Processing)","อ่านง่าย (คล้ายภาษาอังกฤษ)","เหมาะสำหรับระบบ Mainframe ที่ยังคงใช้งานอยู่"],"cons":["ล้าสมัยและไม่เหมาะกับการพัฒนาสมัยใหม่","ทรัพยากรการเรียนรู้และนักพัฒนามีน้อย","การปรับตัวเข้ากับเทคโนโลยีใหม่ๆ ทำได้ยาก","มี Learning Curve สำหรับผู้เริ่มต้น","ค่าใช้จ่ายในการบำรุงรักษาสูง"],"frameworks":["None (เป็นภาษาพื้นฐาน)"],"learn":["OpenCOBOL Programmer's Guide","COBOL Tutorial","IBM COBOL Documentation"],"variables":{"declaration (การประกาศ)":["01 WS-EMP-REC. // การประกาศ Record Level (Level 01)\n   05 WS-EMP-ID   PIC 9(5). // Field ระดับ 05, ตัวเลข 5 หลัก\n   05 WS-EMP-NAME PIC X(30). // Field ระดับ 05, ตัวอักษร 30 ตัว"],"types (ประเภท)":["PIC 9(n) // Numeric (ตัวเลข n หลัก)","PIC X(n) // Alphanumeric (ตัวอักษร n ตัว หรือตัวเลขรวมกัน)","PIC A(n) // Alphabetic (ตัวอักษร n ตัวเท่านั้น)","COMP // Binary (สำหรับเลขฐานสอง, Internal Representation)","DISPLAY // Character (Standard Character Representation)"],"examples (ตัวอย่าง)":["DATA DIVISION. // ส่วนสำหรับประกาศข้อมูล\nWORKING-STORAGE SECTION. // ส่วนสำหรับประกาศตัวแปรที่ใช้ชั่วคราว\n01 WS-CUSTOMER-NAME PIC X(20) VALUE 'John Doe'. // ตัวแปรสตริงชื่อ WS-CUSTOMER-NAME ขนาด 20 ตัวอักษร มีค่าเริ่มต้น 'John Doe'\n01 WS-QUANTITY      PIC 9(3) VALUE 123. // ตัวแปรตัวเลขชื่อ WS-QUANTITY ขนาด 3 หลัก มีค่าเริ่มต้น 123\n01 WS-TOTAL-PRICE   PIC 9(5)V99. // ตัวแปรตัวเลขทศนิยม 5 หลักหน้าจุด 2 หลักหลังจุด\n\nPROCEDURE DIVISION. // ส่วนสำหรับโค้ดคำสั่ง\n    MOVE 'Jane Smith' TO WS-CUSTOMER-NAME. // กำหนดค่า 'Jane Smith' ให้กับตัวแปร WS-CUSTOMER-NAME\n    ADD 10 TO WS-QUANTITY. // บวก 10 เข้าไปใน WS-QUANTITY\n    MULTIPLY 5.00 BY WS-QUANTITY GIVING WS-TOTAL-PRICE. // คูณ 5.00 ด้วย WS-QUANTITY แล้วเก็บผลลัพธ์ใน WS-TOTAL-PRICE"]},"functions":{"declaration (การประกาศ)":["SECTION-NAME SECTION. // การประกาศ Section (เหมือนกลุ่มฟังก์ชัน)\nPARAGRAPH-NAME. // การประกาศ Paragraph (เหมือนฟังก์ชันย่อย/Subroutine)\n    STATEMENT. // คำสั่ง COBOL\n    EXIT. // ออกจาก Paragraph"],"examples (ตัวอย่าง)":["PROCEDURE DIVISION. // จุดเริ่มต้นของ Logic Program\nMAIN-LOGIC SECTION. // การประกาศ Section หลัก\n    DISPLAY 'Hello, COBOL!'. // แสดงข้อความออกทาง Console\n    PERFORM CALCULATE-SUM. // เรียกใช้ Paragraph ชื่อ CALCULATE-SUM\n    STOP RUN. // หยุดการทำงานของโปรแกรม\n\nCALCULATE-SUM SECTION. // การประกาศ Section สำหรับคำนวณผลรวม\n    ADD WS-AMOUNT-1 TO WS-AMOUNT-2 GIVING WS-TOTAL-AMOUNT. // บวก WS-AMOUNT-1 กับ WS-AMOUNT-2 เก็บใน WS-TOTAL-AMOUNT\n    DISPLAY 'Total is: ' WS-TOTAL-AMOUNT. // แสดงผลรวม\n    EXIT. // ออกจาก Section/Paragraph\n","// การเรียกใช้ฟังก์ชัน/Paragraphs\n// ใน COBOL เราใช้คำสั่ง PERFORM เพื่อเรียกใช้ Paragraph หรือ Section อื่นๆ\n// ซึ่งคล้ายกับการเรียกฟังก์ชันในภาษาอื่น\n// ตัวอย่างที่ 1: PERFORM เพื่อรัน Paragraph ครั้งเดียว\n// PERFORM INITIALIZE-VARIABLES.\n// ตัวอย่างที่ 2: PERFORM เพื่อรัน Paragraph ซ้ำๆ ตามจำนวนครั้ง\n// PERFORM PROCESS-RECORDS 10 TIMES.\n// ตัวอย่างที่ 3: PERFORM เพื่อรัน Paragraph ซ้ำๆ จนกว่าเงื่อนไขจะเป็นจริง\n// PERFORM PROCESS-NEXT-ITEM UNTIL END-OF-FILE."],"built_in (ในตัว)":["DISPLAY // ใช้แสดงผลข้อมูลออกทาง Console","ACCEPT // ใช้รับข้อมูลจากผู้ใช้งาน","MOVE // ใช้กำหนดค่าจากตัวแปรหนึ่งไปยังอีกตัวแปรหนึ่ง","ADD // ใช้บวกเลข","SUBTRACT // ใช้ลบเลข","MULTIPLY // ใช้คูณเลข","DIVIDE // ใช้หารเลข","COMPUTE // ใช้คำนวณนิพจน์ทางคณิตศาสตร์ที่ซับซ้อน","STRING // ใช้เชื่อมสตริง","UNSTRING // ใช้แยกสตริง"],"async (แนวคิด)":["// COBOL เป็นภาษาที่ออกแบบมาสำหรับการประมวลผลแบบ Batch Processing (Sequential)\n// จึงไม่มีแนวคิดเรื่อง Asynchronous Programming แบบ Native เหมือนภาษาสมัยใหม่\n// การทำงานแบบ Concurrency หรือ Multithreading มักถูกจัดการในระดับของระบบปฏิบัติการ (Mainframe) หรือผ่าน Extensions/Middleware เฉพาะ"]},"syntax":{"comments (คอมเมนต์)":["* This is a comment line // คอมเมนต์บรรทัดเดียว (ขึ้นต้นด้วย * ใน Column 7)","*> Another comment line // คอมเมนต์บรรทัดเดียว (ขึ้นต้นด้วย *> ใน Column 7)","// This is a free-form comment (COBOL 2002+ standard) // คอมเมนต์แบบ Free-form (ในเวอร์ชันใหม่)"],"conditions (เงื่อนไข)":["IF condition THEN\n    statement(s)\nELSE\n    statement(s)\nEND-IF. // คำสั่ง IF-ELSE (ต้องมี END-IF ปิดท้าย)","EVALUATE expression\n    WHEN value1\n        statement(s)\n    WHEN value2\n        statement(s)\n    WHEN OTHER\n        statement(s)\nEND-EVALUATE. // คำสั่ง EVALUATE (คล้าย Switch)"],"loops (การวนซ้ำ)":["PERFORM VARYING I FROM 1 BY 1 UNTIL I > 10\n    statement(s)\nEND-PERFORM. // ลูป PERFORM VARYING (วนซ้ำโดยใช้ตัวแปรนับ)","PERFORM paragraph-name THRU paragraph-end UNTIL condition. // รัน Paragraph ซ้ำๆ จนกว่าเงื่อนไขเป็นจริง"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, ยกกำลัง","Comparison: IS EQUAL TO, IS NOT EQUAL TO, IS GREATER THAN, IS LESS THAN, IS GREATER THAN OR EQUAL TO, IS LESS THAN OR EQUAL TO // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: AND, OR, NOT // ตัวดำเนินการตรรกะ: AND, OR, NOT"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ IF-ELSE\n    WORKING-STORAGE SECTION.\n    01 WS-AGE PIC 99 VALUE 20.\n    PROCEDURE DIVISION.\n    MAIN-PARA.\n        IF WS-AGE IS GREATER THAN 18 THEN\n            DISPLAY 'Adult'\n        ELSE\n            DISPLAY 'Minor'\n        END-IF.\n        STOP RUN.\n","// ตัวอย่างที่ 2: การใช้ PERFORM VARYING (Loop)\n    WORKING-STORAGE SECTION.\n    01 I PIC 9 VALUE 0.\n    PROCEDURE DIVISION.\n    MAIN-PARA.\n        PERFORM VARYING I FROM 1 BY 1 UNTIL I > 3\n            DISPLAY 'Loop COBOL: ' I\n        END-PERFORM.\n        STOP RUN.\n","// ตัวอย่างที่ 3: การใช้ EVALUATE (Switch-like)\n    WORKING-STORAGE SECTION.\n    01 WS-GRADE PIC X VALUE 'B'.\n    PROCEDURE DIVISION.\n    MAIN-PARA.\n        EVALUATE WS-GRADE\n            WHEN 'A'\n                DISPLAY 'Excellent!'\n            WHEN 'B'\n                DISPLAY 'Very Good!'\n            WHEN OTHER\n                DISPLAY 'Needs Improvement'\n        END-EVALUATE.\n        STOP RUN.\n","// ตัวอย่างที่ 4: การจัดการไฟล์ (Sequential File Input/Output)\n    ENVIRONMENT DIVISION.\n    INPUT-OUTPUT SECTION.\n    FILE-CONTROL.\n        SELECT INPUT-FILE ASSIGN TO 'input.txt'\n            ORGANIZATION IS SEQUENTIAL\n            ACCESS MODE IS SEQUENTIAL.\n    DATA DIVISION.\n    FILE SECTION.\n    FD INPUT-FILE.\n    01 INPUT-RECORD PIC X(80).\n    WORKING-STORAGE SECTION.\n    01 WS-EOF-FLAG PIC X VALUE 'N'.\n        88 EOF-REACHED VALUE 'Y'.\n    PROCEDURE DIVISION.\n    MAIN-PROCESS.\n        OPEN INPUT INPUT-FILE.\n        PERFORM READ-NEXT-RECORD.\n        PERFORM PROCESS-RECORDS UNTIL EOF-REACHED.\n        CLOSE INPUT-FILE.\n        STOP RUN.\n\n    READ-NEXT-RECORD.\n        READ INPUT-FILE NEXT RECORD\n            AT END SET EOF-REACHED TO TRUE\n        END-READ.\n\n    PROCESS-RECORDS.\n        DISPLAY 'Read: ' INPUT-RECORD.\n        PERFORM READ-NEXT-RECORD."]}},{"id":2,"name":"C++","slug":"cpp","logo":"img/cpp.png","desc":"C++ คือภาษาโปรแกรมที่พัฒนาต่อยอดมาจาก C โดยเพิ่มความสามารถเชิงวัตถุ (Object-Oriented Programming) ทำให้สามารถสร้างโปรแกรมที่ซับซ้อนและมีโครงสร้างที่ดีได้ เหมาะสำหรับเกม, ซอฟต์แวร์ประสิทธิภาพสูง และระบบฝังตัว","by":"Bjarne Stroustrup","yr":"1979","level":"3","par":["Multi-paradigm","Object-Oriented","Procedural","Generic"],"fields":["Game","Desktop","System","Compiler","VR","Security","Robot","Network","Finance","Plugin","HPC","Aero","Graphics","Render","Digital"],"rank":"2 ใน TIOBE Index 2025 (11.37% และเติบโตแรง)","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-90,000 บาท/เดือน (Senior)","salary":["low","mid","high","veryhigh"],"pros":["ประสิทธิภาพสูงมาก (ใกล้เคียง C)","รองรับการเขียนโปรแกรมเชิงวัตถุ (OOP)","ควบคุมฮาร์ดแวร์และหน่วยความจำได้ละเอียด","ใช้งานได้หลากหลายแพลตฟอร์ม","มีไลบรารีมาตรฐานที่ทรงพลัง (STL)"],"cons":["มีความซับซ้อนในการเรียนรู้และใช้งาน","การจัดการหน่วยความจำด้วยตนเองอาจเกิดข้อผิดพลาดได้ง่าย","เวลาในการคอมไพล์โปรเจกต์ขนาดใหญ่อาจนาน","Syntax และคุณสมบัติของภาษามีความซับซ้อนมาก","การดีบักอาจทำได้ยากกว่าภาษาที่มี abstraction สูง"],"frameworks":["Qt (GUI)","Boost (General Purpose)","Unreal Engine (Game Dev)","SFML (Game Dev)"],"learn":["C++ Primer","Effective Modern C++","learncpp.com","GeeksforGeeks C++ Tutorial"],"variables":{"declaration (การประกาศ)":["int num; // การประกาศตัวแปรจำนวนเต็ม","std::string text; // การประกาศตัวแปรสตริง","bool isValid; // การประกาศตัวแปรบูลีน"],"types (ประเภท)":["int // จำนวนเต็ม","float // ทศนิยมความแม่นยำเดี่ยว","double // ทศนิยมความแม่นยำคู่","char // ตัวอักขระ","bool // ค่าจริงหรือเท็จ","long // จำนวนเต็มขนาดยาว","short // จำนวนเต็มขนาดสั้น","unsigned // ไม่มีเครื่องหมาย (สำหรับจำนวนเต็ม)","std::string // สตริง (จากไลบรารีมาตรฐาน)"],"examples (ตัวอย่าง)":["int score = 100; // กำหนดตัวแปร score เก็บตัวเลข 100","double pi = 3.14; // กำหนดตัวแปร pi เก็บเลขทศนิยม","std::string name = \"Alice\"; // กำหนดตัวแปร name เก็บข้อความ","bool is_active = true; // กำหนดตัวแปร is_active เก็บค่าความจริง","int grades[5] = {90, 85, 70, 95, 80}; // ประกาศและกำหนดค่าอาร์เรย์","int* ptr_score = &score; // ประกาศ pointer และชี้ไปยัง score"]},"functions":{"declaration (การประกาศ)":["return_type function_name(parameters) { /* ... */ } // การประกาศฟังก์ชันทั่วไป","// Class member function (ฟังก์ชันสมาชิกคลาส)\nclass MyClass { \npublic: \n  void myMethod(); \n};"],"examples (ตัวอย่าง)":["// ฟังก์ชันคูณเลขสองจำนวน\nint multiply(int a, int b) {\n  return a * b;\n}\n","// ฟังก์ชันแสดงผล Vector (ใช้ STL)\n#include <vector>\n#include <iostream>\nvoid print_vector(const std::vector<int>& vec) {\n  for (int x : vec) { \n    std::cout << x << \" \"; \n  }\n  std::cout << std::endl;\n}\n","// ฟังก์ชัน Overloading (ชื่อฟังก์ชันเดียวกันแต่พารามิเตอร์ต่างกัน)\nint add(int a, int b) { return a + b; }\ndouble add(double a, double b) { return a + b; }\n","// การเรียกใช้ฟังก์ชัน\nint product = multiply(4, 2); // product จะมีค่า 8\nstd::vector<int> numbers = {1, 2, 3};\nprint_vector(numbers); // แสดงผล '1 2 3'\n","// การเรียกใช้ฟังก์ชัน Overloading\nint sum_int = add(10, 20); // เรียก add(int, int)\ndouble sum_double = add(10.5, 20.5); // เรียก add(double, double)"],"built_in (ในตัว)":["std::cout // ใช้แสดงผลข้อมูลออกทาง Console","std::cin // ใช้รับข้อมูลจากผู้ใช้","std::vector // คอนเทนเนอร์แบบไดนามิก (Dynamic Array)","std::map // คอนเทนเนอร์สำหรับ Key-Value Pairs (แผนที่)","new // ตัวดำเนินการจัดสรรหน่วยความจำแบบไดนามิก","delete // ตัวดำเนินการคืนหน่วยความจำที่จัดสรรแบบไดนามิก"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while","for (type var : collection) { /* ... */ } // Range-based for loop (ลูป for ตามช่วง)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: &, |, ^, ~, <<, >> // ตัวดำเนินการบิตไวส์","sizeof() // ตัวดำเนินการหาขนาดของตัวแปร/ประเภทข้อมูล","& // ตัวดำเนินการ Address-of (ใช้หาที่อยู่หน่วยความจำ)","* // ตัวดำเนินการ Dereference (ใช้เข้าถึงค่าที่ pointer ชี้ไป)",":: // Scope Resolution Operator (ตัวดำเนินการระบุขอบเขต)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\n#include <iostream>\nint val = 20;\nif (val > 15) {\n  std::cout << \"Val is greater than 15\" << std::endl;\n} else {\n  std::cout << \"Val is not greater than 15\" << std::endl;\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\n#include <iostream>\nfor (int i = 0; i < 3; i++) {\n  std::cout << \"Loop C++: \" << i << std::endl;\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\n#include <iostream>\nchar grade = 'B';\nswitch (grade) {\n  case 'A':\n    std::cout << \"Excellent!\" << std::endl;\n    break;\n  case 'B':\n    std::cout << \"Very Good!\" << std::endl;\n    break;\n  default:\n    std::cout << \"Pass\" << std::endl;\n}\n","// ตัวอย่างที่ 4: การใช้งานคลาสและ Object-Oriented Programming (OOP)\n#include <iostream>\n#include <string>\nclass Dog {\npublic:\n  std::string name;\n  int age;\n  void bark() {\n    std::cout << name << \" says Woof!\" << std::endl;\n  }\n};\nDog myDog; // สร้าง Object จากคลาส Dog\nmyDog.name = \"Buddy\";\nmyDog.age = 3;\nmyDog.bark(); // เรียกใช้เมธอดของ Object\n","// ตัวอย่างที่ 5: การจัดการหน่วยความจำด้วย Pointer (Memory Management with Pointers)\n#include <iostream>\nint* dynamic_int = new int; // จัดสรรหน่วยความจำสำหรับ int\n*dynamic_int = 100; // กำหนดค่า\nstd::cout << \"Dynamic int value: \" << *dynamic_int << std::endl;\ndelete dynamic_int; // คืนหน่วยความจำ\ndynamic_int = nullptr; // ตั้งค่าเป็น nullptr เพื่อป้องกัน Dangling Pointer"]}},{"id":46,"name":"Crystal","slug":"crystal","logo":"img/crystal.png","desc":"Crystal เป็นภาษาโปรแกรม Statically-typed, Compiled ที่เน้นความเร็ว, ประสิทธิภาพ และไวยากรณ์ที่อ่านง่าย (คล้าย Ruby) ออกแบบมาเพื่อเป็นทางเลือกที่มีประสิทธิภาพสูงสำหรับ Ruby เหมาะสำหรับ Web Development, Command-line Tools และ System Programming","by":"Ary Borenszweig, Juan Wajnerman, Brian Cardiff","yr":"2014 (เปิดตัวครั้งแรก)","level":"4","par":["Object-Oriented","Imperative","Functional"],"fields":["System","Backend"],"rank":"ยังไม่ติดอันดับหลัก (กำลังเติบโตใน Niche Performance)","salary_range":"฿38,000-65,000 บาท/เดือน (Junior), ฿65,000-110,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["ประสิทธิภาพสูง (ใกล้เคียง C/C++/Go)","ไวยากรณ์ที่สะอาดและอ่านง่าย (คล้าย Ruby)","มี Type Inference ที่แข็งแกร่ง (ไม่ต้องระบุ Type มากเกินไป)","คอมไพล์เป็น Native Code ทำให้รันได้เร็ว","มี Macro System ที่ทรงพลังสำหรับการ Metaprogramming","Concurrency ด้วย Fibers (คล้าย Goroutines)"],"cons":["Learning Curve อาจสูงสำหรับผู้ที่ไม่คุ้นเคยกับ Type System หรือ Functional Programming","ชุมชนนักพัฒนาเล็กกว่าภาษาหลัก","Library และ Frameworks ยังไม่หลากหลายเท่าภาษาที่มีมานาน","เวลาในการคอมไพล์สำหรับโปรเจกต์ขนาดใหญ่อาจใช้เวลา","การดีบักอาจท้าทายในบางกรณี"],"frameworks":["Kemal (Web Framework)","Amber (Web Framework)","Lucky (Web Framework)"],"learn":["Crystal-Lang.org Official Documentation","Crystal by Example","The Crystal Book","DevDocs Crystal"],"variables":{"declaration (การประกาศ)":["var my_var = 10 // ตัวแปรที่เปลี่ยนแปลงได้ (Mutable), Type Inference","val my_const = \"Hello\" // ค่าคงที่ (Immutable, Type Inference)","my_var: Int32 = 100 // การระบุ Type ชัดเจน"],"types (ประเภท)":["Int32, Int64 // จำนวนเต็ม (มีขนาดบิตต่างกัน)","Float32, Float64 // ทศนิยม (ความแม่นยำต่างกัน)","Bool // ค่าตรรกะ (true/false)","Char // ตัวอักขระ","String // ข้อความ","Array(T) // อาร์เรย์ (เช่น Array(Int32))","Hash(K, V) // Hash (Key-Value pairs)","Tuple // Tuple (กลุ่มของค่าที่มีประเภทต่างกันได้)","Enum // Enumeration Type","Struct // โครงสร้างข้อมูล (คล้าย Structs ใน C)","Class // คลาส (สำหรับ Object-Oriented)"],"examples (ตัวอย่าง)":["name = \"Crystal\" // กำหนดตัวแปร name เป็นสตริง","version = 1.0 // กำหนดตัวแปร version เป็นทศนิยม","is_ready = true // กำหนดตัวแปร is_ready เป็น Boolean","numbers = [1, 2, 3] // สร้าง Array ของตัวเลข","user = {name: \"Alice\", age: 30} // สร้าง Hash (Key เป็น Symbol หรือ String ได้)","point = {10, 20} // สร้าง Tuple"]},"functions":{"declaration (การประกาศ)":["def function_name(param1, param2)\n  # ... code ...\nend // การประกาศฟังก์ชัน/เมธอด","->(a, b) { a + b } // Lambda / Block (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\ndef add(a, b)\n  a + b\nend\n","// ฟังก์ชันทักทาย\ndef greet(name)\n  puts \"Hello, #{name}!\"\nend\n","// การเรียกใช้ฟังก์ชัน:\n# sum = add(5, 5) # sum จะมีค่า 10\n# greet(\"Crystal User\") # แสดงผล 'Hello, Crystal User!'\n","// ฟังก์ชันที่มี Optional Parameters และ Named Arguments\ndef create_message(msg, prefix = \"Info\", suffix = \"!\")\n  \"#{prefix}: #{msg}#{suffix}\"\nend\n# puts create_message(\"Task complete\") # Info: Task complete!\n# puts create_message(\"Error occurred\", prefix: \"ERROR\", suffix: \"!!!\") # ERROR: Error occurred!!!\n","// Asynchronous Programming (Fibers)\n// Crystal รองรับ Concurrency ผ่าน Fibers ซึ่งเป็น Lightweight Concurrent Primitives\n// สามารถใช้ 'spawn' เพื่อรันโค้ดใน Fiber ใหม่ได้\n\n# def long_task(name)\n#   puts \"#{name}: Starting long task...\"\n#   sleep 1 # จำลองการทำงานที่ใช้เวลา\n#   puts \"#{name}: Finished long task!\"\n# end\n\n# puts \"Main: Before spawning tasks.\"\n# spawn long_task(\"Task A\") # รันใน Fiber ใหม่\n# spawn long_task(\"Task B\") # รันใน Fiber ใหม่\n# puts \"Main: After spawning tasks. Waiting...\"\n# sleep 2 # รอให้ Fibers ทำงานจนเสร็จก่อนโปรแกรมหลักจะจบ\n# puts \"Main: All tasks completed.\""],"built_in (ในตัว)":["puts // ใช้แสดงผลข้อมูลออกทาง Console (พร้อมขึ้นบรรทัดใหม่)","print // ใช้แสดงผลข้อมูลออกทาง Console (ไม่ขึ้นบรรทัดใหม่)","gets // ใช้รับข้อมูลจากผู้ใช้งาน","Array.new // สร้าง Array ใหม่","String.size // หาความยาวของสตริง","Hash.new // สร้าง Hash ใหม่","spawn // ใช้สำหรับ Concurrency (Fibers)","raise // ใช้สำหรับโยน Exception"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","# Multi-line\n# comment // คอมเมนต์หลายบรรทัด (ใช้ # ในทุกบรรทัด)","#= Multi-line comment =# // คอมเมนต์หลายบรรทัด (คล้าย Pod-style ใน Perl)"],"conditions (เงื่อนไข)":["if condition\n  # ... code ...\nelsif another_condition\n  # ... code ...\nelse\n  # ... code ...\nend // คำสั่ง if-elsif-else (เป็น Expression)","case expression\nwhen value1 then\n  # ... code ...\nwhen value2 then\n  # ... code ...\nelse\n  # ... code ...\nend // คำสั่ง case (คล้าย Switch)"],"loops (การวนซ้ำ)":["for item in collection\n  # ... code ...\nend // ลูป for (วนซ้ำ Collection)","while condition\n  # ... code ...\nend // ลูป while","loop\n  # ... code ...\n  break if condition # ออกจากลูป\nend // Infinite loop (ลูปไม่รู้จบ) พร้อมเงื่อนไขออก","collection.each { |item| # ... } // Iterator 'each' (สำหรับ Side Effects)","collection.map { |item| # ... } // Iterator 'map' (สำหรับสร้าง Array ใหม่)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","String Concatenation: + // ตัวดำเนินการเชื่อมสตริง"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nscore = 75\nif score >= 90\n  puts \"Grade A\"\nelsif score >= 70\n  puts \"Grade B\"\nelse\n  puts \"Grade C\"\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nnumbers = [10, 20, 30]\nfor num in numbers\n  puts \"Number: #{num}\"\nend\n","// ตัวอย่างที่ 3: การใช้ Case Statement\nstatus = :active\ncase status\nwhen :active\n  puts \"User is active.\"\nwhen :inactive\n  puts \"User is inactive.\"\nelse\n  puts \"Unknown status.\"\nend\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Object-Oriented Programming (OOP)\nclass Greeter\n  def initialize(@name)\n  end\n\n  def greet\n    puts \"Hello, #{@name}!\"\n  end\nend\n\nmy_greeter = Greeter.new(\"Object\")\nmy_greeter.greet # แสดงผล 'Hello, Object!'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nbegin\n  result = 10 / 0 # จะเกิด DivisionByZeroError\n  puts \"Result: #{result}\"\nrescue DivisionByZeroError => e\n  puts \"Error: #{e.message}\"\nrescue e\n  puts \"An unexpected error occurred: #{e.message}\"\nensure\n  puts \"Execution finished.\"\nend\n","// ตัวอย่างที่ 6: การทำงานกับ Array และ Hash\nfruits = [\"Apple\", \"Banana\", \"Cherry\"]\nfruits << \"Date\" # เพิ่มสมาชิก\nputs \"Fruits: #{fruits}\"\n\nuser_data = {\"name\" => \"John\", \"age\" => 30}\nuser_data[\"city\"] = \"New York\" # เพิ่ม Key-Value ใหม่\nputs \"User Data: #{user_data}\"\n"]}},{"id":3,"name":"C#","slug":"csharp","logo":"img/csharp.png","desc":"C# (C-sharp) คือภาษาโปรแกรมเชิงวัตถุที่พัฒนาโดย Microsoft ใช้สำหรับสร้างแอปพลิเคชันหลากหลายประเภทบนแพลตฟอร์ม .NET เช่น Windows desktop apps, เว็บไซต์ (ASP.NET), เกม (Unity) และแอปบนมือถือ (Xamarin)","by":"Microsoft (.NET team)","yr":"2000","level":"3","par":["Object-Oriented","Component-Oriented","Structured","Imperative","Functional"],"fields":["Game","Desktop","Mobile","Plugin","Render"],"rank":"5 ใน TIOBE Index 2025 (4.12%)","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-85,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["เป็นภาษาเชิงวัตถุที่ทันสมัยและทรงพลัง","มี Ecosystem ที่สมบูรณ์แบบบน .NET","เครื่องมือพัฒนา (Visual Studio) ที่มีประสิทธิภาพสูง","มี Garbage Collection จัดการหน่วยความจำอัตโนมัติ","สามารถสร้างแอปพลิเคชันได้หลากหลายประเภท"],"cons":["ผูกติดกับแพลตฟอร์ม .NET (แม้จะเปิดกว้างมากขึ้นกับ .NET Core)","ประสิทธิภาพอาจไม่เท่า C/C++ สำหรับงานระดับต่ำมาก","การเรียนรู้อาจมี Learning Curve สูงสำหรับบางฟีเจอร์","โปรแกรมที่สร้างขึ้นมีขนาดใหญ่กว่า C/C++","ชุมชนอาจไม่ใหญ่เท่า JavaScript หรือ Python ในบางด้าน"],"frameworks":["ASP.NET","Unity (Game Engine)","Xamarin (Mobile)","Blazor (Web)"],"learn":["Microsoft Learn: C#","Head First C#","Pluralsight C# Courses","C# Station"],"variables":{"declaration (การประกาศ)":["int age; // การประกาศตัวแปรจำนวนเต็ม","string name; // การประกาศตัวแปรสตริง","bool isActive; // การประกาศตัวแปรบูลีน"],"types (ประเภท)":["int (System.Int32) // จำนวนเต็ม","double (System.Double) // ทศนิยมความแม่นยำคู่","string (System.String) // ข้อความ","bool (System.Boolean) // ค่าจริงหรือเท็จ","char (System.Char) // ตัวอักขระ","float (System.Single) // ทศนิยมความแม่นยำเดี่ยว","decimal (System.Decimal) // ทศนิยมความแม่นยำสูง (สำหรับงานการเงิน)","long (System.Int64) // จำนวนเต็มขนาดยาว"],"examples (ตัวอย่าง)":["int quantity = 50; // กำหนดตัวแปร quantity เก็บตัวเลข 50","string product_name = \"Laptop\"; // กำหนดตัวแปร product_name เก็บข้อความ","bool has_stock = true; // กำหนดตัวแปร has_stock เก็บค่าความจริง","double price = 1200.50; // กำหนดตัวแปร price เก็บเลขทศนิยม","int[] numbers = {1, 2, 3, 4, 5}; // ประกาศและกำหนดค่าอาร์เรย์","var dynamicValue = \"Hello\"; // การใช้ var เพื่อให้ compiler อนุมานประเภทข้อมูล"]},"functions":{"declaration (การประกาศ)":["public returnType MethodName(parameters) { /* ... */ } // การประกาศเมธอด (ฟังก์ชัน) แบบปกติ","(parameters) => expression // Lambda expression (ฟังก์ชันนิรนามแบบย่อ)","public static returnType MethodName(parameters) { /* ... */ } // การประกาศ Static Method"],"examples (ตัวอย่าง)":["// ฟังก์ชัน (เมธอด) สำหรับบวกเลขสองจำนวน\npublic int Add(int a, int b) {\n  return a + b;\n}\n","// ฟังก์ชัน (เมธอด) สำหรับแสดงข้อความออกทาง Console\nprivate void DisplayMessage(string message) {\n  Console.WriteLine(message);\n}\n","// การเรียกใช้ฟังก์ชัน (เมธอด)\nint result = Add(10, 20); // result จะมีค่า 30\nDisplayMessage(\"Hello from C#!\"); // แสดงผล 'Hello from C#!'\n","// การใช้งาน Lambda expression (ฟังก์ชันนิรนาม)\nFunc<int, int, int> multiply = (a, b) => a * b;\nConsole.WriteLine($\"Multiply: {multiply(5, 4)}\"); // แสดงผล 'Multiply: 20'\n","// Asynchronous Function (using async/await)\n// ฟังก์ชันนี้แสดงการทำงานแบบ Asynchronous ซึ่งจะรันโดยไม่บล็อกการทำงานหลักของโปรแกรม\n// ต้องใช้ 'async' และ 'await' ร่วมกับ Task<T> หรือ Task\nusing System.Threading.Tasks;\npublic async Task<string> FetchDataAsync() {\n  Console.WriteLine(\"Fetching data...\");\n  await Task.Delay(1000); // จำลองการหน่วงเวลา (เช่น การเรียก API)\n  Console.WriteLine(\"Data fetched!\");\n  return \"Data fetched asynchronously\";\n}\n// ตัวอย่างการเรียกใช้ Async Function (ต้องอยู่ในบริบทของ Async Method หรือ Main method ใน C# 7.1+)\n/*\nasync Task Main(string[] args)\n{\n    string data = await FetchDataAsync();\n    Console.WriteLine(data);\n}\n*/"],"built_in (ในตัว)":["Console.WriteLine() // ใช้แสดงผลข้อมูลออกทาง Console","List<T> // คอลเลกชันแบบไดนามิกที่ปรับขนาดได้","Dictionary<TKey, TValue> // คอลเลกชันสำหรับ Key-Value Pairs","DateTime.Now // ใช้สำหรับรับเวลาปัจจุบัน","File.ReadAllText() // ใช้สำหรับอ่านข้อความทั้งหมดจากไฟล์"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","foreach (var item in collection) { /* ... */ } // ลูป foreach สำหรับวนซ้ำคอลเลกชัน"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Null-coalescing: ??, ??= // ตัวดำเนินการสำหรับจัดการค่า null","Ternary: ? : // ตัวดำเนินการเงื่อนไขแบบย่อ (Conditional Operator)","as // ตัวดำเนินการแปลงประเภท (Type Casting) อย่างปลอดภัย","is // ตัวดำเนินการตรวจสอบประเภท (Type Checking)","new // ตัวดำเนินการสร้าง Object ใหม่"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nint score = 75;\nif (score >= 80) {\n  Console.WriteLine(\"Grade A\");\n} else if (score >= 60) {\n  Console.WriteLine(\"Grade B\");\n} else {\n  Console.WriteLine(\"Grade C\");\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (int i = 0; i < 3; i++) {\n  Console.WriteLine($\"Loop C#: {i}\");\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nstring day = \"Monday\";\nswitch (day) {\n  case \"Monday\":\n    Console.WriteLine(\"Start of the week.\");\n    break;\n  case \"Friday\":\n    Console.WriteLine(\"End of the week!\");\n    break;\n  default:\n    Console.WriteLine(\"Mid-week.\");\n}\n","// ตัวอย่างที่ 4: การใช้งานคลาสและ Object-Oriented Programming (OOP)\nusing System;\npublic class Car {\n  public string Model { get; set; }\n  public int Year { get; set; }\n  public void StartEngine() {\n    Console.WriteLine($\"{Model} engine started!\");\n  }\n}\n// สร้าง Object จากคลาส Car\nCar myCar = new Car();\nmyCar.Model = \"Toyota\";\nmyCar.Year = 2023;\nmyCar.StartEngine(); // เรียกใช้เมธอด\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nusing System;\ntry {\n  int dividend = 10;\n  int divisor = 0;\n  int result = dividend / divisor; // จะเกิด DivideByZeroException\n  Console.WriteLine(result);\n}\ncatch (DivideByZeroException ex) {\n  Console.WriteLine($\"Error: {ex.Message}\");\n}\nfinally {\n  Console.WriteLine(\"Execution completed.\");\n}\n","// ตัวอย่างที่ 6: การใช้ LINQ (Language Integrated Query) กับ List\nusing System.Collections.Generic;\nusing System.Linq;\nList<int> numbers = new List<int> { 1, 5, 2, 8, 3 };\nvar evenNumbers = numbers.Where(n => n % 2 == 0).OrderBy(n => n).ToList();\nConsole.WriteLine(\"Even numbers (sorted): \" + string.Join(\", \", evenNumbers)); // แสดงผล 'Even numbers (sorted): 2, 4, 8' (สมมติ 4 ด้วย)"]}},{"id":54,"name":"CUDA","slug":"cuda","logo":"img/cuda.jfif","desc":"CUDA (Compute Unified Device Architecture) เป็นแพลตฟอร์มการประมวลผลแบบขนาน (Parallel Computing Platform) และ Application Programming Interface (API) ที่พัฒนาโดย NVIDIA ช่วยให้นักพัฒนาสามารถใช้ GPU ของ NVIDIA ในการประมวลผลงานที่ซับซ้อนได้เร็วกว่าการใช้ CPU เพียงอย่างเดียว เหมาะสำหรับงานที่ต้องการการคำนวณจำนวนมาก เช่น Machine Learning, Data Science, Scientific Simulation และ Game Development","by":"NVIDIA","yr":"2006","level":"1","par":["Parallel Programming","Imperative","Low-level","Hardware"],"fields":["HPC","AI"],"rank":"เป็นมาตรฐานสำหรับ GPGPU (General-Purpose computing on Graphics Processing Units)","salary_range":"฿50,000-90,000 บาท/เดือน (Junior), ฿90,000-180,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["เพิ่มประสิทธิภาพการประมวลผลได้อย่างมหาศาลสำหรับงานที่เหมาะสม","รองรับการคำนวณแบบขนานด้วย GPU","มี Library และ Tools ที่หลากหลายสำหรับการพัฒนา","เป็นมาตรฐานในอุตสาหกรรม Machine Learning และ AI","สามารถทำงานร่วมกับภาษาโปรแกรมยอดนิยม (C/C++, Python, Fortran)"],"cons":["ผูกติดกับ Hardware ของ NVIDIA (ไม่สามารถใช้กับ GPU ค่ายอื่นได้โดยตรง)","Learning Curve สูง (ต้องเข้าใจ Parallel Programming และสถาปัตยกรรม GPU)","การดีบักและการ Optimize โค้ดซับซ้อน","ไม่เหมาะสำหรับงานที่ประมวลผลแบบ Sequential","ต้องมีการจัดการ Memory ระหว่าง Host (CPU) และ Device (GPU)"],"frameworks":["TensorFlow (with CUDA)","PyTorch (with CUDA)","cuDNN","cuBLAS","OptiX"],"learn":["NVIDIA CUDA Documentation","CUDA C++ Programming Guide","Udemy/Coursera CUDA courses","NVIDIA GTC (GPU Technology Conference)"],"variables":{"declaration (การประกาศ)":["__global__ void kernel_name(int* data); // การประกาศ Kernel (ฟังก์ชันที่รันบน GPU)","int* host_array; // Pointer ไปยัง Memory บน Host (CPU)","int* device_array; // Pointer ไปยัง Memory บน Device (GPU)","dim3 threadsPerBlock(32, 32); // การกำหนดขนาดของ Block (Threads per Block)","dim3 numBlocks(gridDimX, gridDimY); // การกำหนดขนาดของ Grid (Number of Blocks)"],"types (ประเภท)":["int, float, double // ประเภทข้อมูลพื้นฐานที่ใช้ใน Kernel","char, short, long // ประเภทข้อมูลพื้นฐานอื่นๆ","dim3 // ใช้สำหรับกำหนดมิติของ Grid และ Block","cudaStream_t // Stream สำหรับการจัดการ Asynchronous Operations","cudaError_t // ประเภทสำหรับการจัดการข้อผิดพลาด CUDA"],"examples (ตัวอย่าง)":["// ในไฟล์ .cu (CUDA C++ file)\n// __global__ void add_vectors(float* a, float* b, float* c, int N) {\n//   int idx = blockIdx.x * blockDim.x + threadIdx.x;\n//   if (idx < N) {\n//     c[idx] = a[idx] + b[idx];\n//   }\n// }\n//","// ใน Host Code (CPU)\n// float* h_a, *h_b, *h_c; // Host-side pointers\n// float* d_a, *d_b, *d_c; // Device-side pointers\n// cudaMalloc((void**)&d_a, N * sizeof(float)); // Allocate memory on GPU\n// cudaMemcpy(d_a, h_a, N * sizeof(float), cudaMemcpyHostToDevice); // Copy data from CPU to GPU"]},"functions":{"declaration (การประมวลผลแบบขนานบน GPU)":["__global__ void kernel_name(parameters) { /* ... */ } // Kernel Function (รันบน GPU)","cudaMalloc(ptr, size); // ฟังก์ชันสำหรับจัดสรร Memory บน GPU","cudaMemcpy(dst, src, size, kind); // ฟังก์ชันสำหรับคัดลอก Memory ระหว่าง CPU และ GPU"],"examples (ตัวอย่าง)":["// การประกาศ Kernel สำหรับ Vector Addition\n// __global__ void vectorAdd(float* A, float* B, float* C, int numElements)\n// {\n//    int i = blockDim.x * blockIdx.x + threadIdx.x;\n//    if (i < numElements)\n//    {\n//        C[i] = A[i] + B[i];\n//    }\n// }\n//","// การเรียกใช้ Kernel จาก Host (CPU)\n// // กำหนดขนาด Grid และ Block\n// int blockSize = 256;\n// int numBlocks = (N + blockSize - 1) / blockSize;\n//\n// // เรียกใช้ Kernel (Launch Kernel)\n// vectorAdd<<<numBlocks, blockSize>>>(d_A, d_B, d_C, N);\n"],"built_in (ในตัว)":["blockIdx.x, blockIdx.y, blockIdx.z // Index ของ Block ใน Grid","blockDim.x, blockDim.y, blockDim.z // ขนาดของ Block (จำนวน Threads)","threadIdx.x, threadIdx.y, threadIdx.z // Index ของ Thread ภายใน Block","gridDim.x, gridDim.y, gridDim.z // ขนาดของ Grid (จำนวน Blocks)","cudaMalloc() // จัดสรร Memory บน GPU","cudaFree() // คืน Memory บน GPU","cudaMemcpy() // คัดลอก Memory ระหว่าง Host/Device","__syncthreads() // Synchronize Threads ภายใน Block","atomicAdd() // Atomic Operation (สำหรับ Shared Memory)","cudaDeviceSynchronize() // Synchronize CPU กับ GPU (รอให้ GPU ทำงานเสร็จ)"],"async (Asynchronous Operations)":["cudaStreamCreate(&stream); // สร้าง Stream","cudaMemcpyAsync(dst, src, size, kind, stream); // Copy Memory แบบ Asynchronous","kernel_name<<<numBlocks, blockSize, 0, stream>>>(params); // Launch Kernel แบบ Asynchronous","cudaStreamSynchronize(stream); // รอให้ Stream ทำงานเสร็จ"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว (เหมือน C++)","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด (เหมือน C++)"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else (ใน Kernel หรือ Host Code)","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch (ใน Kernel หรือ Host Code)"],"loops (การวนซ้ำ)":["for (int i = 0; i < N; i++) { /* ... */ } // ลูป for (ใน Kernel หรือ Host Code)","while (condition) { /* ... */ } // ลูป while (ใน Kernel หรือ Host Code)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: &, |, ^, ~, <<, >> // ตัวดำเนินการบิตไวส์"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else ใน Kernel\\n// __global__ void process_data(float* input, float* output, int N) {\\n//   int idx = blockIdx.x * blockDim.x + threadIdx.x;\\n//   if (idx < N) {\\n//     if (input[idx] > 0) {\\n//       output[idx] = input[idx] * 2;\\n//     } else {\\n//       output[idx] = input[idx] / 2;\\n//     }\\n//   }\\n// }\\n","// ตัวอย่างที่ 2: การใช้วงลูป For ใน Kernel\\n// __global__ void initialize_array(int* arr, int N, int value) {\\n//   int idx = blockIdx.x * blockDim.x + threadIdx.x;\\n//   if (idx < N) {\\n//     for (int i = 0; i < 10; i++) { // Loop ภายใน Thread\\n//       arr[idx] += value;\\n//     }\\n//   }\\n// }\\n","// ตัวอย่างที่ 3: การจัดการ Memory และ Error Handling ใน Host Code\\n// cudaError_t err = cudaMalloc((void**)&d_data, data_size);\\n// if (err != cudaSuccess) {\\n//   fprintf(stderr, \"Failed to allocate device memory!\\n\");\\n//   return 1;\\n// }\\n// // ... kernel launch ...\\n// err = cudaDeviceSynchronize(); // Synchronize and check for errors\\n// if (err != cudaSuccess) {\\n//   fprintf(stderr, \"Kernel launch failed: %s\\n\", cudaGetErrorString(err));\\n//   return 1;\\n// }\\n// cudaFree(d_data);\\n"]}},{"id":16,"name":"Dart","slug":"dart","logo":"img/dart.png","desc":"Dart เป็นภาษาโปรแกรมที่พัฒนาโดย Google เน้นการสร้างแอปพลิเคชันแบบ Multi-platform โดยเฉพาะอย่างยิ่ง Mobile App ด้วย Flutter Framework สามารถ Compile เป็น Native Code ได้ ทำให้มีประสิทธิภาพสูง","by":"Google","yr":"2011","level":"3","par":["Object-Oriented","Imperative","Functional"],"fields":["Mobile","Frontend"],"rank":"25-30 แต่เติบโตแรงด้วย Flutter (6.2% ของนักพัฒนา Mobile)","salary_range":"฿30,000-50,000 บาท/เดือน (Junior), ฿50,000-85,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["เหมาะกับการพัฒนา Cross-platform ด้วย Flutter","มี Hot Reload สำหรับการพัฒนาที่รวดเร็ว","ประสิทธิภาพสูง (Compiled to Native Code)","มี Null Safety ในตัว","รองรับ Asynchronous Programming ได้ดี"],"cons":["Learning Curve อาจสูงสำหรับผู้เริ่มต้น","ชุมชนนักพัฒนาอาจเล็กกว่าภาษาหลัก","ต้องพึ่งพา Flutter เป็นหลักสำหรับการพัฒนา Mobile","ขนาดของแอปพลิเคชันที่สร้างอาจจะใหญ่"],"frameworks":["Flutter"],"learn":["Dart Official Documentation","Flutter Documentation","Effective Dart","DartPad"],"variables":{"declaration (การประกาศ)":["var name = 'Dart'; // Type inferred (อนุมานประเภทข้อมูล)","String message = 'Hello'; // ระบุประเภทข้อมูลชัดเจน","const pi = 3.14; // Compile-time constant (ค่าคงที่ที่กำหนดตอน Compile)","final age = 30; // Runtime constant (ค่าคงที่ที่กำหนดตอนรัน)"],"types (ประเภท)":["int // จำนวนเต็ม","double // ทศนิยม","String // ข้อความ","bool // ค่าจริงหรือเท็จ (true/false)","List // รายการ (คล้าย Array)","Map // แผนที่ (Key-Value pairs)","Set // เซต (ชุดของค่าที่ไม่ซ้ำกัน)","dynamic // ประเภทข้อมูลที่ยืดหยุ่น (สามารถเก็บค่าประเภทใดก็ได้)","Object // คลาสพื้นฐานของทุกอ็อบเจกต์ใน Dart","Null // ประเภทข้อมูลสำหรับค่าว่างเปล่า (null)"],"examples (ตัวอย่าง)":["int count = 10; // กำหนดตัวแปร count เก็บตัวเลข 10","String greeting = \"Welcome!\"; // กำหนดตัวแปร greeting เก็บสตริง","bool isActive = false; // กำหนดตัวแปร isActive เก็บค่าความจริง","List<String> fruits = ['apple', 'banana']; // กำหนด List ของสตริง","Map<String, int> ages = {'Alice': 25, 'Bob': 30}; // กำหนด Map"]},"functions":{"declaration (การประกาศ)":["returnType functionName(param1, param2) { /* ... */ } // การประกาศฟังก์ชันทั่วไป","(params) => expression; // Anonymous function / Lambda (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nint add(int a, int b) {\n  return a + b;\n}\n","// ฟังก์ชันแสดงข้อความ\nvoid printMessage(String msg) {\n  print(msg);\n}\n","// การเรียกใช้ฟังก์ชัน\nint sum = add(5, 5); // sum จะมีค่า 10\nprintMessage(\"Hello, Dart!\"); // แสดงผล 'Hello, Dart!'\n","// ฟังก์ชันที่มี Named Parameters และ Optional Parameters\nvoid displayUserInfo({String? name, int? age}) {\n  if (name != null) print('Name: $name');\n  if (age != null) print('Age: $age');\n}\ndisplayUserInfo(name: 'Alice', age: 30); // เรียกใช้ด้วย Named Arguments\ndisplayUserInfo(name: 'Bob'); // เรียกใช้โดยไม่ส่ง age\n","// Asynchronous Programming (Async/Await)\n// Dart จัดการ Asynchronous Programming ได้ดีด้วย Future และ async/await\nFuture<String> fetchData() async {\n  print(\"Fetching data...\");\n  await Future.delayed(Duration(seconds: 1)); // จำลองการหน่วงเวลา 1 วินาที\n  print(\"Data fetched!\");\n  return \"Data fetched asynchronously\";\n}\n// ตัวอย่างการเรียกใช้ Async Function\n/*\nvoid main() async {\n  String data = await fetchData();\n  print(\"Received: $data\");\n}\n*/"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","List.add() // เมธอดสำหรับเพิ่มสมาชิกใน List","Map.containsKey() // เมธอดสำหรับตรวจสอบ Key ใน Map","Future.delayed() // ใช้สร้าง Future ที่หน่วงเวลา","int.parse() // ใช้แปลง String เป็น Integer","String.length // Property สำหรับหาความยาวของสตริง","List.map() // เมธอดสำหรับแปลง List"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด","/// Documentation comment // คอมเมนต์สำหรับเอกสาร (จะถูกประมวลผลเป็นเอกสาร)"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","for (var item in collection) { /* ... */ } // ลูป for-in สำหรับวนซ้ำ Collection"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Null-aware: ??, ??=, ?., !. // ตัวดำเนินการสำหรับจัดการค่า Null และเข้าถึงสมาชิกแบบ Null-safe"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nint score = 70;\nif (score >= 60) {\n  print('Passed');\n} else {\n  print('Failed');\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (int i = 0; i < 3; i++) {\n  print('Loop Dart: $i');\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nString command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n    print('Opening file...');\n    break;\n  case 'SAVE':\n    print('Saving file...');\n    break;\n  default:\n    print('Unknown command.');\n}\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Object-Oriented Programming (OOP)\nclass Car {\n  String brand;\n  int year;\n\n  Car(this.brand, this.year); // Constructor แบบย่อ\n\n  void drive() {\n    print('$brand from $year is driving.');\n  }\n}\n// สร้าง Object จากคลาส Car\nCar myCar = Car('Toyota', 2023);\nmyCar.drive(); // แสดงผล 'Toyota from 2023 is driving.'\n","// ตัวอย่างที่ 5: Null Safety\nString? nullableName = 'John'; // ตัวแปรที่สามารถเป็น null ได้\nprint(nullableName?.toUpperCase()); // ใช้ ?. เพื่อเรียกเมธอดแบบ Null-safe\nnullableName = null;\nprint(nullableName?.toUpperCase()); // จะแสดง null (ไม่เกิด error)\n\nString nonNullableName = nullableName ?? 'Guest'; // ใช้ ?? เพื่อให้ค่าเริ่มต้นหากเป็น null\nprint(nonNullableName); // จะแสดง 'Guest'\n","// ตัวอย่างที่ 6: การจัดการข้อผิดพลาด (Exception Handling)\ntry {\n  int result = 10 ~/ 0; // ~/ คือ integer division\n  print(result);\n} on IntegerDivisionByZeroException {\n  print('Error: Cannot divide by zero!');\n} catch (e) {\n  print('An unexpected error occurred: $e');\n} finally {\n  print('Operation completed.');\n}\n"]}},{"id":29,"name":"Elixir","slug":"elixir","logo":"img/elixir.png","desc":"Elixir เป็นภาษา Functional Programming ที่ทำงานบน Erlang Virtual Machine (BEAM) มีจุดเด่นด้าน Concurrency, Fault-tolerance (ความทนทานต่อข้อผิดพลาด) และ Scalability สูงมาก ออกแบบมาเพื่อสร้างระบบที่มีความทนทานสูงและสามารถรองรับผู้ใช้จำนวนมหาศาล เหมาะสำหรับ Web Servers, APIs, Chat applications และ Distributed Systems","by":"José Valim","yr":"2012","level":"3","par":["Functional","Concurrent","Dynamic"],"fields":["Backend","Network","Tele","Distributed"],"rank":"30-35 เติบโตใน High-concurrency Systems","salary_range":"฿32,000-52,000 บาท/เดือน (Junior), ฿52,000-88,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["Concurrency สูงและจัดการได้ง่าย (ผ่าน Actor Model)","Fault-tolerance (ระบบมีความทนทานต่อข้อผิดพลาดสูง)","Scalability ดีเยี่ยม (เนื่องจากมาจาก Erlang VM)","ไวยากรณ์ที่สะอาดและอ่านง่าย (คล้าย Ruby)","Hot Code Swapping (สามารถอัปเดตโค้ดได้โดยไม่ต้องหยุดระบบ)"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Functional Programming หรือ Actor Model","Ecosystem และ Library ยังเล็กกว่าภาษาหลักๆ","จำนวนนักพัฒนาที่มีความเชี่ยวชาญค่อนข้างน้อย","การจัดการ Memory อาจต้องใช้ความเข้าใจเฉพาะ"],"frameworks":["Phoenix (Web Framework)","Nerves (Embedded Systems)","Ecto (Database Wrapper)"],"learn":["Elixir Official Website","Elixir School","Programming Elixir (Book)","Phoenix Guides"],"variables":{"declaration (การประกาศ)":["name = \"Alice\" # การกำหนดค่าให้กับตัวแปร (Immutable by default)","age = 30 # ตัวเลข","list = [1, 2, 3] # List (คล้าย Array)"],"types (ประเภท)":["Atoms (symbols, e.g., :ok) // ค่าคงที่ที่ไม่สามารถเปลี่ยนแปลงได้ มักใช้เป็น Key หรือ Status","Numbers (integers, floats) // ตัวเลข (จำนวนเต็ม, ทศนิยม)","Booleans (true, false) // ค่าความจริง","Strings // ข้อความ (ใช้ Double Quote)","Lists // รายการ (คล้าย Array ในภาษาอื่น, แต่เป็น Linked List)","Tuples // Tuple (ลำดับของค่าที่มีขนาดคงที่)","Maps // Map (Key-Value store, คล้าย Hash/Dictionary)","PIDs (Process Identifiers) // Process Identifier (สำหรับ Concurrency)"],"examples (ตัวอย่าง)":["name = \"Bob\" # กำหนดตัวแปร name เป็นสตริง","is_active = true # กำหนดตัวแ variabile is_active เป็น Boolean","user_data = %{name: \"Charlie\", age: 25} # กำหนด Map ด้วย Atom Keys","numbers = [10, 20, 30] # กำหนด List","tuple_example = {:ok, \"Success\", 123} # กำหนด Tuple","pid_example = spawn(fn -> :timer.sleep(1000) end) # ตัวอย่าง PID จากการสร้าง Process"]},"functions":{"declaration (การประกาศ)":["def func_name(param1, param2) do\\n  # code\\n  result\\nend # การประกาศฟังก์ชันใน Module","add = fn a, b -> a + b end # Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวนใน Module\ndefmodule Math do\n  def add(a, b) do\n    a + b\n  end\nend\nresult = Math.add(5, 3) # เรียกใช้ฟังก์ชัน Math.add(5, 3)\nIO.puts(\"Sum: #{result}\") # แสดงผล \"Sum: 8\"\n","// ฟังก์ชันทักทาย\ndefmodule Greeter do\n  def greet(name) do\n    IO.puts(\"Hello, \" <> name <> \"!\") # ใช้ <> สำหรับเชื่อมสตริง\n  end\nend\nGreeter.greet(\"World\") # แสดงผล 'Hello, World!'\n","// ฟังก์ชันที่มี Pattern Matching และ Guard Clauses\ndefmodule MyMath do\n  def factorial(0), do: 1 # Base case: factorial ของ 0 คือ 1\n  def factorial(n) when n > 0 do # Recursive case: factorial ของ n เมื่อ n > 0\n    n * factorial(n - 1)\n  end\n  def factorial(n) do\n    IO.puts(\"Error: Factorial is not defined for negative numbers.\")\n    :error\n  end\nend\nIO.puts(\"Factorial of 5: #{MyMath.factorial(5)}\") # แสดงผล 'Factorial of 5: 120'\nIO.puts(\"Factorial of -1: #{MyMath.factorial(-1)}\") # แสดงผล Error message และ :error\n","// Concurrency (Actor Model - Spawning Processes)\ndefmodule GreeterProcess do\n  def start_link do\n    spawn_link(__MODULE__, :loop, []) # สร้าง Process ใหม่และเชื่อมโยง (link) กับ Process ปัจจุบัน\n  end\n\n  def loop do\n    receive do # รอรับข้อความ\n      {:greet, name} ->\n        IO.puts(\"Process received: Hello, #{name}!\")\n        loop()\n      :stop ->\n        IO.puts(\"Process stopping.\")\n    end\n  end\n\n  def send_greet(pid, name) do\n    send(pid, {:greet, name}) # ส่งข้อความไปยัง Process ด้วย PID\n  end\n\n  def stop(pid) do\n    send(pid, :stop)\n  end\nend\n\n# // ใน IEx (Elixir Shell):\n# // {:ok, pid} = GreeterProcess.start_link()\n# // GreeterProcess.send_greet(pid, \"Alice\")\n# // GreeterProcess.send_greet(pid, \"Bob\")\n# // GreeterProcess.stop(pid)\n"],"built_in (ในตัว)":["IO.puts() // ใช้แสดงผลข้อมูลออกทาง Console","Enum.map() // ใช้แปลงทุก Element ใน Collection","String.split() // ใช้แบ่งสตริง","Map.get() // ใช้ดึงค่าจาก Map ด้วย Key","hd() // ใช้ดึง Head (Element แรก) ของ List","tl() // ใช้ดึง Tail (List ที่เหลือ) ของ List","if // คำสั่งเงื่อนไข","cond // คำสั่งเงื่อนไขที่ยืดหยุ่นกว่า if","case // คำสั่ง Pattern Matching","spawn() // ใช้สร้าง Process ใหม่ (สำหรับ Concurrency)","send() // ใช้ส่งข้อความไปยัง Process","receive() // ใช้รอรับข้อความจาก Process"]},"syntax":{"comments (คอมเมนต์)":["# Single-line comment // คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["if condition do\\n  # code\\nelse if another_condition do\\n  # code\\nelse\\n  # code\\nend // คำสั่ง if-else if-else","case variable do\\n  1 -> # code\\n  _ -> # code\\nend // คำสั่ง case (Pattern Matching)","cond do\\n  condition1 -> result1\\n  condition2 -> result2\\n  true -> default_result\\nend // คำสั่ง cond (หลายเงื่อนไข)"],"loops (การวนซ้ำ)":["Enum.each([1, 2, 3], fn x -> IO.puts(x) end) // การวนซ้ำโดยใช้ Enum.each (Functional Style)","for x <- [1, 2, 3] do\\n  IO.puts(x)\\nend // For Comprehension (สำหรับสร้าง List ใหม่หรือ Side Effects)","while (condition) do # rarely used\\n  # code\\nend // ลูป while (ไม่ค่อยนิยมใช้ใน Elixir Functional Programming)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, rem // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, เศษเหลือ","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not (boolean operators) // ตัวดำเนินการตรรกะ: AND, OR, NOT (สำหรับ Boolean)","Concatenation: <> (string), ++ (list), -- (list subtraction) // ตัวดำเนินการเชื่อม: สตริง, List, ลบ List","//. // Pipe operator (ส่งผลลัพธ์จากฟังก์ชันหนึ่งไปยังอีกฟังก์ชันหนึ่ง)","<> // String Concatenation","-> // Anonymous Function Arrow","<- // Generator in For Comprehension",": // Atom Prefix"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nage = 20\nif age >= 18 do\n  IO.puts(\"Adult\")\nelse\n  IO.puts(\"Minor\")\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป For Comprehension\nfor i <- 0..2 do\n  IO.puts(\"Loop: #{i}\")\nend\n","// ตัวอย่างที่ 3: การใช้ Case Statement (Pattern Matching)\nstatus = :active\ncase status do\n  :active -> IO.puts(\"Status is active.\")\n  :inactive -> IO.puts(\"Status is inactive.\")\n  _ -> IO.puts(\"Unknown status.\")\nend\n","// ตัวอย่างที่ 4: การทำงานกับ List และ Pattern Matching\ndefmodule ListOperations do\n  def sum_list([]) do\n    0\n  end\n  def sum_list([head | tail]) do\n    head + sum_list(tail)\n  end\nend\n\nIO.puts(\"Sum of [1, 2, 3]: #{ListOperations.sum_list([1, 2, 3])}\") # แสดงผล 'Sum of [1, 2, 3]: 6'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Tuple-based error handling)\ndefmodule Divider do\n  def divide(a, 0), do: {:error, :division_by_zero} # ถ้าตัวหารเป็น 0\n  def divide(a, b), do: {:ok, a / b} # ถ้าหารได้ปกติ\nend\n\ncase Divider.divide(10, 2) do\n  {:ok, result} -> IO.puts(\"Result: #{result}\")\n  {:error, reason} -> IO.puts(\"Error: #{reason}\")\nend\n\ncase Divider.divide(10, 0) do\n  {:ok, result} -> IO.puts(\"Result: #{result}\")\n  {:error, reason} -> IO.puts(\"Error: #{reason}\")\nend\n"]}},{"id":60,"name":"Erlang","slug":"erlang","logo":"img/erlang.png","desc":"Erlang เป็นภาษาโปรแกรม Functional Programming และ Runtime System (VM) ที่สร้างขึ้นโดย Ericsson สำหรับการสร้างระบบโทรคมนาคมที่มีความทนทานสูง, สามารถปรับขนาดได้ และทำงานพร้อมกันได้จำนวนมาก (Massively Concurrent) เป็นที่รู้จักกันดีในเรื่องความสามารถในการทนต่อข้อผิดพลาด (Fault-tolerance) และ Hot Code Swapping","by":"Ericsson","yr":"1986","level":"2","par":["Functional","Concurrent","Declarative"],"fields":["Tele","Distributed"],"rank":"40+ (Niche ในตลาดเฉพาะทาง)","salary_range":"฿35,000-60,000 บาท/เดือน (Junior), ฿60,000-110,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ความสามารถในการทำงานพร้อมกันสูง (Massive Concurrency) ด้วย Actor Model","ความทนทานต่อข้อผิดพลาด (Fault-tolerance) ในตัว (Let It Crash philosophy)","สามารถอัปเดตโค้ดได้ขณะรัน (Hot Code Swapping)","เหมาะสำหรับ Distributed Systems และ Real-time Applications","มี Garbage Collection ที่ไม่บล็อกการทำงาน (Non-blocking GC)"],"cons":["Learning Curve สูงมาก (แนวคิด Actor Model และ Functional Programming)","ไวยากรณ์ที่แตกต่างจากภาษาหลักทั่วไป","ชุมชนนักพัฒนาขนาดเล็กและเฉพาะทาง","ไม่เหมาะสำหรับงานคำนวณเชิงตัวเลขที่หนักหน่วง (Number-crunching)","การดีบักและการ Trace อาจซับซ้อน"],"frameworks":["OTP (Open Telecom Platform)","Cowboy (Web Server)","Mnesia (Database)"],"learn":["Erlang.org","Learn You Some Erlang for Great Good!","Erlang Programming (book)","The Erlang Battleground"],"variables":{"declaration (การประกาศ)":["X = 10. % ตัวแปร (เริ่มต้นด้วยตัวพิมพ์ใหญ่, Immutable)","MyAtom = hello. % Atom (ค่าคงที่ที่เริ่มต้นด้วยตัวพิมพ์เล็ก, ไม่ต้องมี quote)","String = \"Erlang\". % String (Double Quotes)"],"types (ประเภท)":["Atom // ค่าคงที่ที่เริ่มต้นด้วยตัวพิมพ์เล็ก (เช่น ok, error, hello)","Integer // จำนวนเต็ม","Float // ทศนิยม","Binary // ข้อมูลไบนารี","Bitstring // Bitstring","Boolean (true, false) // ค่าความจริง","List // รายการ (คล้าย Linked List)","Tuple // Tuple (ลำดับของค่าที่มีขนาดคงที่)","Map // Map (Key-Value store, ตั้งแต่ Erlang/OTP 17.0)","PID (Process Identifier) // Process Identifier (สำหรับ Concurrency)","Reference // Reference","Port // Port (สำหรับสื่อสารกับ External Program)"],"examples (ตัวอย่าง)":["Name = \"Joe\". % กำหนดตัวแปร Name เป็นสตริง","Age = 30. % กำหนดตัวแปร Age เป็นตัวเลข","IsActive = true. % กำหนดตัวแปร IsActive เป็น Boolean (Atom)","Numbers = [1, 2, 3]. % สร้าง List ของตัวเลข","User = {user, \"Alice\", 25}. % สร้าง Tuple (มี Atom 'user' เป็น Tag)","Config = #{host => \"localhost\", port => 8080}. % สร้าง Map (Key-Value pairs)"]},"functions":{"declaration (การประกาศ)":["function_name(Param1, Param2) -> Result. % การประกาศฟังก์ชัน (Module function)","fun (Param) -> Body end. % Anonymous function (ฟังก์ชันนิรนาม)"],"examples":["// ฟังก์ชันบวกเลขสองจำนวน (ใน Module `my_math`)\n-module(my_math).\n-export([add/2]).\n\nadd(A, B) -> A + B. % ฟังก์ชัน add รับ 2 Arguments\n","// ฟังก์ชันทักทาย (ใน Module `my_greeter`)\n-module(my_greeter).\n-export([greet/1]).\n\ngreet(Name) -> io:format(\"Hello, ~s!~n\", [Name]). % ฟังก์ชัน greet รับ 1 Argument\n","// การเรียกใช้ฟังก์ชัน (ใน Shell หรือ Module อื่น)\n% my_math:add(10, 20). % เรียกใช้ฟังก์ชัน add จาก Module my_math (คืนค่า 30)\n% my_greeter:greet(\"Erlang User\"). % แสดงผล 'Hello, Erlang User!'\n","// ฟังก์ชัน Recursive สำหรับ Factorial\n-module(my_factorial).\n-export([factorial/1]).\n\nfactorial(0) -> 1;\nfactorial(N) when N > 0 -> N * factorial(N-1).\n% my_factorial:factorial(5). % คืนค่า 120\n","// Concurrency (Spawning Processes and Message Passing)\n-module(my_process).\n-export([start/0, worker/0]).\n\nstart() -> spawn(fun my_process:worker/0). % สร้าง Process ใหม่และรันฟังก์ชัน worker/0\n\nworker() ->\n    io:format(\"Worker process started with PID ~p~n\", [self()]),\n    receive % รอรับข้อความ\n        {hello, Name} ->\n            io:format(\"Worker received hello from ~s~n\", [Name]),\n            worker(); % ทำงานต่อ\n        stop ->\n            io:format(\"Worker stopping.~n\")\n    end.\n\n% // ใน Erlang Shell:\n% % Pid = my_process:start(). % จะได้ PID ของ Process กลับมา\n% % Pid ! {hello, \"Alice\"}. % ส่งข้อความ {hello, \"Alice\"} ไปยัง Process\n% % Pid ! stop. % ส่งข้อความ stop ไปยัง Process เพื่อให้หยุดทำงาน\n"],"built_in (ในตัว)":["self() // คืนค่า PID ของ Process ปัจจุบัน","spawn(Fun) // สร้าง Process ใหม่และรัน Fun","send(Pid, Msg) // ส่งข้อความ Msg ไปยัง Process ที่มี PID","receive ... end // ใช้สำหรับรอรับข้อความจาก Process อื่น","io:format() // ใช้แสดงผลข้อมูลออกทาง Console (Format String)","lists:map() // ใช้แปลงทุก Element ใน List","lists:filter() // ใช้กรอง Element ใน List","erlang:now() // คืนค่าปัจจุบันของนาฬิการะบบ","erlang:exit(Reason) // ใช้ทำให้ Process หยุดทำงาน"]},"syntax":{"comments (คอมเมนต์)":["% Single-line comment // คอมเมนต์บรรทัดเดียว (เริ่มต้นด้วย %)"],"conditions (เงื่อนไข)":["if Condition1 -> Body1; Condition2 -> Body2; true -> DefaultBody end. % คำสั่ง if (เป็น Expression)","case Expression of\\n  Pattern1 -> Body1;\\n  Pattern2 -> Body2;\\n  _ -> DefaultBody\\nend. % คำสั่ง case (Pattern Matching)"],"loops (การวนซ้ำ)":["// Erlang ไม่มี loop แบบ Imperative โดยตรง (for, while)\n// แต่ใช้ Recursion (การเรียกตัวเองของฟังก์ชัน) และ Pattern Matching เพื่อวนซ้ำ\n\n% ตัวอย่าง Recursion สำหรับนับเลขใน List\nsum_list([]) -> 0;\nsum_list([H|T]) -> H + sum_list(T).\n\n% ตัวอย่าง Tail Recursion สำหรับลูป\nloop_n(N) when N > 0 ->\n    io:format(\"Loop: ~p~n\", [N]),\n    loop_n(N-1);\nloop_n(0) -> ok.\n"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, div, rem // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร (ทศนิยม), หาร (จำนวนเต็ม), เศษเหลือ","Comparison: ==, /=, <, >, =<, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not, xor // ตัวดำเนินการตรรกะ (สำหรับ Boolean)","Bitwise: band, bor, bnot, bxor, bsl, bsr // ตัวดำเนินการระดับบิต","++ // Concatenation (สำหรับ List)","-- // List Subtraction","!, -> // Message Sending Operator and Function Arrow"],"examples":["// ตัวอย่างที่ 1: การใช้ If Expression\nMyNum = 10.\nResult = if MyNum > 5 -> \"Greater than 5\";\n            MyNum =< 5 -> \"Less than or equal to 5\"\n         end.\n% io:format(\"Result: ~s~n\", [Result]). % แสดงผล 'Result: Greater than 5'\n","// ตัวอย่างที่ 2: การใช้ Case Expression (Pattern Matching)\nStatus = {error, \"File not found\"}.\nInfo = case Status of\n           {ok, Data} -> Data;\n           {error, Reason} -> Reason;\n           _ -> \"Unknown Status\"\n       end.\n% io:format(\"Info: ~s~n\", [Info]). % แสดงผล 'Info: File not found'\n","// ตัวอย่างที่ 3: Recursion และ List Processing\n-module(list_ops).\n-export([sum/1, reverse/1]).\n\nsum([]) -> 0;\nsum([H|T]) -> H + sum(T).\n\nreverse(L) -> reverse(L, []).\nreverse([], Acc) -> Acc;\nreverse([H|T], Acc) -> reverse(T, [H|Acc]).\n\n% % ใน Shell:\n% % list_ops:sum([1,2,3]). % คืนค่า 6\n% % list_ops:reverse([a,b,c]). % คืนค่า [c,b,a]\n","// ตัวอย่างที่ 4: Error Handling (Fault-Tolerance) ด้วย Supervisor\n% Erlang ใช้ Supervisor Tree สำหรับ Fault-tolerance\n% Supervisor จะตรวจสอบ Child Processes ถ้า Child Crash, Supervisor จะ Restart Child\n% (โค้ดจริงจะซับซ้อนกว่านี้มาก แต่แนวคิดคือ 'Let It Crash')\n\n% -module(my_worker).\n% -export([start_link/0, crash_me/0]).\n% \n% start_link() ->\n%     proc_lib:start_link(?MODULE, worker, []).\n% \n% worker() ->\n%     io:format(\"Worker ~p started.~n\", [self()]),\n%     receive\n%         crash ->\n%             exit(an_error);\n%         _ -> ok\n%     end,\n%     worker().\n% \n% crash_me(Pid) -> Pid ! crash.\n% \n% % ใน Shell:\n% % {ok, WorkerPid} = my_worker:start_link().\n% % my_worker:crash_me(WorkerPid). % Worker Crash\n% % % Supervisor (ถ้ามี) จะ Restart Worker ให้อัตโนมัติ\n","// ตัวอย่างที่ 5: Hot Code Swapping\n% Erlang สามารถอัปเดตโค้ดขณะรันโดยไม่ต้องหยุดระบบ\n% (นี่คือแค่แนวคิด)\n% 1. รันเวอร์ชันเก่าของ Module\n% 2. คอมไพล์เวอร์ชันใหม่ของ Module\n% 3. โหลดเวอร์ชันใหม่ (Code:load_abs/1)\n% 4. ส่ง Message ให้ Process รันเวอร์ชันใหม่ (โดยใช้ process_flag(trap_exit, true))"]}},{"id":23,"name":"Fortran","slug":"fortran","logo":"img/fortran.png","desc":"Fortran (Formula Translation) เป็นภาษาโปรแกรมที่เก่าแก่และยังคงใช้กันอย่างแพร่หลายในงานทางวิทยาศาสตร์และการคำนวณทางวิศวกรรม โดยเฉพาะงานที่เกี่ยวข้องกับ Supercomputing และ Numerical Analysis","by":"John Backus (IBM)","yr":"1957","level":"1","par":["Procedural","Imperative","Array-oriented"],"fields":["Scientific","HPC"],"rank":"35-40 ยังใช้ใน High-Performance Scientific Computing","salary_range":"฿28,000-48,000 บาท/เดือน (Junior), ฿48,000-80,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["ประสิทธิภาพสูงมากสำหรับการคำนวณตัวเลขและ Array","มีไลบรารีทางคณิตศาสตร์และวิทยาศาสตร์ที่แข็งแกร่ง","เหมาะสำหรับ Parallel Computing","มีความเสถียรและเชื่อถือได้"],"cons":["ล้าสมัยและไม่เหมาะกับการพัฒนาเว็บ/แอปทั่วไป","Syntax ค่อนข้างโบราณและไม่ยืดหยุ่น","การจัดการ I/O ซับซ้อน","ชุมชนนักพัฒนาลดลง","การเรียนรู้อาจยากสำหรับผู้เริ่มต้น"],"frameworks":["None (เป็นภาษาพื้นฐาน)"],"learn":["Fortran Wiki","Fortran-lang.org","Fortran 90/95 for Scientists and Engineers"],"variables":{"declaration (การประกาศ)":["INTEGER :: i // การประกาศตัวแปรจำนวนเต็ม","REAL :: x // การประกาศตัวแปรทศนิยมความแม่นยำเดี่ยว","CHARACTER(len=20) :: name // การประกาศตัวแปรสตริงความยาว 20 ตัวอักษร"],"types (ประเภท)":["INTEGER // จำนวนเต็ม","REAL // ทศนิยมความแม่นยำเดี่ยว","DOUBLE PRECISION // ทศนิยมความแม่นยำคู่","COMPLEX // จำนวนเชิงซ้อน","LOGICAL // ค่าตรรกะ (.TRUE. / .FALSE.)","CHARACTER(len=n) // สตริงความยาว n ตัวอักษร"],"examples (ตัวอย่าง)":["INTEGER :: count = 10 // กำหนดตัวแปร count เก็บตัวเลข 10","REAL :: pi = 3.14159 // กำหนดตัวแปร pi เก็บค่าทศนิยม","CHARACTER(len=15) :: message = 'Hello Fortran' // กำหนดตัวแปร message เป็นสตริง","LOGICAL :: is_true = .TRUE. // กำหนดตัวแปร is_true เป็นค่าตรรกะ TRUE","INTEGER, DIMENSION(3) :: numbers = (/10, 20, 30/) // การประกาศและกำหนดค่า Array (Vector)","REAL, DIMENSION(2,2) :: matrix_A = RESHAPE((/1.0, 2.0, 3.0, 4.0/), SHAPE=(/2,2/)) // การประกาศและกำหนดค่า Matrix"]},"functions":{"declaration (การประกาศ)":["FUNCTION func_name(param1, param2)\n  ! ... (เนื้อหาฟังก์ชัน)\nEND FUNCTION func_name // การประกาศ Function (คืนค่ากลับเป็นตัวฟังก์ชันเอง)","SUBROUTINE sub_name(param1, param2)\n  ! ... (เนื้อหา Subroutine)\nEND SUBROUTINE sub_name // การประกาศ Subroutine (ไม่มีค่าคืนกลับโดยตรง)"],"examples (ตัวอย่าง)":["FUNCTION add(a, b) // ฟังก์ชันบวกเลขสองจำนวน\n  INTEGER, INTENT(IN) :: a, b\n  INTEGER :: add\n  add = a + b\nEND FUNCTION add\n","SUBROUTINE print_data(value) // Subroutine สำหรับแสดงข้อความ\n  INTEGER, INTENT(IN) :: value\n  PRINT *, 'Value is: ', value\nEND SUBROUTINE print_data\n","// การเรียกใช้ฟังก์ชัน/Subroutine\nPROGRAM MainProgram\n  IMPLICIT NONE\n  INTEGER :: RESULT\n  CALL print_data(25)     ! แสดงผล 'Value is: 25'\n  RESULT = add(5, 5)       ! RESULT จะมีค่า 10\n  PRINT *, 'Sum is: ', RESULT\nEND PROGRAM MainProgram\n","SUBROUTINE calculate_area_and_perimeter(length, width, area, perimeter)\n  REAL, INTENT(IN)  :: length, width\n  REAL, INTENT(OUT) :: area, perimeter\n  area = length * width\n  perimeter = 2 * (length + width)\nEND SUBROUTINE calculate_area_and_perimeter\n// การเรียกใช้ Subroutine ที่ส่งค่ากลับทาง Argument (ใช้ INTENT(OUT))\n// PROGRAM Main\n//   IMPLICIT NONE\n//   REAL :: L = 10.0, W = 5.0, A, P\n//   CALL calculate_area_and_perimeter(L, W, A, P)\n//   PRINT *, 'Area = ', A, ' Perimeter = ', P\n// END PROGRAM Main\n","// Asynchronous Programming (แนวคิด - ผ่าน Modules/Libraries)\n// Fortran โดยพื้นฐานเป็นภาษา Sequential และ Parallel Computing (MPI, OpenMP)\n// การทำงานแบบ Asynchronous ที่แท้จริง (Non-blocking I/O) มักจะถูกจัดการโดย Library ภายนอก หรือระดับ OS\n// ตัวอย่างนี้เป็นการแสดงแนวคิดการทำงานที่อาจจะเกิดขึ้นในบริบทของ Parallel Computing (ไม่ใช่ async/await แบบสมัยใหม่)\n/*\nMODULE async_ops\nCONTAINS\n  SUBROUTINE long_computation(result)\n    REAL, INTENT(OUT) :: result\n    PRINT *, 'Starting long computation...'\n    CALL SLEEP(1) ! จำลองการหน่วงเวลา 1 วินาที (อาจต้องใช้ external module)\n    result = 42.0\n    PRINT *, 'Long computation finished!'\n  END SUBROUTINE long_computation\nEND MODULE async_ops\n\nPROGRAM MainAsync\n  USE async_ops\n  IMPLICIT NONE\n  REAL :: data_result\n\n  ! ใน Fortran, การทำ async มักจะเกี่ยวข้องกับ Parallelism\n  ! เช่น การใช้ MPI_IRECV สำหรับ Non-blocking receive หรือ OpenMP tasks\n  ! สำหรับตัวอย่างง่ายๆ นี้ เราเพียงเรียก Subroutine แบบปกติ\n  PRINT *, 'Main program continues while computation runs...'\n  CALL long_computation(data_result)\n  PRINT *, 'Received result: ', data_result\nEND PROGRAM MainAsync\n*/"],"built_in (ในตัว)":["PRINT * // ใช้แสดงผลข้อมูลออกทาง Console (Free-format)","READ * // ใช้รับข้อมูลจากผู้ใช้งาน (Free-format)","SQRT() // คำนวณรากที่สอง","SIN() // คำนวณค่า Sine","COS() // คำนวณค่า Cosine","MAX() // หาค่าสูงสุด","MIN() // หาค่าต่ำสุด","ABS() // หาค่าสัมบูรณ์","MOD() // หาเศษ (Modulo)","LEN() // หาความยาวของสตริง","INT() // แปลงเป็นจำนวนเต็ม","REAL() // แปลงเป็นทศนิยม"]},"syntax":{"comments (คอมเมนต์)":["! Single line comment // คอมเมนต์บรรทัดเดียว (Fortran 90/95+)","C This is a comment line (Legacy Fortran 77) // คอมเมนต์บรรทัดเดียว (ขึ้นต้นด้วย C หรือ * ใน Column 1)"],"conditions (เงื่อนไข)":["IF (condition) THEN\n  ! ... (โค้ด)\nELSE IF (condition) THEN\n  ! ... (โค้ด)\nELSE\n  ! ... (โค้ด)\nEND IF // คำสั่ง IF-ELSE IF-ELSE","SELECT CASE (expression)\n  CASE (value1)\n    ! ... (โค้ด)\n  CASE (value2:value3) ! Range of values\n    ! ... (โค้ด)\n  CASE DEFAULT\n    ! ... (โค้ด)\nEND SELECT // คำสั่ง SELECT CASE (คล้าย Switch)"],"loops (การวนซ้ำ)":["DO i = 1, 5\n  ! ... (โค้ด)\nEND DO // ลูป DO (วนซ้ำตามช่วงตัวเลข)","DO WHILE (condition)\n  ! ... (โค้ด)\nEND DO // ลูป DO WHILE","DO // Infinite loop\n  ! ... (โค้ด)\n  IF (condition) EXIT // ออกจากลูป\nEND DO // ลูป DO แบบไม่รู้จบ"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, ยกกำลัง","Assignment: = // ตัวดำเนินการกำหนดค่า","Comparison: .EQ., .NE., .GT., .LT., .GE., .LE. // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า, มากกว่าหรือเท่ากับ, น้อยกว่าหรือเท่ากับ","Logical: .AND., .OR., .NOT. // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","// // String Concatenation (Fortran 90+)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ IF-ELSE\nPROGRAM ConditionalExample\n  IMPLICIT NONE\n  INTEGER :: num = 10\n  IF (num > 5) THEN\n    PRINT *, 'Num is greater than 5'\n  ELSE\n    PRINT *, 'Num is not greater than 5'\n  END IF\nEND PROGRAM ConditionalExample\n","// ตัวอย่างที่ 2: การใช้วงลูป DO\nPROGRAM LoopExample\n  IMPLICIT NONE\n  INTEGER :: I\n  DO I = 1, 3\n    PRINT *, 'Loop Fortran: ', I\n  END DO\nEND PROGRAM LoopExample\n","// ตัวอย่างที่ 3: การใช้ SELECT CASE\nPROGRAM SelectCaseExample\n  IMPLICIT NONE\n  INTEGER :: score = 85\n  SELECT CASE (score)\n    CASE (90:100)\n      PRINT *, 'Grade A'\n    CASE (70:89)\n      PRINT *, 'Grade B'\n    CASE DEFAULT\n      PRINT *, 'Grade C'\n  END SELECT\nEND PROGRAM SelectCaseExample\n","// ตัวอย่างที่ 4: การทำงานกับ Array และ Vector Operations\nPROGRAM ArrayExample\n  IMPLICIT NONE\n  INTEGER, DIMENSION(3) :: A = (/1, 2, 3/)\n  INTEGER, DIMENSION(3) :: B = (/4, 5, 6/)\n  INTEGER, DIMENSION(3) :: C\n\n  C = A + B ! การบวก Element-wise\n  PRINT *, 'A + B = ', C\n\n  C = A * 2 ! การคูณด้วย Scalar\n  PRINT *, 'A * 2 = ', C\n\n  PRINT *, 'Sum of A: ', SUM(A) ! ใช้ Built-in function SUM\nEND PROGRAM ArrayExample\n","// ตัวอย่างที่ 5: การจัดการไฟล์ (File I/O)\nPROGRAM FileIOExample\n  IMPLICIT NONE\n  INTEGER :: unit_num = 10\n  CHARACTER(len=50) :: line_data\n\n  ! เขียนไฟล์\n  OPEN(UNIT=unit_num, FILE='fortran_output.txt', STATUS='REPLACE')\n  WRITE(unit_num, *) 'Hello from Fortran file!'\n  WRITE(unit_num, *) 'This is another line.'\n  CLOSE(unit_num)\n  PRINT *, 'File written: fortran_output.txt'\n\n  ! อ่านไฟล์\n  OPEN(UNIT=unit_num, FILE='fortran_output.txt', STATUS='OLD')\n  READ(unit_num, '(A)', END=100) line_data ! อ่านบรรทัดแรก\n  PRINT *, 'Read: ', TRIM(line_data)\n  READ(unit_num, '(A)', END=100) line_data ! อ่านบรรทัดที่สอง\n  PRINT *, 'Read: ', TRIM(line_data)\n100 CONTINUE\n  CLOSE(unit_num)\nEND PROGRAM FileIOExample\n"]}},{"id":48,"name":"F#","slug":"fsharp","logo":"img/fsharp.png","desc":"F# (F Sharp) เป็นภาษา Functional Programming ที่ทำงานบนแพลตฟอร์ม .NET พัฒนาโดย Microsoft Research มีคุณสมบัติเด่นด้าน Type Safety, Conciseness (กระชับ) และ Immutability (ไม่เปลี่ยนแปลงค่า) เหมาะสำหรับงาน Data Science, Web Development (Backend), Machine Learning และ Financial Modeling ที่ต้องการความน่าเชื่อถือสูง","by":"Microsoft Research","yr":"2005","level":"4","par":["Functional","Imperative","Object-Oriented"],"fields":["Finance","Scientific"],"rank":"35+ Niche ใน Functional Programming บน .NET","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-110,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["รองรับ Functional Programming ที่บริสุทธิ์ ช่วยลด Bug","ทำงานร่วมกับ .NET Ecosystem ได้อย่างสมบูรณ์","Type Inference ที่แข็งแกร่งและ Type Safety สูง","โค้ดกระชับและอ่านง่าย (Concise Syntax)","เหมาะสำหรับงาน Data Transformation และ Algorithm ที่ซับซ้อน"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Functional Programming","ชุมชนนักพัฒนาเล็กกว่าภาษาหลักทั่วไป","เครื่องมือพัฒนาและการรองรับ IDE อาจไม่สมบูรณ์เท่า C#","ทรัพยากรการเรียนรู้มีจำกัด","ยังไม่เป็นที่นิยมในวงกว้างสำหรับแอปพลิเคชันเชิงพาณิชย์"],"frameworks":["Giraffe (Web Framework)","Fable (F# to JavaScript Compiler)","Saturn (Web Framework)","Suave (Web Framework)"],"learn":["F# Official Documentation","F# for Fun and Profit","Microsoft Learn: F#","Pluralsight F# Courses"],"variables":{"declaration (การประกาศ)":["let x = 10 // การประกาศค่าคงที่ (Immutable by default)","let mutable y = 20 // การประกาศตัวแปรที่เปลี่ยนแปลงได้ (Mutable)"],"types (ประเภท)":["int // จำนวนเต็ม","float // ทศนิยม (Single-precision)","double // ทศนิยม (Double-precision)","bool // ค่าตรรกะ (true/false)","char // ตัวอักขระ","string // ข้อความ","list<'a> // List (Immutable, Linked List)","array<'a> // Array (Mutable, Fixed Size)","option<'a> // Optional type (Some(value) or None)","Result<'ok, 'error> // Result type (Ok(value) or Error(error))","tuple<'a, 'b> // Tuple (กลุ่มของค่าที่มีประเภทต่างกันได้)","record // Record (คล้าย Struct/Object ที่ Immutable)"],"examples (ตัวอย่าง)":["let count = 100 // กำหนดค่าคงที่ count เป็นตัวเลข 100","let message = \"Functional Programming\" // กำหนดค่าคงที่ message เป็นสตริง","let is_active = true // กำหนดค่าคงที่ is_active เป็น Boolean","let numbers = [1; 2; 3] // สร้าง List ของตัวเลข","let data_array = [|1.0; 2.5; 3.0|] // สร้าง Array ของทศนิยม","let user = { Name = \"Alice\"; Age = 30 } // สร้าง Record\n"]},"functions":{"declaration (การประกาศ)":["let functionName param1 param2 = // code // การประกาศฟังก์ชัน (Implicit Return)","let functionName param = function // Pattern matching on input\n  | Pattern -> result // ... code ...","let inline add x y = x + y // Inline Function"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nlet add a b = a + b\n","// ฟังก์ชันทักทาย\nlet greet name = printfn \"Hello, %s!\" name\n","// การเรียกใช้ฟังก์ชัน:\n// let sum_result = add 5 5 // sum_result จะมีค่า 10\n// greet \"F# User\" // แสดงผล 'Hello, F# User!'\n","// ฟังก์ชันที่มี Pattern Matching (คล้าย Switch)\nlet describeNumber n = \n    match n with\n    | 0 -> \"Zero\"\n    | 1 -> \"One\"\n    | _ -> \"Other number\"\n// printfn \"%s\" (describeNumber 0) // Output: Zero\n// printfn \"%s\" (describeNumber 5) // Output: Other number\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\nlet applyTwice f x = f (f x)\n// let result = applyTwice (fun z -> z + 1) 5 // Result: 7\n// printfn \"Result: %d\" result\n","// Asynchronous Programming (Async Workflows)\n// F# มี Async Workflows ที่ช่วยให้เขียนโค้ด Asynchronous ได้อย่างเป็นธรรมชาติและมีประสิทธิภาพ\n// ซึ่งคอมไพล์ไปเป็น State Machine ที่ทำงานบน .NET Task Parallel Library (TPL)\n// open System\n// open System.Threading.Tasks\n\n// let fetchDataAsync () = async {\n//     printfn \"Fetching data...\"\n//     do! Async.Sleep 1000 // จำลองการหน่วงเวลา 1 วินาที\n//     printfn \"Data fetched!\"\n//     return \"Data fetched asynchronously\"\n// }\n\n// // การเรียกใช้ Async Function\n// // let main () = async {\n// //     printfn \"Main program started.\"\n// //     let! data = fetchDataAsync () // ใช้ 'let!' เพื่อรอผลลัพธ์ของ async operation\n// //     printfn \"Received: %s\" data\n// //     printfn \"Main program finished.\"\n// // }\n// // // ต้องรัน Async Workflow ด้วย Async.RunSynchronously หรือ Async.StartAsTask\n// // // main() |> Async.RunSynchronously\n"],"built_in (ในตัว)":["printfn // ใช้แสดงผลข้อมูลออกทาง Console (พร้อมขึ้นบรรทัดใหม่)","List.map // ใช้แปลงทุก Element ใน List","List.filter // ใช้กรอง Element ใน List","String.length // หาความยาวของสตริง","Option.map // สำหรับแปลงค่าใน Optional","Result.bind // สำหรับเชื่อมต่อ Result"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","(* Multi-line\n   comment *) // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition then expression1 else expression2 // คำสั่ง If-Else (เป็น Expression ที่คืนค่า)","match expression with // Pattern Matching ด้วย Match Expression\n  | Pattern1 -> result1\n  | Pattern2 -> result2\n  | _ -> defaultResult // Wildcard สำหรับค่าอื่นๆ"],"loops (การวนซ้ำ)":["for i in 1..5 do // code // ลูป for สำหรับช่วงตัวเลข (รวมค่าสุดท้าย)","for item in collection do // code // ลูป for-in สำหรับวนซ้ำ Collection","while condition do // code // ลูป while","// F# เน้น Functional Programming ดังนั้นมักใช้ Recursion หรือ Higher-Order Functions (map, filter, fold) สำหรับการวนซ้ำมากกว่าลูป Imperative"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: =, <>, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), not (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","|> // Pipe-forward Operator (ส่งผลลัพธ์จากซ้ายไปขวา)","// // Function Composition (เขียนฟังก์ชันเรียงต่อกัน)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else Expression\nlet temperature = 25\nlet weather_status = if temperature > 30 then \"Hot\"\n                     elif temperature < 10 then \"Cold\"\n                     else \"Normal\"\n// printfn \"%s\" weather_status // Output: Normal\n","// ตัวอย่างที่ 2: การใช้วงลูป For\nfor i in 0..2 do\n  printfn \"Loop F#: %d\" i\n","// ตัวอย่างที่ 3: การใช้ Match Expression (Pattern Matching)\nlet check_fruit fruit = \n    match fruit with\n    | \"Apple\" -> \"It's a red fruit.\"\n    | \"Banana\" -> \"It's a yellow fruit.\"\n    | _ -> \"Unknown fruit.\"\n// printfn \"%s\" (check_fruit \"Apple\") // Output: It's a red fruit.\n","// ตัวอย่างที่ 4: การใช้งาน Records และ Discriminated Unions (Type Safety)\ntype Person = { Name: string; Age: int }\ntype PaymentStatus = \n  | Pending\n  | Completed of string // Completed พร้อม Transaction ID\n  | Failed of int // Failed พร้อม Error Code\n\nlet customer = { Name = \"Bob\"; Age = 40 }\n// printfn \"Customer name: %s\" customer.Name\n\nlet processPayment status = \n    match status with\n    | Pending -> printfn \"Payment is pending.\"\n    | Completed(id) -> printfn \"Payment completed with ID: %s\" id\n    | Failed(code) -> printfn \"Payment failed with code: %d\" code\n\n// processPayment Pending\n// processPayment (Completed \"TX12345\")\n// processPayment (Failed 500)\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาดด้วย Option และ Result Types\nlet safeDivide x y = \n    if y = 0 then None\n    else Some(x / y)\n\nlet result1 = safeDivide 10 2\nmatch result1 with\n| Some(value) -> printfn \"Result: %d\" value // Output: Result: 5\n| None -> printfn \"Cannot divide by zero.\"\n\nlet result2 = safeDivide 10 0\nmatch result2 with\n| Some(value) -> printfn \"Result: %d\" value\n| None -> printfn \"Cannot divide by zero.\" // Output: Cannot divide by zero.\n","// ตัวอย่างที่ 6: การใช้ Pipe-forward Operator (|>) และ Function Chaining\nlet calculate tax_rate price = price * (1.0 + tax_rate)\nlet format_currency amount = sprintf \"฿%.2f\" amount\n\nlet final_price = 100.0\n|> calculate 0.07 // 107.0\n|> format_currency // \"฿107.00\"\n\n// printfn \"Final price: %s\" final_price // Output: Final price: ฿107.00\n"]}},{"id":57,"name":"GLSL","slug":"glsl","logo":"img/glsl.png","desc":"GLSL (OpenGL Shading Language) เป็นภาษาโปรแกรมระดับสูง (High-level Shading Language) ที่ใช้สำหรับโปรแกรมมิ่งหน่วยประมวลผลกราฟิก (GPU) ใน Pipeline การแสดงผลกราฟิกแบบเรียลไทม์ (Real-time Graphics Rendering) เป็นส่วนหนึ่งของ OpenGL API ช่วยให้นักพัฒนาสามารถควบคุมกระบวนการ Render ภาพ 3D ได้อย่างละเอียด ตั้งแต่การคำนวณตำแหน่ง Vertex ไปจนถึงการคำนวณสีของ Pixel","by":"OpenGL Architecture Review Board (ARB)","yr":"2004","level":"2","par":["Procedural","Imperative","Concurrent (implicitly)"],"fields":["Game","Graphics","Scientific","Render","VR"],"rank":"เป็นมาตรฐานสำหรับ Real-time Graphics Rendering (ร่วมกับ HLSL)","salary_range":"฿40,000-75,000 บาท/เดือน (Junior), ฿75,000-140,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ควบคุม GPU ได้โดยตรงเพื่อประสิทธิภาพสูงสุดในการ Render กราฟิก","เป็นส่วนหนึ่งของ OpenGL ซึ่งเป็น Open Standard","สามารถสร้าง Visual Effect ที่ซับซ้อนและสวยงามได้","ประมวลผลแบบขนานบน GPU ได้อย่างมีประสิทธิภาพ","เรียนรู้ได้ค่อนข้างง่ายสำหรับผู้ที่มีพื้นฐาน C/C++"],"cons":["เฉพาะทางสูง (ใช้สำหรับกราฟิกโดยเฉพาะ)","ต้องมีความเข้าใจในหลักการกราฟิก 3D และ Linear Algebra","การดีบัก Shader ค่อนข้างยาก","ทำงานกับ Hardware โดยตรง การจัดการ Memory และ Resource ต้องทำด้วยตนเอง","ไม่เหมาะกับการเขียนโปรแกรมทั่วไป"],"frameworks":["OpenGL (Graphics API)","GLFW","GLUT","SDL"],"learn":["OpenGL Documentation","LearnOpenGL.com","The Book of Shaders","Scratchapixel (Computer Graphics)"],"variables":{"declaration (การประกาศ)":["in vec3 vertexColor; // Input variable (จาก Vertex Shader ไป Fragment Shader)","out vec4 FragColor; // Output variable (จาก Fragment Shader ไป Framebuffer)","uniform mat4 modelMatrix; // Uniform variable (ค่าคงที่ที่กำหนดจาก CPU)","const float PI = 3.14159; // Constant variable"],"types (ประเภท)":["float // ทศนิยม","int // จำนวนเต็ม","uint // จำนวนเต็มบวก","bool // ค่าตรรกะ (true/false)","vec2, vec3, vec4 // Vector ของ float (2, 3, 4 องค์ประกอบ)","ivec2, ivec3, ivec4 // Vector ของ int","bvec2, bvec3, bvec4 // Vector ของ bool","mat2, mat3, mat4 // Matrix ของ float (2x2, 3x3, 4x4)","sampler1D, sampler2D, sampler3D // Sampler สำหรับ Texture (1D, 2D, 3D)","struct // โครงสร้างข้อมูล"],"examples (ตัวอย่าง)":["in vec2 TexCoords; // Input: ค่า Coordinate สำหรับ Texture","out vec4 finalColor; // Output: สีสุดท้ายของ Pixel","uniform sampler2D textureSampler; // Uniform: Sampler สำหรับ Texture (ส่งมาจาก CPU)","float shininess = 32.0; // ตัวแปร float","vec3 lightPos = vec3(1.0, 1.0, 1.0); // Vector 3 มิติสำหรับตำแหน่งแสง"]},"functions":{"declaration (การเขียน Shader)":["void main() { /* ... */ } // Main Function (จุดเริ่มต้นการทำงานของ Shader)"],"examples (ตัวอย่าง)":["// Vertex Shader (คำนวณตำแหน่งของ Vertex)\\n#version 330 core\\nlayout (location = 0) in vec3 aPos;\\nlayout (location = 1) in vec3 aColor;\\n\\nout vec3 vertexColor;\\n\\nuniform mat4 model;\\nuniform mat4 view;\\nuniform mat4 projection;\\n\\nvoid main()\\n{\\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\\n    vertexColor = aColor;\\n}\\n","// Fragment Shader (คำนวณสีของ Pixel)\\n#version 330 core\\nin vec3 vertexColor;\\nout vec4 FragColor;\\n\\nvoid main()\\n{\\n    FragColor = vec4(vertexColor, 1.0);\\n}\\n","// ฟังก์ชันที่ผู้ใช้กำหนด (User-defined Function)\\nfloat calculate_distance(vec3 p1, vec3 p2)\\n{\\n    return distance(p1, p2); // ใช้ built-in function distance\\n}\\n\\nvec3 apply_light(vec3 surface_color, vec3 light_direction, vec3 normal)\\n{\n    float diff = max(dot(normal, light_direction), 0.0);\n    return surface_color * diff;\n}\n"],"built_in (ในตัว)":["gl_Position // Output จาก Vertex Shader (ตำแหน่งสุดท้ายของ Vertex)","gl_FragCoord // Input ใน Fragment Shader (ตำแหน่ง Pixel บนหน้าจอ)","gl_FrontFacing // Input ใน Fragment Shader (บอกว่า Pixel อยู่ด้านหน้าหรือหลัง)","texture() // ใช้ดึงค่าสีจาก Texture","dot() // Dot Product ของ Vector","cross() // Cross Product ของ Vector (สำหรับ vec3)","normalize() // ทำให้ Vector มีความยาวเท่ากับ 1","distance() // คำนวณระยะห่างระหว่างจุดสองจุด","mix() // Linear Interpolation (ผสมค่าสองค่า)","clamp() // จำกัดค่าให้อยู่ในช่วงที่กำหนด","sin(), cos(), tan() // ฟังก์ชันตรีโกณมิติ"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for","while (condition) { /* ... */ } // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ",". (swizzling) // Swizzling (เช่น vec4.rgba, vec2.xy)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) ใน Fragment Shader\\n#version 330 core\\nin vec3 vertexColor;\\nout vec4 FragColor;\\nuniform float threshold;\\n\\nvoid main()\\n{\\n    if (vertexColor.r > threshold) {\\n        FragColor = vec4(1.0, 0.0, 0.0, 1.0); // สีแดงถ้าค่า R เกิน threshold\\n    } else {\\n        FragColor = vec4(vertexColor, 1.0); // ใช้สีเดิม\\n    }\\n}\\n","// ตัวอย่างที่ 2: การใช้วงลูป for ใน Fragment Shader (เช่น สำหรับ Lighting)\\n#version 330 core\\nuniform int numLights;\\nuniform vec3 lightPositions[4];\\nuniform vec3 objectColor;\\nout vec4 FragColor;\\n\\nvoid main()\\n{\\n    vec3 final_color = objectColor;\\n    for (int i = 0; i < numLights; i++) {\\n        // จำลองการคำนวณแสงแบบง่ายๆ\\n        final_color += objectColor * 0.1; // เพิ่มแสงทีละนิด\\n    }\\n    FragColor = vec4(final_color, 1.0);\\n}\\n","// ตัวอย่างที่ 3: การใช้ Swizzling และ Vector Operations\\nvec4 myVector = vec4(1.0, 2.0, 3.0, 4.0);\\nvec2 xy = myVector.xy; // xy = (1.0, 2.0)\\nvec3 rgb = myVector.rgb; // rgb = (1.0, 2.0, 3.0)\\nvec4 rearranged = myVector.yxwz; // rearranged = (2.0, 1.0, 4.0, 3.0)\\n\\nvec3 A = vec3(1.0, 0.0, 0.0);\\nvec3 B = vec3(0.0, 1.0, 0.0);\\nfloat dot_product = dot(A, B); // dot_product = 0.0\\nvec3 cross_product = cross(A, B); // cross_product = (0.0, 0.0, 1.0)\\n"]}},{"id":7,"name":"Go","slug":"go","logo":"img/go.png","desc":"Go (หรือ Golang) เป็นภาษาโปรแกรมที่พัฒนาโดย Google เน้นความเรียบง่าย, ประสิทธิภาพสูง และรองรับการทำงานแบบ Concurrency ได้ดี เหมาะสำหรับ Backend services, Cloud computing, และ Networking tools","by":"Robert Griesemer, Rob Pike, Ken Thompson","yr":"2009","level":"2","par":["Concurrent","Structured","Imperative"],"fields":["Cloud","System","Network","Testing","Security","Distributed"],"rank":"6-8 และเติบโตแรงใน Cloud/Backend (เพิ่มขึ้น 1.2% ใน 2024)","salary_range":"฿45,000-70,000 บาท/เดือน (Junior), ฿70,000-130,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ประสิทธิภาพสูง (ใกล้เคียง C/C++)","รองรับ Concurrency ได้ดีด้วย Goroutines","Syntax เรียบง่าย เรียนรู้ง่าย","มีเครื่องมือในตัวครบวงจร (Go tools)","คอมไพล์เป็น Single Binary ทำให้ง่ายต่อการ Deploy"],"cons":["ไม่มี Generics จนถึง Go 1.18 (แต่ตอนนี้มีแล้ว)","ไม่มี OOP แบบคลาส (ใช้ Structs แทน)","การจัดการ Error ที่ค่อนข้างเยอะ (error handling)","ชุมชนยังเล็กกว่าภาษาเก่าแก่"],"frameworks":["Gin","Echo","Revel"],"learn":["Go Tour","Go by Example","Effective Go","Golang Official Documentation"],"variables":{"declaration (การประกาศ)":["var name string = \"John\" // การประกาศตัวแปรแบบเต็มรูปแบบ","age := 30 // การประกาศแบบย่อ (Type Inference)"],"types (ประเภท)":["int // จำนวนเต็ม","int8 // จำนวนเต็ม 8 บิต","int16 // จำนวนเต็ม 16 บิต","int32 // จำนวนเต็ม 32 บิต","int64 // จำนวนเต็ม 64 บิต","uint // จำนวนเต็มบวก","uint8 // จำนวนเต็มบวก 8 บิต","uint16 // จำนวนเต็มบวก 16 บิต","uint32 // จำนวนเต็มบวก 32 บิต","uint64 // จำนวนเต็มบวก 64 บิต","float32 // ทศนิยมความแม่นยำเดี่ยว","float64 // ทศนิยมความแม่นยำคู่","bool // ค่าความจริง (true/false)","string // ข้อความ","array // อาร์เรย์ (ขนาดคงที่)","slice // สไลซ์ (อาร์เรย์ยืดหยุ่น)","map // แผนที่ (Key-Value pairs)","struct // โครงสร้างข้อมูล (คล้าย Class แต่ไม่มีเมธอดในตัว)"],"examples (ตัวอย่าง)":["var message string = \"Hello Go!\" // กำหนดตัวแปร message เป็นสตริง","count := 100 // กำหนดตัวแปร count เป็นตัวเลขด้วย := (การประกาศแบบย่อ)","isActive := true // กำหนดตัวแปร isActive เป็น boolean","var numbers [3]int // ประกาศอาร์เรย์ขนาด 3 ของ int\nnumbers[0] = 1\nnumbers[1] = 2\nnumbers[2] = 3","colors := []string{\"red\", \"green\", \"blue\"} // ประกาศและกำหนดค่า slice","user := map[string]string{\"name\": \"Alice\", \"city\": \"Wonderland\"} // ประกาศและกำหนดค่า map","type Person struct { Name string; Age int } // การประกาศ struct\np1 := Person{Name: \"Bob\", Age: 25} // การสร้าง instance ของ struct"]},"functions":{"declaration (การประกาศ)":["func functionName(param1 type) returnType { /* ... */ } // การประกาศฟังก์ชันทั่วไป"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfunc add(a, b int) int {\n  return a + b\n}\n","// ฟังก์ชันทักทาย\nfunc greet(name string) string {\n  return fmt.Sprintf(\"Hello, %s!\", name)\n}\n","// การเรียกใช้ฟังก์ชัน\nresult := add(10, 20) // result จะมีค่า 30\nmessage := greet(\"Gopher\") // message จะมีค่า 'Hello, Gopher!'\n","// ฟังก์ชันที่คืนค่าหลายค่า\nfunc swap(x, y string) (string, string) {\n  return y, x\n}\na, b := swap(\"hello\", \"world\") // a = \"world\", b = \"hello\"\n","// ฟังก์ชันนิรนาม (Anonymous Function) และ Closure\nfunc makeGreeter(greeting string) func(name string) string {\n  return func(name string) string {\n    return greeting + \" \" + name + \"!\"\n  }\n}\nenglishGreeter := makeGreeter(\"Hello\")\nspanishGreeter := makeGreeter(\"Hola\")\nfmt.Println(englishGreeter(\"Alice\")) // Hello Alice!\nfmt.Println(spanishGreeter(\"Bob\")) // Hola Bob!\n","// เมธอดบน Struct (Method on Struct)\ntype Rectangle struct {\n  Width, Height float64\n}\nfunc (r Rectangle) Area() float64 {\n  return r.Width * r.Height\n}\nrect := Rectangle{Width: 10, Height: 5}\nfmt.Println(\"Area:\", rect.Area()) // Area: 50\n","// Asynchronous Programming (Concurrency) ด้วย Goroutine\n// Go จัดการ Concurrency ผ่าน Goroutines (lightweight threads) และ Channels\n// ตัวอย่างนี้แสดงการทำงานแบบ Concurrency โดยไม่บล็อกการทำงานหลัก\nfunc doSomething(message string) {\n  for i := 0; i < 3; i++ {\n    fmt.Println(message)\n    time.Sleep(time.Millisecond * 100) // หน่วงเวลาชั่วคราว\n  }\n}\n// การเรียกใช้ Goroutine (ต้อง import \"time\")\n// go doSomething(\"Hello from Goroutine!\")\n// fmt.Println(\"Main function continues...\")\n// time.Sleep(time.Second) // รอให้ Goroutine ทำงานจนเสร็จก่อนโปรแกรมหลักจบ"],"built_in (ในตัว)":["fmt.Println() // ใช้แสดงผลข้อมูลออกทาง Console","make() // ใช้สร้าง slice, map, channel","len() // ใช้หาความยาวของ slice, array, string, map, channel","append() // ใช้เพิ่มสมาชิกใน slice","copy() // ใช้คัดลอกข้อมูลจาก slice หนึ่งไปอีก slice หนึ่ง","cap() // ใช้หาความจุของ slice, array, channel","new() // ใช้จัดสรรหน่วยความจำสำหรับประเภทข้อมูล (คืนค่า pointer)","close() // ใช้ปิด channel","panic() // ใช้ทำให้โปรแกรมหยุดทำงานและแสดง error","recover() // ใช้ดักจับ panic"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition { /* ... */ } else if condition { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else"],"loops (การวนซ้ำ)":["for initialization; condition; post { /* ... */ } // ลูป for แบบดั้งเดิม (คล้าย C/C++)","for condition { /* ... */ } // ลูป for แบบ While","for { /* ... */ } // Infinite loop (ลูปไม่รู้จบ)","for index, value := range collection { /* ... */ } // Range-based for loop สำหรับวนซ้ำ Slice, Array, Map, String, Channel"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: &, |, ^, ~ (XOR), <<, >> // ตัวดำเนินการบิตไวส์","& // Address-of Operator (หาที่อยู่หน่วยความจำ)","* // Dereference Operator (เข้าถึงค่าผ่าน Pointer)","<- // Channel Operator (ส่ง/รับข้อมูลผ่าน Channel)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\npackage main\nimport \"fmt\"\nfunc main() {\n  age := 18\n  if age >= 18 {\n    fmt.Println(\"Adult\")\n  } else {\n    fmt.Println(\"Minor\")\n  }\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\npackage main\nimport \"fmt\"\nfunc main() {\n  for i := 0; i < 3; i++ {\n    fmt.Println(\"Loop Go:\", i)\n  }\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\npackage main\nimport \"fmt\"\nfunc main() {\n  day := \"Monday\"\n  switch day {\n  case \"Monday\":\n    fmt.Println(\"Start of the week.\")\n  case \"Friday\":\n    fmt.Println(\"End of the week!\")\n  default:\n    fmt.Println(\"Mid-week.\")\n  }\n}\n","// ตัวอย่างที่ 4: การจัดการ Error\npackage main\nimport (\"errors\"; \"fmt\")\nfunc divide(a, b float64) (float64, error) {\n  if b == 0 {\n    return 0, errors.New(\"cannot divide by zero\")\n  }\n  return a / b, nil\n}\nfunc main() {\n  result, err := divide(10, 2)\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n  } else {\n    fmt.Println(\"Result:\", result)\n  }\n  result, err = divide(10, 0)\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n  }\n}\n","// ตัวอย่างที่ 5: การใช้งาน Slice (Dynamic Array)\npackage main\nimport \"fmt\"\nfunc main() {\n  numbers := []int{1, 2, 3, 4, 5}\n  fmt.Println(\"Original slice:\", numbers)\n  numbers = append(numbers, 6) // เพิ่มสมาชิก\n  fmt.Println(\"After append:\", numbers)\n  // การวนซ้ำด้วย range\n  for i, num := range numbers {\n    fmt.Printf(\"Index %d, Value %d\\n\", i, num)\n  }\n}\n","// ตัวอย่างที่ 6: การใช้งาน Goroutines และ Channels\npackage main\nimport (\"fmt\"; \"time\")\nfunc worker(done chan bool) {\n  fmt.Println(\"Worker: Starting...\")\n  time.Sleep(time.Second) // จำลองการทำงาน\n  fmt.Println(\"Worker: Done!\")\n  done <- true // ส่งสัญญาณว่าเสร็จสิ้น\n}\nfunc main() {\n  done := make(chan bool, 1)\n  go worker(done) // รัน worker เป็น Goroutine\n  fmt.Println(\"Main: Waiting for worker...\")\n  <-done // รอรับสัญญาณจาก worker\n  fmt.Println(\"Main: Worker finished.\")\n}"]}},{"id":38,"name":"GraphQL","slug":"graphql","logo":"img/graphql.png","desc":"GraphQL คือภาษา Query Language สำหรับ API และเป็น Runtime สำหรับการทำ Query ด้วยข้อมูลที่มีอยู่ คุณลักษณะเฉพาะของ GraphQL คือความสามารถในการให้ Client กำหนดรูปแบบโครงสร้างของข้อมูลที่ต้องการจาก Server ได้อย่างชัดเจน","by":"Facebook","yr":"2015 (Open Sourced)","level":"5","par":["Declarative"],"fields":["Backend","API"],"rank":"20-25 เติบโตใน Modern API Development (5.1% ของนักพัฒนา)","salary_range":"฿35,000-58,000 บาท/เดือน (Junior), ฿58,000-98,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["Client สามารถระบุข้อมูลที่ต้องการได้อย่างแม่นยำ (ลด Over-fetching/Under-fetching)","Single Endpoint สำหรับ Query ข้อมูลหลายประเภท","ลดจำนวน Round Trips ระหว่าง Client กับ Server","มีเครื่องมือและ Ecosystem ที่เติบโตอย่างรวดเร็ว (เช่น Apollo, Relay)"],"cons":["Learning Curve สูงกว่า REST สำหรับบางกรณี","การจัดการ Caching อาจซับซ้อนกว่า","ไม่เหมาะกับทุก Use Case (บางครั้ง REST ก็พอ)","อาจทำให้เกิด Query ที่ซับซ้อนและมีประสิทธิภาพต่ำหากออกแบบไม่ดี"],"frameworks":["Apollo Server","Relay","Hasura"],"learn":["GraphQL Official Website","How to GraphQL","Apollo GraphQL Docs"],"variables":{"declaration (การประกาศ)":["Query variables ($varName: Type!)"],"types (ประเภท)":["String","Int","Float","Boolean","ID","Enum","Custom Scalar"],"examples (ตัวอย่าง)":["query GetUserById($id: ID!) { // กำหนด Query และตัวแปร id\n  user(id: $id) { // ดึงข้อมูล user โดยใช้ id\n    name\n    email\n    posts { // ดึงข้อมูลโพสต์ของ user นั้นๆ ด้วย\n      title\n      content\n    }\n  }\n}","mutation CreateUser($name: String!, $email: String!) { // กำหนด Mutation และตัวแปร\n  createUser(input: { name: $name, email: $email }) {\n    id\n    name\n  }\n}"]},"functions":{"declaration (การประกาศ)":["Queries","Mutations","Subscriptions"],"examples (ตัวอย่าง)":["query { allUsers { id name } } // Query เพื่อดึงข้อมูลผู้ใช้ทั้งหมด","mutation { createUser(name: \"New User\") { id } } // Mutation เพื่อสร้างผู้ใช้ใหม่","subscription { newPost { id title } } // Subscription เพื่อรับการแจ้งเตือนเมื่อมีโพสต์ใหม่"],"built_in (ในตัว)":[]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["N/A (Logic handled by resolver functions in backend)"],"loops (การวนซ้ำ)":["N/A (Logic handled by resolver functions in backend)"],"operators (ตัวดำเนินการ)":["N/A (Logical operations handled by backend)"],"examples (ตัวอย่าง)":["query { product(id: \"123\") { name price } } // Query ดึงชื่อและราคาของสินค้าที่มี ID 123","fragment UserFields on User { // Fragment สำหรับระบุ Field ที่ใช้ซ้ำๆ\n  id\n  name\n}","query GetUserAndPosts {\n  user(id: \"456\") { ...UserFields }\n  posts(userId: \"456\") { title }\n}"]}},{"id":62,"name":"HAL/S","slug":"hals","logo":"img/hals.png","desc":"HAL/S (High-order Assembly Language/Shuttle) คือภาษาโปรแกรมระดับสูงที่ออกแบบมาโดยเฉพาะสำหรับภารกิจการบินอวกาศที่มีความสำคัญยิ่งยวดและต้องการความน่าเชื่อถือสูงสุด โดยเป็นภาษาหลักที่ใช้ในการควบคุมการบินของกระสวยอวกาศของ NASA","by":"Intermetrics (NASA)","yr":"1972","level":"1","par":["Procedural","Imperative","Real-time","System Programming"],"fields":["Aero","Embedded","Render","System"],"rank":"Niche (ใช้ในระบบการบินอวกาศ)","salary_range":"฿45,000-80,000 บาท/เดือน (Junior), ฿80,000-150,000 บาท/เดือน (Senior)","salary":["mid","high","veryhigh"],"pros":["ความน่าเชื่อถือและความปลอดภัยสูงมาก (ออกแบบมาเพื่อลดข้อผิดพลาด)","ควบคุมฮาร์ดแวร์ได้ละเอียดและมีประสิทธิภาพสูง","รองรับการประมวลผลแบบ Real-time ที่ซับซ้อน","มี Type System ที่เข้มงวดเพื่อป้องกันข้อผิดพลาด","เหมาะสำหรับระบบควบคุมที่มีความสำคัญต่อชีวิตและทรัพย์สิน"],"cons":["เฉพาะทางสูง ไม่เหมาะกับแอปพลิเคชันทั่วไป","Learning Curve สูงมากและซับซ้อน","ชุมชนนักพัฒนาเล็กและแหล่งเรียนรู้จำกัด","การดีบักซับซ้อนและต้องใช้เครื่องมือเฉพาะ","โค้ดไม่สามารถนำไปใช้กับแพลตฟอร์มอื่นได้ง่าย"],"frameworks":["None (เป็นภาษาพื้นฐานสำหรับระบบฝังตัว)"],"learn":["NASA Documentation","Intermetrics Archives","Aerospace Engineering Texts (Limited Public Access)"],"variables":{"declaration (การประกาศ)":["DECLARE VELOCITY VECTOR (3) REAL; -- ประกาศตัวแปร Vector 3 มิติ ชนิด Real","DECLARE TEMPERATURE REAL; -- ประกาศตัวแปรอุณหภูมิ ชนิด Real","DECLARE STATUS_BITS BIT (8); -- ประกาศตัวแปร Bit String ขนาด 8 บิต"],"types (ประเภท)":["SCALAR (REAL, INTEGER, BOOLEAN) // ตัวเลข (ทศนิยม, จำนวนเต็ม) และบูลีน","VECTOR (n) REAL // เวกเตอร์ (n มิติ) ของจำนวนจริง","MATRIX (m,n) REAL // เมทริกซ์ (m x n มิติ) ของจำนวนจริง","BIT (n) // Bit String ขนาด n บิต","CHARACTER (n) // สตริงตัวอักษรขนาด n ตัว"],"examples (ตัวอย่าง)":["DECLARE POSITION VECTOR (3) REAL; -- กำหนดตัวแปรตำแหน่งเป็น Vector 3 มิติ","DECLARE DELTA_V VECTOR (3) REAL INITIAL (0.0, 0.0, 0.0); -- กำหนดตัวแปร Vector พร้อมค่าเริ่มต้น","DECLARE COMMAND_WORD BIT (16) INITIAL (B'1011001101011110'); -- กำหนด Bit String พร้อมค่าเริ่มต้น","DECLARE ENGINE_STATUS BOOLEAN; -- กำหนดตัวแปรสถานะเป็น Boolean"]},"functions":{"declaration (การประกาศ)":["PROCEDURE COMPUTE_GUIDANCE (STATE IN VECTOR (6) REAL; COMMANDS OUT VECTOR (3) REAL); -- ประกาศ Procedure (คล้ายฟังก์ชันที่คืนค่าผ่าน Parameter)","FUNCTION CALCULATE_MAGNITUDE (V VECTOR (3) REAL) RETURNS REAL; -- ประกาศ Function (คืนค่ากลับ)"],"examples (ตัวอย่าง)":["// Procedure สำหรับคำนวณแรงขับดัน\\nPROCEDURE COMPUTE_THRUST (THRUST_VECTOR OUT VECTOR (3) REAL);\\nBEGIN\\n  THRUST_VECTOR(1) = 100.0; -- กำหนดค่าแกน X ของแรงขับ\\n  THRUST_VECTOR(2) = 50.0;  -- กำหนดค่าแกน Y ของแรงขับ\\n  THRUST_VECTOR(3) = 0.0;   -- กำหนดค่าแกน Z ของแรงขับ\\nEND;\\n","// Function สำหรับคำนวณขนาดของ Vector\\nFUNCTION VECTOR_MAGNITUDE (V VECTOR (3) REAL) RETURNS REAL;\\nBEGIN\\n  RETURN SQRT(V(1)**2 + V(2)**2 + V(3)**2);\\nEND;\\n","// การเรียกใช้ Procedure/Function (ต้องอยู่ใน Main Program หรือ Task)\\n// DECLARE THRUST_COMMAND VECTOR (3) REAL;\\n// CALL COMPUTE_THRUST (THRUST_COMMAND); -- เรียกใช้ Procedure\\n// DECLARE SPEED REAL;\\n// SPEED = VECTOR_MAGNITUDE (THRUST_COMMAND); -- เรียกใช้ Function\\n","// การจัดการ I/O (ตัวอย่างแนวคิด)\\n// READ (SENSOR_CHANNEL) INTO TEMPERATURE; -- อ่านค่าจาก Sensor\\n// WRITE (ACTUATOR_CHANNEL) FROM CONTROL_SIGNAL; -- ส่งค่าไปยัง Actuator"],"built_in (ในตัว)":["SQRT() // คำนวณรากที่สอง","SIN(), COS(), TAN() // ฟังก์ชันตรีโกณมิติ","ABS() // ค่าสัมบูรณ์","DOT_PRODUCT(V1, V2) // Dot product ของ Vector","CROSS_PRODUCT(V1, V2) // Cross product ของ Vector","MAGNITUDE(V) // ขนาดของ Vector","REPLACE // ใช้เปลี่ยนค่า Bit String บางส่วน"],"async (Concurrency)":["TASK CONTROL_LOOP; -- ประกาศ Task สำหรับ Concurrency (ทำงานแบบ Real-time)\n-- ตัวอย่างการสื่อสารระหว่าง Tasks (Rendezvous)\\n-- ENTRY UPDATE_STATE (NEW_STATE IN VECTOR (6) REAL); -- Entry Point สำหรับ Task อื่นเรียกใช้\n-- ACCEPT UPDATE_STATE (NEW_STATE IN VECTOR (6) REAL) DO ... END; -- การรอรับการเรียกจาก Entry Point"]},"syntax":{"comments (คอมเมนต์)":["/* This is a multi-line comment */","-- This is a single-line comment"],"conditions (เงื่อนไข)":["IF condition THEN\\n  statement(s);\\nELSE IF another_condition THEN\\n  statement(s);\\nELSE\\n  statement(s);\\nEND IF; // คำสั่ง IF-ELSE IF-ELSE"],"loops (การวนซ้ำ)":["FOR I FROM 1 TO 10 DO\\n  statement(s);\\nEND FOR; // ลูป FOR (นับเลข)","WHILE condition DO\\n  statement(s);\\nEND WHILE; // ลูป WHILE","LOOP\\n  statement(s);\\n  EXIT WHEN condition;\\nEND LOOP; // ลูปไม่รู้จบพร้อมเงื่อนไขออก"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, **, MOD, REM // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, ยกกำลัง, Modulo, Remainder","Comparison: =, /=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: AND, OR, NOT, XOR // ตัวดำเนินการตรรกะ: AND, OR, NOT, XOR","& // Concatenation (เชื่อมสตริง)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (IF-ELSE)\\nIF TEMPERATURE > 100.0 THEN\\n  CALL ACTIVATE_COOLING_SYSTEM;\\nELSE\\n  CALL DEACTIVATE_COOLING_SYSTEM;\\nEND IF;\\n","// ตัวอย่างที่ 2: การใช้วงลูป FOR\\nFOR I FROM 1 TO NUMBER_OF_CYCLES DO\\n  CALL PERFORM_CALCULATION (I);\\nEND FOR;\\n","// ตัวอย่างที่ 3: การจัดการข้อผิดพลาด (On-Unit / Exception)\\n// HAL/S มีกลไกการจัดการข้อผิดพลาดที่ละเอียด เช่น On-Unit สำหรับ Interrupts\\n// ON OVERFLOW DO\\n//    CALL LOG_ERROR ('Arithmetic Overflow Occurred');\\n//    RECOVER; -- พยายามกู้คืนสถานะ\\n// END ON;\\n","// ตัวอย่างที่ 4: การทำงานกับ Vector และ Matrix Operations\\nDECLARE A MATRIX (3,3) REAL;\\nDECLARE B MATRIX (3,3) REAL;\\nDECLARE C MATRIX (3,3) REAL;\\nDECLARE V VECTOR (3) REAL;\\n\\nC = A * B; -- การคูณเมทริกซ์\\nV = A * V; -- การคูณเมทริกซ์กับ Vector\\nV = V + (10.0, 5.0, 0.0); -- การบวก Vector กับ Constant Vector"]}},{"id":25,"name":"Haskell","slug":"haskell","logo":"img/haskell.png","desc":"Haskell เป็นภาษาโปรแกรม Functional ที่บริสุทธิ์ (Purely Functional) และเป็น Statically-typed เน้นความถูกต้องทางคณิตศาสตร์และการเขียนโค้ดที่ไม่เปลี่ยนแปลง (Immutable) เหมาะสำหรับงานวิจัย, การศึกษา และโปรแกรมที่ต้องการความเสถียรสูง","by":"Simon Peyton Jones, Philip Wadler, et al.","yr":"1990","level":"3","par":["Functional","Lazy Evaluation"],"fields":["Compiler","Edu","Math","Script"],"rank":"35-40 Niche ใน Functional Programming","salary_range":"฿38,000-60,000 บาท/เดือน (Junior), ฿60,000-105,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["โค้ดมีความถูกต้องทางคณิตศาสตร์สูง (Guaranteed Correctness)","ลด Bug จาก Side Effects","มี Type System ที่แข็งแกร่งและปลอดภัย","รองรับ Lazy Evaluation","เหมาะสำหรับ Concurrency"],"cons":["Learning Curve สูงมาก (แนวคิด Functional ที่แตกต่าง)","เข้าใจ Monads และ Type Classes ได้ยาก","การดีบักอาจทำได้ยาก","ชุมชนนักพัฒนาเล็กและ Niche","ไม่ได้รับความนิยมในอุตสาหกรรมทั่วไป"],"frameworks":["Yesod","Servant"],"learn":["Learn You a Haskell for Great Good!","Haskell Book","Haskell.org","Stackage"],"variables":{"declaration (การประกาศ)":["let x = 5 -- การประกาศค่าคงที่ (Immutable by default)","let greeting = \"Hello\" -- การประกาศค่าคงที่สตริง"],"types (ประเภท)":["Int // จำนวนเต็ม","Float // ทศนิยมความแม่นยำเดี่ยว","Double // ทศนิยมความแม่นยำคู่","Char // ตัวอักขระ","Bool // ค่าตรรกะ (True/False)","String // ข้อความ (List ของ Char)","List a // List ของ Type 'a' ใดๆ (เช่น [Int], [Char])","Tuple a b // Tuple (เก็บค่าหลายประเภทได้)","Maybe a // ประเภทที่อาจมีค่า (Just a) หรือไม่มีค่า (Nothing)","IO a // ประเภทสำหรับการทำงานที่มี Side Effect (เช่น I/O)"],"examples (ตัวอย่าง)":["let number = 10 -- กำหนดค่าคงที่ number เป็น 10","let message = \"Purely Functional\" -- กำหนดค่าคงที่ message เป็นสตริง","let myList = [1, 2, 3] -- สร้าง List ของตัวเลข","let myTuple = (\"Alice\", 30) -- สร้าง Tuple (สตริง, จำนวนเต็ม)","let optionalValue = Just 5 -- ตัวแปร Maybe ที่มีค่า","let noValue = Nothing -- ตัวแปร Maybe ที่ไม่มีค่า"]},"functions":{"declaration (การประกาศ)":["functionName :: Type -> Type -> ReturnType\nfunctionName param1 param2 = expression -- การประกาศฟังก์ชันพร้อม Type Signature"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nadd :: Int -> Int -> Int\nadd a b = a + b\n","// ฟังก์ชันทักทาย (ใช้ IO เพื่อพิมพ์ออก Console)\ngreet :: String -> IO ()\ngreet name = putStrLn (\"Hello, \" ++ name ++ \"!\")\n","// การเรียกใช้ฟังก์ชัน\n-- ต้องรันใน main function หรือใน GHCi\n-- let sum = add 5 5 -- sum จะมีค่า 10\n-- greet \"Haskeller\" -- แสดงผล 'Hello, Haskeller!'\n","// ฟังก์ชัน Recursive สำหรับ Factorial\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n-- factorial 5 -- 120\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n-- applyTwice (+1) 5 -- 7 (5 -> 6 -> 7)\n","// การทำงานกับ List โดยใช้ Pattern Matching\nsumList :: [Int] -> Int\nsumList [] = 0\nsumList (x:xs) = x + sumList xs\n-- sumList [1, 2, 3] -- 6\n","// Asynchronous Programming (Conceptual - Haskell ใช้ Monads และ Libraries)\n// Haskell จัดการ Concurrency และ Asynchronous Programming ผ่าน Monads (เช่น IO Monad, STM)\n// และ Libraries เช่น 'async' หรือ 'stm'\n// ตัวอย่างนี้แสดงแนวคิดการทำงานแบบ Asynchronous ด้วย `forkIO` (ใน IO Monad)\n/*\n-- import Control.Concurrent\n-- import Control.Monad\n\n-- asyncTask :: String -> IO ()\n-- asyncTask msg = do\n--   putStrLn $ \"Starting async task: \" ++ msg\n--   threadDelay 1000000 -- 1 วินาที (in microseconds)\n--   putStrLn $ \"Finished async task: \" ++ msg\n\n-- main :: IO ()\n-- main = do\n--   putStrLn \"Main: Starting...\"\n--   forkIO $ asyncTask \"Task A\"\n--   forkIO $ asyncTask \"Task B\"\n--   putStrLn \"Main: Continuing...\"\n--   threadDelay 2000000 -- ให้เวลากับ async tasks ได้รัน\n--   putStrLn \"Main: Done.\"\n*/"],"built_in (ในตัว)":["putStrLn // ใช้แสดงสตริงพร้อมขึ้นบรรทัดใหม่","getLine // ใช้รับสตริงจากผู้ใช้","map // ใช้แปลงทุก Element ใน List","filter // ใช้กรอง Element ใน List","foldl // ใช้ลด (Reduce) List จากซ้ายไปขวา","head // คืนค่า Element แรกของ List","tail // คืนค่า List ที่เหลือ (ไม่รวม Element แรก)","(++) // Concatenate List (เช่น String)","($) // Operator สำหรับ Apply Function (Function Application)"]},"syntax":{"comments (คอมเมนต์)":["-- Single line comment // คอมเมนต์บรรทัดเดียว","{- Multi-line\n   comment -} // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition then expression1 else expression2 // คำสั่ง If-Else (เป็น Expression)","case expression of\n  pattern1 -> result1\n  pattern2 -> result2\n  _        -> defaultResult // Pattern Matching ด้วย Case Expression"],"loops (การวนซ้ำ)":["// Haskell ไม่มี loop แบบ Imperative โดยตรง (for, while)\n// แต่จะใช้ Recursion, Higher-Order Functions (map, filter, fold) หรือ List Comprehensions แทน","map (+1) [1,2,3] -- [2,3,4] (การใช้ map เพื่อวนลูปและแปลงค่า)","[x * 2 | x <- [1..5], x `mod` 2 == 0] -- [4, 8] (List Comprehension - วนลูปและกรอง)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร (สำหรับ Float/Double), ยกกำลัง","Comparison: ==, /=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), not (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else Expression\n-- if-else ใน Haskell เป็น Expression ที่คืนค่า\nlet age = 20\nlet status = if age >= 18 then \"Adult\" else \"Minor\"\n-- ใน main function หรือ GHCi\n-- putStrLn status -- แสดงผล 'Adult'\n","// ตัวอย่างที่ 2: การใช้ Map (Functional Loop)\n-- map เป็น Higher-Order Function ที่ใช้แปลงทุก Element ใน List\nlet numbers = [1, 2, 3]\nlet doubled = map (*2) numbers\n-- ใน main function หรือ GHCi\n-- print doubled -- แสดงผล '[2,4,6]'\n","// ตัวอย่างที่ 3: การใช้ Case Expression (Pattern Matching)\n-- Case expression ใช้สำหรับตรวจสอบรูปแบบของข้อมูลและคืนค่าตามรูปแบบนั้น\n-- factorial :: Int -> Int\n-- factorial n = case n of\n--   0 -> 1\n--   _ -> n * factorial (n - 1)\n-- factorial 4 -- 24\n","// ตัวอย่างที่ 4: การทำงานกับ List Comprehension\n-- List Comprehension เป็นวิธีที่กระชับในการสร้าง List ใหม่จาก List เดิม\nlet evenSquares = [x^2 | x <- [1..10], x `mod` 2 == 0]\n-- evenSquares -- [4, 16, 36, 64, 100] (กำลังสองของเลขคู่ 1-10)\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\n-- Haskell ใช้ `Either` หรือ `Maybe` Monad สำหรับการจัดการข้อผิดพลาดแบบ Functional\n-- หรือใช้ `try` จาก Control.Exception สำหรับ Exceptions จริงๆ\n\n-- safelyDivide :: Int -> Int -> Maybe Int\n-- safelyDivide _ 0 = Nothing\n-- safelyDivide a b = Just (a `div` b)\n\n-- -- ใน main function หรือ GHCi\n-- -- print $ safelyDivide 10 2 -- Just 5\n-- -- print $ safelyDivide 10 0 -- Nothing\n","// ตัวอย่างที่ 6: การทำงานกับ IO (Input/Output)\n-- การทำงานกับ Side Effect เช่น I/O จะอยู่ใน IO Monad\n-- main :: IO ()\n-- main = do\n--   putStrLn \"Enter your name:\"\n--   name <- getLine\n--   putStrLn $ \"Hello, \" ++ name ++ \"!\"\n"]}},{"id":58,"name":"HLSL","slug":"hlsl","logo":"img/hlsl.svg","desc":"HLSL (High-Level Shading Language) เป็นภาษาโปรแกรมสำหรับ Shaders ที่พัฒนาโดย Microsoft ใช้สำหรับโปรแกรมมิ่งหน่วยประมวลผลกราฟิก (GPU) ใน Pipeline การแสดงผลกราฟิกแบบเรียลไทม์ (Real-time Graphics Rendering) บนแพลตฟอร์ม Microsoft DirectX มีความสามารถในการควบคุมการ Render ภาพ 3D ได้อย่างละเอียด ตั้งแต่การคำนวณตำแหน่ง Vertex ไปจนถึงการคำนวณสีของ Pixel","by":"Microsoft","yr":"2002","level":"2","par":["Procedural","Imperative","Concurrent (implicitly)"],"fields":["Game","Graphics","Scientific","Render","VR"],"rank":"เป็นมาตรฐานสำหรับ Real-time Graphics Rendering บน Windows/Xbox (ร่วมกับ GLSL)","salary_range":"฿40,000-75,000 บาท/เดือน (Junior), ฿75,000-140,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ควบคุม GPU ได้โดยตรงเพื่อประสิทธิภาพสูงสุดในการ Render กราฟิกบน DirectX","บูรณาการเข้ากับ Ecosystem ของ Microsoft (DirectX, Visual Studio)","สามารถสร้าง Visual Effect ที่ซับซ้อนและสวยงามได้","ประมวลผลแบบขนานบน GPU ได้อย่างมีประสิทธิภาพ","ไวยากรณ์คล้าย C/C++ ทำให้เรียนรู้ได้ง่ายสำหรับผู้ที่มีพื้นฐาน"],"cons":["ผูกติดกับแพลตฟอร์ม Microsoft DirectX (ไม่สามารถใช้กับ OpenGL/Vulkan โดยตรง)","ต้องมีความเข้าใจในหลักการกราฟิก 3D และ Linear Algebra","การดีบัก Shader ค่อนข้างยากและต้องใช้เครื่องมือเฉพาะ","ทำงานกับ Hardware โดยตรง การจัดการ Memory และ Resource ต้องทำด้วยตนเอง","ไม่เหมาะกับการเขียนโปรแกรมทั่วไป"],"frameworks":["DirectX (Graphics API)","Direct3D"],"learn":["Microsoft DirectX Documentation","DirectX-Graphics-Samples","GameDev.net (HLSL Tutorials)","Shader Playground"],"variables":{"declaration (การประกาศ)":["struct VertexInput { float3 position : POSITION; float3 normal : NORMAL; }; // การประกาศ Struct สำหรับ Input/Output","float4 outputColor : SV_Target; // Output variable สำหรับ Fragment (Pixel) Shader","cbuffer PerFrame { float4x4 ViewProjection; }; // Uniform variable (ค่าคงที่ที่กำหนดจาก CPU)"],"types (ประเภท)":["float, float2, float3, float4 // ทศนิยม (1, 2, 3, 4 องค์ประกอบ)","half, half2, half3, half4 // ทศนิยมความแม่นยำต่ำ (สำหรับประสิทธิภาพ)","minfloat, minhalf, minint // ทศนิยม/จำนวนเต็มความแม่นยำต่ำสุด","int, int2, int3, int4 // จำนวนเต็ม","uint, uint2, uint3, uint4 // จำนวนเต็มบวก","bool, bool2, bool3, bool4 // ค่าตรรกะ (true/false)","matrix (float2x2, float3x3, float4x4) // Matrix ของ float (2x2, 3x3, 4x4)","sampler, SamplerState // Sampler สำหรับ Texture","Texture1D, Texture2D, Texture3D, TextureCube // Object สำหรับ Texture","struct // โครงสร้างข้อมูล"],"examples (ตัวอย่าง)":["float2 TexCoords; // ค่า Coordinate สำหรับ Texture","float4 finalColor; // สีสุดท้ายของ Pixel","SamplerState mySampler; // Sampler สำหรับ Texture (ส่งมาจาก CPU)","Texture2D myTexture; // Texture object (ส่งมาจาก CPU)","float shininess = 32.0f; // ตัวแปร float (มี 'f' ต่อท้ายสำหรับ literal)","float3 lightPos = float3(1.0f, 1.0f, 1.0f); // Vector 3 มิติสำหรับตำแหน่งแสง"]},"functions":{"declaration (การเขียน Shader)":["VS_OUTPUT MyVertexShader(VS_INPUT input) { /* ... */ } // Vertex Shader Function","float4 MyPixelShader(PS_INPUT input) : SV_Target { /* ... */ } // Pixel (Fragment) Shader Function"],"examples (ตัวอย่าง)":["// Vertex Shader (คำนวณตำแหน่งของ Vertex)\\nstruct VS_INPUT {\\n    float3 position : POSITION;\\n    float3 color    : COLOR;\\n};\\n\\nstruct VS_OUTPUT {\\n    float4 position : SV_POSITION;\\n    float3 color    : COLOR;\\n};\\n\\ncbuffer PerFrame : register(b0) {\\n    float4x4 WorldViewProjection;\\n};\\n\\nVS_OUTPUT MyVertexShader(VS_INPUT input)\\n{\\n    VS_OUTPUT output;\\n    output.position = mul(float4(input.position, 1.0f), WorldViewProjection);\\n    output.color = input.color;\\n    return output;\\n}\\n","// Pixel Shader (คำนวณสีของ Pixel)\\nstruct PS_INPUT {\\n    float4 position : SV_POSITION;\\n    float3 color    : COLOR;\\n};\\n\\nfloat4 MyPixelShader(PS_INPUT input) : SV_Target\\n{\n    return float4(input.color, 1.0f);\n}\\n","// ฟังก์ชันที่ผู้ใช้กำหนด (User-defined Function)\\nfloat CalculateDistance(float3 p1, float3 p2)\\n{\\n    return distance(p1, p2); // ใช้ built-in function distance\\n}\\n\\nfloat3 ApplyLighting(float3 surfaceColor, float3 lightDirection, float3 normal)\\n{\n    float diff = max(dot(normal, lightDirection), 0.0f);\n    return surfaceColor * diff;\n}\n"],"built_in (ในตัว)":["SV_POSITION // Output จาก Vertex Shader (ตำแหน่งสุดท้ายของ Vertex)","SV_Target // Output จาก Pixel Shader (สีของ Pixel)","POSITION, NORMAL, TEXCOORD, COLOR // Semantics สำหรับ Input/Output registers","mul() // คูณ Matrix/Vector","dot() // Dot Product ของ Vector","cross() // Cross Product ของ Vector (สำหรับ float3)","normalize() // ทำให้ Vector มีความยาวเท่ากับ 1","distance() // คำนวณระยะห่างระหว่างจุดสองจุด","lerp() // Linear Interpolation (ผสมค่าสองค่า)","clamp() // จำกัดค่าให้อยู่ในช่วงที่กำหนด","sin(), cos(), tan() // ฟังก์ชันตรีโกณมิติ","saturate() // จำกัดค่าให้อยู่ในช่วง 0.0 ถึง 1.0","tex2D(), Sample() // ใช้ดึงค่าสีจาก Texture (ขึ้นอยู่กับเวอร์ชัน HLSL)"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for","while (condition) { /* ... */ } // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ",". (swizzling) // Swizzling (เช่น float4.rgba, float2.xy)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) ใน Pixel Shader\\nfloat4 MyConditionalPixelShader(float4 color : COLOR) : SV_Target\\n{\\n    if (color.r > 0.5f) {\\n        return float4(1.0f, 0.0f, 0.0f, 1.0f); // สีแดงถ้าค่า R เกิน 0.5\\n    } else {\\n        return color; // ใช้สีเดิม\\n    }\\n}\\n","// ตัวอย่างที่ 2: การใช้วงลูป for ใน Pixel Shader (เช่น สำหรับ Blur Effect)\\nTexture2D myTexture;\\nSamplerState mySampler;\\n\\nfloat4 MyBlurPixelShader(float2 texCoord : TEXCOORD) : SV_Target\\n{\\n    float4 sum = 0;\\n    float blurSize = 1.0f / 1024.0f; // ขนาดของ Pixel ที่จะ Blur\\n    for (int x = -1; x <= 1; x++) {\\n        for (int y = -1; y <= 1; y++) {\\n            sum += myTexture.Sample(mySampler, texCoord + float2(x * blurSize, y * blurSize));\\n        }\\n    }\\n    return sum / 9.0f;\\n}\\n","// ตัวอย่างที่ 3: การใช้ Swizzling และ Vector Operations\\nfloat4 myVector = float4(1.0f, 2.0f, 3.0f, 4.0f);\\nfloat2 xy = myVector.xy; // xy = (1.0f, 2.0f)\\nfloat3 rgb = myVector.rgb; // rgb = (1.0f, 2.0f, 3.0f)\\nfloat4 rearranged = myVector.yxwz; // rearranged = (2.0f, 1.0f, 4.0f, 3.0f)\\n\\nfloat3 A = float3(1.0f, 0.0f, 0.0f);\\nfloat3 B = float3(0.0f, 1.0f, 0.0f);\\nfloat dot_product = dot(A, B); // dot_product = 0.0f\\nfloat3 cross_product = cross(A, B); // cross_product = (0.0f, 0.0f, 1.0f)\\n"]}},{"id":4,"name":"Java","slug":"java","logo":"img/java.png","desc":"Java เป็นภาษาโปรแกรมเชิงวัตถุที่ได้รับความนิยมสูง ถูกออกแบบมาให้เขียนครั้งเดียวสามารถรันได้ทุกที่ (Write Once, Run Anywhere) มีการใช้งานอย่างกว้างขวางในแอปพลิเคชันระดับองค์กร, Android, และ Big Data","by":"James Gosling","yr":"1995","level":"3","par":["Object-Oriented","Concurrent","Structured","Imperative","Generic"],"fields":["Mobile","Backend","Desktop","Cloud","Testing","Finance"],"rank":"3 ใน TIOBE Index 2025 (10.66%)","salary_range":"฿35,000-60,000 บาท/เดือน (Junior), ฿60,000-100,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["แพลตฟอร์มเป็นอิสระ (JVM)","ประสิทธิภาพสูงและเสถียร","มี Ecosystem และไลบรารีขนาดใหญ่","มีการจัดการหน่วยความจำอัตโนมัติ (Garbage Collection)","ความปลอดภัยสูง"],"cons":["ใช้หน่วยความจำค่อนข้างมาก","อาจมี Learning Curve สูงสำหรับผู้เริ่มต้น","การเขียนโค้ดอาจดูเยอะกว่าภาษาที่ทันสมัยกว่า","เวลาในการ Start-up แอปพลิเคชันอาจช้า"],"frameworks":["Spring Boot","Hibernate","Android SDK","Apache Kafka","Apache Spark"],"learn":["Oracle Java Documentation","Baeldung","GeeksforGeeks Java Tutorial","Coursera: Java Programming"],"variables":{"declaration (การประกาศ)":["int count; // การประกาศตัวแปรจำนวนเต็ม","String message; // การประกาศตัวแปรสตริง","boolean status; // การประกาศตัวแปรบูลีน"],"types (ประเภท)":["byte // จำนวนเต็มขนาด 8 บิต","short // จำนวนเต็มขนาด 16 บิต","int // จำนวนเต็มขนาด 32 บิต","long // จำนวนเต็มขนาด 64 บิต","float // ทศนิยมความแม่นยำเดี่ยว","double // ทศนิยมความแม่นยำคู่","char // ตัวอักขระ (Unicode)","boolean // ค่าจริงหรือเท็จ","String // คลาสสำหรับจัดการข้อความ","Object // คลาสแม่ของทุกคลาสใน Java","Array // โครงสร้างข้อมูลสำหรับเก็บกลุ่มของข้อมูลประเภทเดียวกัน"],"examples (ตัวอย่าง)":["int age = 20; // กำหนดตัวแปร age เก็บตัวเลข 20","String name = \"Bob\"; // กำหนดตัวแปร name เก็บข้อความ","boolean isActive = false; // กำหนดตัวแปร isActive เก็บค่าความจริง","double price = 19.99; // กำหนดตัวแปร price เก็บเลขทศนิยม","int[] scores = {90, 85, 70}; // ประกาศและกำหนดค่าอาร์เรย์ของคะแนน"]},"functions":{"declaration (การประกาศ)":["public static returnType methodName(parameters) { /* ... */ } // การประกาศเมธอด (ฟังก์ชัน) แบบปกติ","(parameters) -> expression // Lambda expression (ฟังก์ชันนิรนามแบบย่อ)","public returnType instanceMethod(parameters) { /* ... */ } // การประกาศ Instance Method (ต้องสร้าง Object ก่อนเรียกใช้)"],"examples (ตัวอย่าง)":["// เมธอด (ฟังก์ชัน) สำหรับบวกเลขสองจำนวน\npublic int sum(int a, int b) {\n  return a + b;\n}\n","// เมธอด (ฟังก์ชัน) สำหรับแสดงข้อความออกทาง Console\npublic void displayInfo(String data) {\n  System.out.println(data);\n}\n","// การเรียกใช้เมธอด\nint total = sum(7, 8); // total จะมีค่า 15\ndisplayInfo(\"Java rocks!\"); // แสดงผล 'Java rocks!'\n","// เมธอด Overloading (ชื่อเมธอดเดียวกันแต่พารามิเตอร์ต่างกัน)\npublic int add(int a, int b) { return a + b; }\npublic double add(double a, double b) { return a + b; }\n// การเรียกใช้ Overloaded Method\nint sumInt = add(10, 20); // เรียก add(int, int)\ndouble sumDouble = add(10.5, 20.5); // เรียก add(double, double)\n","// เมธอดที่รับจำนวนอาร์กิวเมนต์แบบไม่จำกัด (Varargs)\npublic int sumAll(int... numbers) {\n  int totalSum = 0;\n  for (int num : numbers) {\n    totalSum += num;\n  }\n  return totalSum;\n}\n// การเรียกใช้ Varargs Method\nint varargsSum = sumAll(1, 2, 3, 4); // varargsSum จะมีค่า 10\n","// การใช้งาน Lambda expression (สำหรับ Functional Interface)\n// สมมติมี Functional Interface: interface MathOperation { int operate(int a, int b); }\n// MathOperation addition = (a, b) -> a + b;\n// System.out.println(\"Lambda Sum: \" + addition.operate(5, 5)); // แสดงผล 'Lambda Sum: 10'\n","// Asynchronous Programming (Concurrency) ด้วย Thread\n// Java จัดการ Concurrency ผ่าน Threads, Executors หรือ CompletableFuture\n// ตัวอย่างนี้เป็นการสร้างและรัน Thread ง่ายๆ\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Thread is running.\");\n    }\n}\n// ในเมธอด main หรือที่อื่น:\n// Thread thread = new Thread(new MyRunnable());\n// thread.start(); // เริ่มการทำงานของ Thread\n"],"built_in (ในตัว)":["System.out.println() // ใช้แสดงผลข้อมูลออกทาง Console","ArrayList<T> // คอลเลกชันแบบ List ที่ปรับขนาดได้ (Generic)","HashMap<K, V> // คอลเลกชันแบบ Key-Value Pairs (Generic)","Math.random() // ใช้สร้างเลขสุ่ม (0.0 ถึงน้อยกว่า 1.0)","File.exists() // ใช้ตรวจสอบว่าไฟล์มีอยู่จริงหรือไม่ (ต้อง import java.io.File)"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","for (Type item : collection) { /* ... */ } // Enhanced for loop (foreach) สำหรับวนซ้ำคอลเลกชัน"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Ternary: ? : // ตัวดำเนินการเงื่อนไขแบบย่อ (Conditional Operator)","instanceof // ตัวดำเนินการตรวจสอบประเภท Object","new // ตัวดำเนินการสร้าง Object ใหม่"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else if (time > 22) {\n  System.out.println(\"Good night.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (int i = 0; i < 3; i++) {\n  System.out.println(\"Loop Java: \" + i);\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nint dayOfWeek = 3; // 1 = Monday, 2 = Tuesday, etc.\nswitch (dayOfWeek) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  case 7:\n    System.out.println(\"Sunday\");\n    break;\n  default:\n    System.out.println(\"Mid-week day\");\n}\n","// ตัวอย่างที่ 4: การใช้งานคลาสและ Object-Oriented Programming (OOP)\npublic class Dog {\n  String name;\n  int age;\n\n  public Dog(String name, int age) { // Constructor\n    this.name = name;\n    this.age = age;\n  }\n\n  public void bark() {\n    System.out.println(name + \" says Woof!\");\n  }\n}\n// สร้าง Object จากคลาส Dog ในเมธอด main หรือที่อื่น\n// Dog myDog = new Dog(\"Buddy\", 3);\n// myDog.bark(); // แสดงผล \"Buddy says Woof!\"\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nimport java.util.Scanner;\ntry {\n  Scanner scanner = new Scanner(System.in);\n  System.out.print(\"Enter a number: \");\n  int num = scanner.nextInt();\n  int result = 100 / num; // อาจเกิด ArithmeticException ถ้า num เป็น 0\n  System.out.println(\"Result: \" + result);\n} catch (ArithmeticException e) {\n  System.out.println(\"Error: Cannot divide by zero!\");\n} catch (Exception e) {\n  System.out.println(\"An unexpected error occurred: \" + e.getMessage());\n} finally {\n  System.out.println(\"Operation finished.\");\n}\n","// ตัวอย่างที่ 6: การทำงานกับ ArrayList (Collection Framework)\nimport java.util.ArrayList;\nArrayList<String> fruits = new ArrayList<>();\nfruits.add(\"Apple\");\nfruits.add(\"Banana\");\nfruits.add(\"Cherry\");\nSystem.out.println(\"Fruits: \" + fruits);\n","// ตัวอย่างที่ 7: การจัดการไฟล์ (File I/O) - การเขียนไฟล์\nimport java.io.FileWriter;\nimport java.io.IOException;\ntry {\n  FileWriter writer = new FileWriter(\"java_example.txt\");\n  writer.write(\"Hello from Java file!\\n\");\n  writer.close();\n  System.out.println(\"File 'java_example.txt' created.\");\n} catch (IOException e) {\n  System.out.println(\"An error occurred while writing to file: \" + e.getMessage());\n}\n"]}},{"id":6,"name":"JavaScript","slug":"javascript","logo":"img/js.png","desc":"JavaScript คือภาษาโปรแกรมที่ทำให้เว็บมีชีวิตชีวา ทั้งปุ่มกด, แอนิเมชัน หรือการตรวจสอบข้อมูล รวมถึงสร้างแอปมือถือและโปรแกรมคอมพิวเตอร์ได้ด้วย","by":"Brendan Eich","yr":"December 4, 1995","level":"4","par":["Multi-paradigm","Event-driven","Functional"],"fields":["Frontend","Backend","Plugin","Testing","Blockchain","Graphics","Render","Script"],"rank":"1 ในกลุ่ม Web Development (ใช้โดย 62.3% ของนักพัฒนาทั่วโลก)","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-85,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ใช้ได้หลายแพลตฟอร์ม (เว็บ, มือถือ, คอมพิวเตอร์)","มีแหล่งเรียนรู้และตัวช่วยเยอะมาก","เริ่มต้นเรียนรู้ได้ง่าย","ทำงานหลายอย่างพร้อมกันได้ดี","ปรับเปลี่ยนการใช้งานได้หลากหลาย"],"cons":["การเขียนโค้ดอิสระ อาจทำให้ไม่เป็นระเบียบ","ทำงานซับซับซ้อนมากๆ ได้ช้ากว่าบางภาษา","การจัดการงานที่ต้องรออาจยุ่งยาก","อาจแสดงผลต่างกันในแต่ละเบราว์เซอร์","โค้ดบนเว็บสามารถถูกดูและแก้ไขง่าย"],"frameworks":["React","Angular","Vue.js","Node.js (Runtime)","Express.js","Next.js"],"learn":["MDN Web Docs","freeCodeCamp","The Modern JavaScript Tutorial","JavaScript.info"],"variables":{"declaration (การประกาศ)":["var // วิธีการประกาศตัวแปรแบบเก่า","let // วิธีการประกาศตัวแปรที่สามารถเปลี่ยนค่าได้","const // วิธีการประกาศค่าคงที่ที่ไม่สามารถเปลี่ยนค่าได้"],"types (ประเภท)":["String // ประเภทข้อมูลข้อความ","Number // ประเภทข้อมูลตัวเลข","Boolean // ประเภทข้อมูลค่าจริงหรือเท็จ","Null // ประเภทข้อมูลค่าว่างเปล่าโดยเจตนา","Undefined // ประเภทข้อมูลค่าที่ยังไม่ได้กำหนด","Symbol // ประเภทข้อมูลค่าเฉพาะที่ไม่ซ้ำกัน","BigInt // ประเภทข้อมูลตัวเลขขนาดใหญ่มาก","Object // ประเภทข้อมูลกลุ่มของข้อมูลที่มีโครงสร้าง","Array // ประเภทข้อมูลรายการของข้อมูล"],"examples (ตัวอย่าง)":["var name = 'John'; // กำหนดตัวแปร name เก็บสตริง 'John'","let age = 30; // กำหนดตัวแปร age เก็บตัวเลข 30 (เปลี่ยนค่าได้)","const PI = 3.14; // กำหนดค่าคงที่ PI เป็น 3.14 (เปลี่ยนค่าไม่ได้)","let numbers = [1, 2, 3]; // กำหนดตัวแปร numbers เก็บรายการตัวเลข"]},"functions":{"declaration (การประกาศ)":["function name(params) { ... } // การประกาศฟังก์ชันแบบปกติ","() => { ... } (Arrow Function) // การประกาศฟังก์ชันแบบย่อ"],"examples (ตัวอย่าง)":["function greet(name) { return 'Hello ' + name; } // ฟังก์ชัน greet เพื่อทักทาย","const add = (a, b) => a + b; // ฟังก์ชัน add แบบย่อ (Arrow Function) เพื่อบวกเลข","function calculateArea(width, height) { // ฟังก์ชันคำนวณพื้นที่\n  return width * height;\n}","const multiply = (x, y) => x * y; // ฟังก์ชัน Arrow Function สำหรับคูณเลข","function fetchData(url) { // ฟังก์ชันสำหรับการเรียกข้อมูลจาก URL\n  return fetch(url).then(response => response.json());\n}","async function getWeatherData(city) { // ฟังก์ชัน async/await สำหรับเรียกข้อมูลสภาพอากาศ\n  const response = await fetch(`https://api.example.com/weather?q=${city}`);\n  const data = await response.json();\n  return data;\n}","function createCounter() { // ฟังก์ชันที่คืนค่าฟังก์ชัน (Closure)\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2"],"built_in (ในตัว)":["console.log() // ใช้แสดงผลข้อมูลใน Console (สำหรับนักพัฒนา)","setTimeout() // ใช้กำหนดให้โค้ดทำงานหลังจากผ่านไปกี่มิลลิวินาที","fetch() // ใช้สำหรับร้องขอข้อมูลจากเครือข่าย (เช่น โหลดข้อมูลจากเว็บไซต์อื่น)","JSON.parse() // ใช้แปลงข้อความที่เป็นรูปแบบ JSON ให้เป็น Object ใน JavaScript","Array.map() // ใช้สำหรับวนซ้ำและสร้าง Array ใหม่จาก Array เดิม"]},"syntax":{"comments (คอมเมนต์)":["// Single line // คอมเมนต์บรรทัดเดียว","/* Multi line */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if...else // ใช้เมื่อมีเงื่อนไข 'ถ้าเป็นอย่างนี้ ให้ทำแบบนี้ ไม่อย่างนั้นให้ทำอีกแบบ'","switch // ใช้เมื่อมีหลายเงื่อนไขที่ต้องตรวจสอบกับค่าเดียว"],"loops (การวนซ้ำ)":["for // วนซ้ำตามจำนวนครั้งที่กำหนด","while // วนซ้ำตราบเท่าที่เงื่อนไขเป็นจริง","do...while // คล้าย while แต่จะทำงานอย่างน้อยหนึ่งครั้งก่อนตรวจสอบเงื่อนไข","forEach // วนซ้ำสำหรับแต่ละสมาชิกใน Array","for...of // วนซ้ำสำหรับค่าของสมาชิกใน Object ที่สามารถวนซ้ำได้","for...in // วนซ้ำสำหรับชื่อ property (key) ของ Object"],"operators (ตัวดำเนินการ)":["+, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","==, === // ตัวดำเนินการเปรียบเทียบค่า: เท่ากันหรือไม่","!=, !== // ตัวดำเนินการเปรียบเทียบว่าไม่เท่ากัน","&& // AND: ทั้งสองเงื่อนไขต้องเป็นจริง","|| // OR: เงื่อนไขใดเงื่อนไขหนึ่งเป็นจริง","! // NOT: ตรงข้ามกับค่าเดิม"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlet score = 75;\nif (score >= 80) {\n  console.log('Grade A');\n} else if (score >= 60) {\n  console.log('Grade B');\n} else {\n  console.log('Grade C');\n}","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) เพื่อแสดงผลตัวเลข\nfor (let i = 0; i < 3; i++) {\n  console.log('Loop count: ' + i);\n}","// ตัวอย่างที่ 3: การใช้วงลูป (forEach) กับ Array\nconst fruits = ['apple', 'banana', 'cherry'];\nfruits.forEach(function(fruit) {\n  console.log('I like ' + fruit);\n});","// ตัวอย่างที่ 4: การใช้ Switch Statement\nlet day = 'Monday';\nswitch (day) {\n  case 'Monday':\n    console.log('Start of the week.');\n    break;\n  case 'Friday':\n    console.log('End of the week!');\n    break;\n  default:\n    console.log('Mid-week.');\n}","// ตัวอย่างที่ 5: การใช้ Operators (ตัวดำเนินการ) และ Boolean Logic\nlet a = 10;\nlet b = 5;\nlet isGreater = (a > b); // true\nlet isEqual = (a === b); // false\nlet result = isGreater && !isEqual; // true && true = true\nconsole.log('Is result true? ' + result);"]}},{"id":34,"name":"Julia","slug":"julia","logo":"img/julia.png","desc":"Julia คือภาษาโปรแกรมที่มีความเร็วสูง เหมาะสำหรับงานคำนวณทางวิทยาศาสตร์ วิเคราะห์ข้อมูล และ Machine Learning โดยเฉพาะ ถูกออกแบบมาให้มีความง่ายในการเขียนเหมือน Python แต่มีความเร็วใกล้เคียง C","by":"Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman","yr":"February 2012","level":"3","par":["Multi-paradigm","Multiple dispatch","High-performance"],"fields":["Scientific","Data","Math","HPC"],"rank":"25-30 เติบโตใน Scientific Computing (1.9% แต่กำลังเพิ่ม)","salary_range":"฿35,000-58,000 บาท/เดือน (Junior), ฿58,000-98,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ประสิทธิภาพสูงมากสำหรับการคำนวณตัวเลข","เขียนง่ายและมีไวยากรณ์คล้าย Python","สามารถเรียกใช้ไลบรารีจาก Python, R, C, Fortran ได้โดยตรง","เหมาะสำหรับงานวิจัยและพัฒนาโมเดลที่ซับซ้อน","มีระบบประเภทข้อมูล (type system) ที่แข็งแกร่งแต่ยืดหยุ่น"],"cons":["ชุมชนนักพัฒนายังไม่ใหญ่เท่า Python หรือ R","มีแพ็คเกจและไลบรารีให้เลือกใช้น้อยกว่าภาษาที่นิยมกว่า","เวลาในการคอมไพล์ครั้งแรก (Time To First Plot - TTFP) อาจช้า","ตลาดงานในไทยยังค่อนข้างเฉพาะทาง"],"frameworks":["Flux.jl (Machine Learning)","DataFrames.jl (Data Manipulation)","Plots.jl (Visualization)"],"learn":["Julia Documentation","Julia Academy","Julia for Data Science"],"variables":{"declaration (การประกาศ)":["var_name = value // วิธีการกำหนดค่าให้กับตัวแปร"],"types (ประเภท)":["Int // จำนวนเต็ม","Float64 // ทศนิยมความแม่นยำสองเท่า","Complex // จำนวนเชิงซ้อน","String // สตริง","Char // ตัวอักขระ","Bool // บูลีน (true, false)","Array // อาร์เรย์ (Vector, Matrix)","Tuple // ทูเพิล (คอลเลกชันที่ไม่สามารถเปลี่ยนแปลงได้)","Dict // ดิกชันนารี (Key-Value pairs)"],"examples (ตัวอย่าง)":["x = 10 // กำหนดตัวแปร x เก็บตัวเลข 10","name = \"Julia\" // กำหนดตัวแปร name เก็บสตริง \"Julia\"","is_ready = true // กำหนดตัวแปร is_ready เก็บค่าความจริง true","A = [1 2; 3 4] // กำหนดเมทริกซ์ 2x2","my_vector = [10, 20, 30] // กำหนด Vector","person = Dict(\"name\" => \"Alice\", \"age\" => 30) // กำหนด Dictionary"]},"functions":{"declaration (การประกาศ)":["function name(params) ... end // การประกาศฟังก์ชันแบบปกติ","name(params) = ... // การประกาศฟังก์ชันแบบ Single-line"],"examples (ตัวอย่าง)":["// ฟังก์ชัน greet เพื่อทักทาย\nfunction greet(name)\n  return \"Hello $(name)\"\nend\nprintln(greet(\"Julia User\")) # แสดงผล \"Hello Julia User\"\n","// ฟังก์ชัน add แบบย่อ เพื่อบวกเลข\nadd(a, b) = a + b\nprintln(add(5, 7)) # แสดงผล 12\n","// ฟังก์ชันที่คืนค่าหลายค่า (Tuple)\nfunction get_minmax(numbers)\n  min_val = minimum(numbers)\n  max_val = maximum(numbers)\n  return min_val, max_val\nend\nmin_v, max_v = get_minmax([1, 5, 2, 8, 3])\nprintln(\"Min: $(min_v), Max: $(max_v)\") # แสดงผล \"Min: 1, Max: 8\"\n","// Asynchronous Programming (Tasks and Channels)\n// Julia มีกลไก Concurrency ที่เรียกว่า Task ซึ่งทำงานแบบ lightweight cooperative multitasking\n// สามารถใช้ @async และ Channel สำหรับการสื่อสารระหว่าง Tasks\n/*\n# async_example.jl\nusing DelimitedFiles\n\nfunction long_computation(id)\n    println(\"Task $(id): Starting long computation...\")\n    sleep(1) # Simulate time-consuming operation\n    println(\"Task $(id): Finished long computation.\")\n    return \"Result from Task $(id)\"\nend\n\nfunction main_async()\n    println(\"Main: Starting...\")\n    \n    # Run long_computation in a separate task\n    task1 = @async long_computation(1)\n    task2 = @async long_computation(2)\n\n    println(\"Main: Continuing with other work...\")\n    \n    # Wait for tasks to complete and fetch results\n    result1 = fetch(task1)\n    result2 = fetch(task2)\n    \n    println(\"Main: Received result1: $(result1)\")\n    println(\"Main: Received result2: $(result2)\")\n    println(\"Main: All tasks completed.\")\nend\n\n# To run this, save it as a .jl file and execute in Julia REPL:\n# include(\"async_example.jl\")\n# main_async()\n*/"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console (ไม่มี Newline)","println() // ใช้แสดงผลข้อมูลออกทาง Console (พร้อม Newline)","sqrt() // คำนวณรากที่สอง","sum() // คำนวณผลรวมของ Collection","length() // หาความยาวของ Collection","minimum() // หาค่าน้อยที่สุด","maximum() // หาค่ามากที่สุด","typeof() // ตรวจสอบประเภทข้อมูล","parse() // แปลงสตริงเป็นตัวเลข/ประเภทอื่น"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","#= Multi line comment =# // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition\n  # code\nelseif another_condition\n  # code\nelse\n  # code\nend // คำสั่ง if-elseif-else"],"loops (การวนซ้ำ)":["for i = 1:10\n  # code\nend // ลูป for (สำหรับช่วงตัวเลข)","for item in collection\n  # code\nend // ลูป for (สำหรับวนซ้ำ Collection)","while condition\n  # code\nend // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, ^, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, ยกกำลัง, โมดูลัส","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","$ // String Interpolation","// // Element-wise operations (เช่น .*, ./)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nscore = 75\nif score >= 90\n  println(\"Grade A\")\nelseif score >= 70\n  println(\"Grade B\")\nelse\n  println(\"Grade C\")\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป for (นับเลข)\nfor i = 1:3\n  println(\"Loop: $(i)\")\nend\n","// ตัวอย่างที่ 3: การวนลูปผ่าน Array\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits\n  println(\"I like $(fruit)\")\nend\n","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาด (try-catch)\ntry\n  result = 10 / 0 # จะเกิด DivideError\n  println(result)\ncatch e\n  if isa(e, DivideError)\n    println(\"Error: Cannot divide by zero!\")\n  else\n    println(\"An unexpected error occurred: $(e)\")\n  end\nfinally\n  println(\"Execution completed.\")\nend\n","// ตัวอย่างที่ 5: การทำงานกับ Metaprogramming (Macros)\n# Macro สำหรับ debugging แบบง่ายๆ\nmacro debug_println(ex)\n    esc(quote\n        println(\"DEBUG: \" * $(string(ex)) * \" = \", $(ex))\n    end)\nend\n\nx = 10\ny = 20\n@debug_println(x + y) # Output: DEBUG: x + y = 30"]}},{"id":13,"name":"Kotlin","slug":"kotlin","logo":"img/kotlin.png","desc":"Kotlin เป็นภาษาโปรแกรมที่ทันสมัย, Statically typed และพัฒนาโดย JetBrains สามารถทำงานบน JVM และถูกเลือกให้เป็นภาษาหลักสำหรับการพัฒนา Android แทน Java ได้รับความนิยมอย่างรวดเร็ว","by":"JetBrains","yr":"2011","level":"3","par":["Object-Oriented","Functional","Procedural","Concurrent"],"fields":["Mobile","Backend","Script"],"rank":"18-20 Android Official Language แต่ความนิยมลดลง","salary_range":"฿38,000-60,000 บาท/เดือน (Junior), ฿60,000-105,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ใช้งานร่วมกับ Java ได้ 100% (Interoperability)","ลด boilerplate code","มี Null Safety ในตัว","รองรับ Coroutines สำหรับ Asynchronous Programming","มีเครื่องมือพัฒนา (IntelliJ IDEA) ที่ยอดเยี่ยม"],"cons":["Learning Curve อาจมีบ้างสำหรับผู้ที่มาจาก Java โดยตรง","ขนาดของแอปพลิเคชันอาจใหญ่ขึ้นเล็กน้อย (จาก Kotlin Runtime)","ทรัพยากรการเรียนรู้ยังไม่เยอะเท่า Java","ความเร็วในการคอมไพล์อาจช้ากว่า Java เล็กน้อยในโปรเจกต์ขนาดใหญ่"],"frameworks":["Spring Boot (with Kotlin)","Ktor","Jetpack Compose (Android)","Exposed"],"learn":["Kotlin Official Documentation","Kotlin Koans","Kotlin by Example","Android Developers Kotlin"],"variables":{"declaration (การประกาศ)":["val name = \"Kotlin\"; // Immutable (ค่าคงที่)","var age = 10; // Mutable (ตัวแปรที่เปลี่ยนแปลงได้)"],"types (ประเภท)":["Int // จำนวนเต็ม","Long // จำนวนเต็มขนาดใหญ่","Float // ทศนิยมความแม่นยำเดี่ยว","Double // ทศนิยมความแม่นยำคู่","Boolean // ค่าจริงหรือเท็จ (true/false)","Char // ตัวอักขระ","String // ข้อความ","Array<T> // อาร์เรย์ (เช่น Array<Int>)","List<T> // List ที่ไม่สามารถเปลี่ยนแปลงได้","MutableList<T> // List ที่สามารถเปลี่ยนแปลงได้","Set<T> // Set ที่ไม่สามารถเปลี่ยนแปลงได้ (ไม่มีค่าซ้ำ)","Map<K, V> // Map ที่ไม่สามารถเปลี่ยนแปลงได้ (Key-Value pairs)","Any // ประเภทที่ยอมรับค่าใดก็ได้ (คล้าย Object ใน Java)","Unit // ประเภทที่ไม่มีค่าคืนกลับ (คล้าย void ใน Java)"],"examples (ตัวอย่าง)":["val message = \"Hello Kotlin!\" // กำหนดค่าคงที่ message เป็นสตริง","var counter = 0 // กำหนดตัวแปร counter เป็นตัวเลข","val pi = 3.14159 // กำหนดค่าคงที่ pi เป็น Double (Type Inference)","var nullableString: String? = null // ตัวแปรที่สามารถเป็น null ได้","val numbers = listOf(1, 2, 3) // กำหนดค่าคงที่ List","var mutableList = mutableListOf(\"apple\", \"banana\") // กำหนดตัวแปร Mutable List"]},"functions":{"declaration (การประกาศ)":["fun functionName(param: Type): ReturnType { ... } // การประกาศฟังก์ชันปกติ","{ param: Type -> expression } // Lambda expression (ฟังก์ชันนิรนาม)","fun ClassName.extensionFunction() { ... } // Extension Function"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfun sum(a: Int, b: Int): Int {\n  return a + b\n}\n","// ฟังก์ชันทักทาย\nfun greet(name: String) {\n  println(\"Hello, $name!\")\n}\n","// การเรียกใช้ฟังก์ชัน\nval total = sum(2, 3) // total จะมีค่า 5\ngreet(\"Developer\") // แสดงผล 'Hello, Developer!'\n","// ฟังก์ชันที่มี Default Arguments และ Named Arguments\nfun calculateVolume(length: Int, width: Int = 1, height: Int = 1): Int {\n  return length * width * height\n}\nprintln(calculateVolume(10)) // 10\nprintln(calculateVolume(10, height = 5)) // 50 (ใช้ Named Arguments)\n","// ฟังก์ชัน Extension (เพิ่มฟังก์ชันให้คลาสที่มีอยู่แล้ว)\nfun String.addExclamation(): String {\n  return this + \"!\"\n}\nval text = \"Hello\".addExclamation() // Hello!\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\nfun operate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n  return operation(a, b)\n}\nval result = operate(5, 3) { x, y -> x * y } // Result: 15\n","// Asynchronous Programming (Coroutines)\n// Kotlin จัดการ Asynchronous ผ่าน Coroutines ซึ่งเป็น Lightweight Threads ที่มีประสิทธิภาพสูง\n// Coroutines ทำให้โค้ด Asynchronous เขียนและอ่านง่ายขึ้น โดยใช้ 'suspend' และ Builder เช่น 'launch', 'async'\n// import kotlinx.coroutines.*\n// suspend fun fetchData(): String {\n//   println(\"Fetching data...\")\n//   delay(1000) // จำลองการหน่วงเวลา 1 วินาที\n//   println(\"Data fetched!\")\n//   return \"Data fetched asynchronously\"\n// }\n// // ตัวอย่างการเรียกใช้ Coroutine (ต้องรันใน Coroutine Scope เช่น GlobalScope.launch)\n// /*\n// fun main() = runBlocking {\n//     val data = fetchData()\n//     println(\"Received: $data\")\n// }\n// */"],"built_in (ในตัว)":["println() // ใช้แสดงผลข้อมูลออกทาง Console","listOf() // ใช้สร้าง Immutable List","mutableListOf() // ใช้สร้าง Mutable List","mapOf() // ใช้สร้าง Immutable Map","mutableMapOf() // ใช้สร้าง Mutable Map","readLine() // ใช้รับข้อมูลจากผู้ใช้งาน","forEach() // เมธอดสำหรับวนซ้ำ Collection","filter() // เมธอดสำหรับกรองข้อมูลใน Collection","map() // เมธอดสำหรับแปลงข้อมูลใน Collection","apply() // Extension Function สำหรับการกำหนดค่า Object","also() // Extension Function สำหรับการทำงานเพิ่มเติมกับ Object","let() // Extension Function สำหรับ Null-Safe Call และ Scope Function"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","when (expression) { value -> /* ... */ else -> /* ... */ } // คำสั่ง when (คล้าย switch แต่ยืดหยุ่นกว่า)"],"loops (การวนซ้ำ)":["for (i in 1..5) { /* ... */ } // ลูป for-in สำหรับ Range (รวมค่าสุดท้าย)","for (i in 1 until 5) { /* ... */ } // ลูป for-in สำหรับ Range (ไม่รวมค่าสุดท้าย)","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","for (item in collection) { /* ... */ } // ลูป for-in สำหรับวนซ้ำ Collection"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %=","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Elvis: ?: // ตัวดำเนินการ Elvis (สำหรับจัดการค่า Null)","Safe Call: ?. // ตัวดำเนินการ Safe Call (สำหรับเรียกเมธอด/Property บน Optional)","Not-null asserted: !! // ตัวดำเนินการ Not-null asserted (ใช้เมื่อแน่ใจว่าไม่ใช่ Null)","Range: .. (Inclusive), until (Exclusive) // ตัวดำเนินการสำหรับช่วงตัวเลข","in // ตัวดำเนินการตรวจสอบการมีอยู่ของสมาชิกใน Collection หรือ Range"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) และ If as Expression\nval grade = 80\nval message = if (grade >= 90) {\n  \"Grade A\"\n} else if (grade >= 80) {\n  \"Grade B\"\n} else {\n  \"Grade C\"\n}\nprintln(message) // แสดงผล 'Grade B'\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) และ 'when' expression\nfor (i in 0..2) {\n  when (i) {\n    0 -> println(\"First iteration\")\n    1 -> println(\"Second iteration\")\n    else -> println(\"Other iteration\")\n  }\n}\n","// ตัวอย่างที่ 3: การใช้งาน Class และ Object-Oriented Programming (OOP)\nclass Dog(val name: String, var age: Int) { // Primary Constructor\n  fun bark() {\n    println(\"$name says Woof!\")\n  }\n}\n// สร้าง Object จากคลาส Dog\nval myDog = Dog(\"Buddy\", 3)\nmyDog.bark() // แสดงผล 'Buddy says Woof!'\nprintln(\"Dog's age: ${myDog.age}\")\nmyDog.age = 4 // เปลี่ยนแปลงค่า age เพราะเป็น var\n\ninterface Greeter { // Interface\n  fun greet(name: String)\n}\nclass EnglishGreeter : Greeter { // Implement Interface\n  override fun greet(name: String) {\n    println(\"Hello, $name!\")\n  }\n}\nval greeter: Greeter = EnglishGreeter()\ngreeter.greet(\"World\") // Hello, World!\n","// ตัวอย่างที่ 4: Null Safety (การจัดการค่า Null)\nvar name: String? = \"Alice\" // สามารถเป็น null ได้\nvar length = name?.length // Safe call: หาก name เป็น null, length จะเป็น null\nprintln(\"Length: $length\") // แสดงผล 'Length: 5'\nname = null\nlength = name?.length\nprintln(\"Length: $length\") // แสดงผล 'Length: null'\n\n// Elvis operator ( ?: ) - ให้ค่า default ถ้าเป็น null\nval actualName = name ?: \"Guest\"\nprintln(\"Actual name: $actualName\") // แสดงผล 'Actual name: Guest'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nimport java.lang.NumberFormatException\ntry {\n  val numberString = \"abc\"\n  val number = numberString.toInt() // อาจเกิด NumberFormatException\n  println(\"Parsed number: $number\")\n} catch (e: NumberFormatException) {\n  println(\"Error: Invalid number format - ${e.message}\")\n} catch (e: Exception) {\n  println(\"An unexpected error occurred: ${e.message}\")\n} finally {\n  println(\"Execution finished.\")\n}\n","// ตัวอย่างที่ 6: การทำงานกับ Collections (List, Map)\nval fruits = listOf(\"Apple\", \"Banana\", \"Cherry\") // Immutable List\nprintln(\"Fruits: $fruits\")\nval mutableFruits = mutableListOf(\"Orange\", \"Grape\") // Mutable List\nmutableFruits.add(\"Mango\")\nprintln(\"Mutable Fruits: $mutableFruits\")\n\nval userMap = mapOf(\"name\" to \"John\", \"age\" to 30) // Immutable Map\nprintln(\"User Map: $userMap\")\nval mutableUserMap = mutableMapOf(\"city\" to \"New York\") // Mutable Map\nmutableUserMap[\"zip\"] = \"10001\"\nprintln(\"Mutable User Map: $mutableUserMap\")"]}},{"id":24,"name":"Lisp","slug":"lisp","logo":"img/lisp.png","desc":"Lisp (LISt Processing) เป็นภาษาโปรแกรมที่เก่าแก่เป็นอันดับสองรองจาก Fortran มีชื่อเสียงในด้าน AI, การประมวลผลสัญลักษณ์ และ Functional Programming โดดเด่นด้วยการใช้ Parentheses จำนวนมาก","by":"John McCarthy","yr":"1958","level":"3","par":["Functional","Procedural","Object-Oriented","Metaprogramming"],"fields":["Edu","AI","Aero"],"rank":"40+ Niche ใน AI Research และ Academic","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-90,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["ทรงพลังสำหรับ AI และ Symbolic computing","มี Metaprogramming (Macros) ที่ยืดหยุ่น","Functional Programming ที่บริสุทธิ์","มีการใช้งานใน Emacs และ CAD/CAM","มีคุณสมบัติในการปรับเปลี่ยนภาษาได้เอง (Homoiconicity)"],"cons":["Syntax ใช้ Parentheses จำนวนมาก (Lisp is a lot of parentheses)","Learning Curve สูงมาก","ไม่ได้รับความนิยมในอุตสาหกรรมทั่วไป","ทรัพยากรการเรียนรู้มีจำกัด","ประสิทธิภาพอาจไม่ดีเท่าภาษาคอมไพล์"],"frameworks":["Common Lisp HyperSpec","Clojure (JVM Lisp)","Scheme"],"learn":["Structure and Interpretation of Computer Programs (SICP)","Practical Common Lisp","Common Lisp: A Gentle Introduction"],"variables":{"declaration (การประกาศ)":["(setq x 10) ; กำหนดค่า x เป็น 10 (Local Variable)","(defvar *name* \"Lisp\") ; กำหนด Global Variable ชื่อ *name*"],"types (ประเภท)":["numbers // ตัวเลข (Integer, Float, etc.)","strings // ข้อความ","booleans // ค่าตรรกะ (T = true, NIL = false)","symbols // สัญลักษณ์ (ใช้เป็นชื่อตัวแปร, ฟังก์ชัน, ฯลฯ)","lists // รายการ (โครงสร้างข้อมูลหลักใน Lisp)","vectors // เวกเตอร์ (Array แบบ Index ได้)","hash-tables // ตาราง Hash (Key-Value pairs)"],"examples (ตัวอย่าง)":["(setq count 10) ; กำหนดตัวแปร count เป็น 10","(setq greeting \"Hello Lisp\") ; กำหนดตัวแปร greeting เป็นสตริง","(setq my-list '(1 2 3)) ; สร้าง List (Quote เพื่อไม่ให้ประเมินค่า)","(setf my-array (make-array 3 :initial-contents '(10 20 30))) ; สร้าง Array/Vector\n; (aref my-array 0) ; เข้าถึงสมาชิกแรก (10)"]},"functions":{"declaration (การประกาศ)":["(defun function-name (params) body) ; การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["(defun add (a b) (+ a b)) ; ฟังก์ชันบวกเลขสองจำนวน\n","(defun greet (name) (format t \"Hello, ~a!~%\" name)) ; ฟังก์ชันทักทาย (format t คือ print)\n","// การเรียกใช้ฟังก์ชัน\n(setq sum (add 5 5)) ; sum จะมีค่า 10\n(greet \"World\") ; แสดงผล 'Hello, World!'\n","(defun multiply-by-two (num) (* num 2)) ; ฟังก์ชันคูณด้วย 2\n(mapcar #'multiply-by-two '(1 2 3)) ; ใช้ mapcar กับฟังก์ชัน (2 4 6)\n","(defun factorial (n)\n  (if (zerop n)\n      1\n      (* n (factorial (- n 1))))) ; ฟังก์ชัน Factorial แบบ Recursive\n(factorial 5) ; 120\n","// Asynchronous Programming (Conceptual - Lisp ใช้ Libraries/Extensions)\n// Lisp โดยพื้นฐานไม่ใช่ภาษาที่มี Asynchronous I/O ในตัวแบบ Modern Language\n// แต่สามารถใช้ Libraries หรือ Extensions (เช่น 'cl-async' สำหรับ Common Lisp)\n// หรือใน Clojure (Lisp บน JVM) มี core.async สำหรับ Concurrency\n/*\n; ตัวอย่างแนวคิด (ไม่ใช่โค้ดที่รันได้โดยตรง)\n(defun simulate-async-task (callback)\n  (format t \"Starting async task...~%\")\n  (sleep 1) ; จำลองการหน่วงเวลา\n  (format t \"Async task finished!~%\")\n  (funcall callback \"Data from async source\"))\n\n; (simulate-async-task (lambda (data) (format t \"Received: ~a~%\" data)))\n; (format t \"Main program continues...~%\")\n*/"],"built_in (ในตัว)":["car // คืนค่าสมาชิกแรกของ List","cdr // คืนค่า List ที่เหลือทั้งหมด ยกเว้นสมาชิกแรก","cons // สร้าง Pair หรือเพิ่ม Element เข้าไปใน List","atom // ตรวจสอบว่าเป็น Atom หรือไม่ (ไม่ใช่ List)","list // สร้าง List","quote // ป้องกันการประเมินค่าของ Expression","lambda // สร้าง Anonymous Function (ฟังก์ชันนิรนาม)","defun // กำหนดฟังก์ชัน","format // ฟังก์ชันสำหรับการแสดงผลแบบจัดรูปแบบ","print // แสดงผลข้อมูล"]},"syntax":{"comments (คอมเมนต์)":["; Single line comment ; คอมเมนต์บรรทัดเดียว","#| Multi-line\n   comment |# // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["(if condition then-form else-form) // คำสั่ง if-else","(cond (test1 expr1) (test2 expr2) (t default-expr)) // คำสั่ง cond (คล้าย If-Else If-Else หรือ Switch)"],"loops (การวนซ้ำ)":["(loop for i from 1 to 5 do (format t \"~a~%\" i)) // ลูป loop for (แบบ Loop Macro)","(dolist (item list) (format t \"~a~%\" item)) // ลูป dolist สำหรับวนซ้ำ List","(dotimes (i 5) (format t \"~a~%\" i)) // ลูป dotimes สำหรับวนซ้ำตามจำนวนครั้ง"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, rem // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, เศษเหลือ","Comparison: =, /=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not // ตัวดำเนินการตรรกะ: AND, OR, NOT"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else\n(setq age 20)\n(if (> age 18)\n    (format t \"Adult~%\")\n    (format t \"Minor~%\"))\n","// ตัวอย่างที่ 2: การใช้วงลูป Dotimes\n(dotimes (i 3)\n  (format t \"Loop Lisp: ~a~%\" i))\n","// ตัวอย่างที่ 3: การใช้ Cond (Conditional)\n(setq score 75)\n(cond\n  ((>= score 90) (format t \"Grade A~%\"))\n  ((>= score 70) (format t \"Grade B~%\"))\n  (t (format t \"Grade C~%\")))\n","// ตัวอย่างที่ 4: การทำงานกับ List และ Recursion\n(defun list-length (lst)\n  (if (null lst)\n      0\n      (+ 1 (list-length (cdr lst))))) ; ฟังก์ชันนับความยาว List แบบ Recursive\n(list-length '(a b c d)) ; 4\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Condition System)\n; Lisp มี Condition System ที่ซับซ้อนกว่า Try-Catch ทั่วไป\n; ซึ่งสามารถ Resume จาก Error ได้ (ไม่ใช่แค่ดักจับแล้วหยุด)\n; ตัวอย่างนี้แสดงการใช้ handler-case เพื่อดักจับ Error\n;\n; (handler-case\n;    (/ 10 0) ; จะเกิด division-by-zero error\n;  (division-by-zero (c) ; ดักจับ error ประเภท division-by-zero\n;    (format t \"Caught error: ~a~%\" c)\n;    nil)) ; คืนค่า nil แทน\n; (format t \"Program continues after error handling.~%\")\n","// ตัวอย่างที่ 6: การใช้ Macros (Metaprogramming)\n; Macros ใน Lisp อนุญาตให้คุณเขียนโค้ดที่สร้างโค้ดอื่นขึ้นมาได้ใน Compile Time\n; ทำให้ภาษา Lisp ยืดหยุ่นและปรับเปลี่ยนได้สูง\n; (defmacro my-unless (condition &body body)\n;   `(if (not ,condition) ,@body))\n;\n; (my-unless (= 1 2)\n;   (format t \"This will print because 1 is not equal to 2.~%\"))\n"]}},{"id":27,"name":"Lua","slug":"lua","logo":"img/lua.png","desc":"Lua เป็นภาษา Scripting ที่มีน้ำหนักเบา (lightweight), ประสิทธิภาพสูง, และมีความสามารถในการขยาย (extensible) สูง เหมาะสำหรับการฝัง (embedding) ในแอปพลิเคชันอื่น ๆ เช่น เกม และระบบฝังตัว (embedded systems) มีไวยากรณ์ที่เรียบง่ายและเรียนรู้ได้เร็ว","by":"Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes","yr":"1993","level":"2","par":["Procedural","Functional","Object-Oriented (prototype-based)"],"fields":["Game","Script","Robot","Plugin"],"rank":"25-30 ใช้ใน Game Development และ Embedded Systems","salary_range":"฿25,000-40,000 บาท/เดือน (Junior), ฿40,000-68,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["มีน้ำหนักเบาและรวดเร็ว เหมาะสำหรับการฝัง","ไวยากรณ์เรียบง่ายและเรียนรู้ง่าย","มี Table ซึ่งเป็น Data Structure ที่ยืดหยุ่นมาก","ประสิทธิภาพสูงสำหรับภาษา Scripting","เป็นที่นิยมในอุตสาหกรรมเกม (Game Scripting)"],"cons":["ระบบจัดการ Error ที่ค่อนข้างจำกัด","ชุมชนนักพัฒนาอาจเล็กกว่าภาษาหลักบางภาษา","ไม่มี Standard Library ที่ครอบคลุมเท่าภาษาอื่น","ไม่มีระบบ Type ในตัว (ก่อน Luau)","ไม่เหมาะสำหรับการพัฒนาแอปพลิเคชันขนาดใหญ่โดยลำพัง"],"frameworks":["Luvit (Web/Networking)","OpenResty (Web Platform)","Corona SDK (Game Dev)","Love2D (Game Dev)"],"learn":["Lua.org Official Manual","Programming in Lua (book)","Learn Lua in 15 Minutes","Codecademy"],"variables":{"declaration (การประกาศ)":["local myVar = 10 -- ตัวแปร Local (แนะนำให้ใช้)","globalVar = \"Hello\" -- ตัวแปร Global (ไม่แนะนำให้ใช้ถ้าไม่จำเป็น)","local name = 'Alice' -- การประกาศตัวแปรสตริง"],"types (ประเภท)":["nil // ไม่มีค่า (คล้าย null หรือ undefined)","boolean (true, false) // ค่าความจริง","number (integers, floats) // ตัวเลข (ทั้งจำนวนเต็มและทศนิยม)","string // ข้อความ","function // ฟังก์ชัน","userdata // ข้อมูลที่กำหนดโดยผู้ใช้ (สำหรับ C/C++ Interfacing)","thread // Coroutine (สำหรับ Concurrency)","table // โครงสร้างข้อมูลที่ยืดหยุ่นที่สุดใน Lua (ใช้แทน Array, Map, Object)"],"examples (ตัวอย่าง)":["local score = 100 -- กำหนดตัวแปร score เป็นตัวเลข 100","local isActive = true -- กำหนดตัวแปร isActive เป็น Boolean","local message = \"Welcome!\" -- กำหนดตัวแปร message เป็นสตริง","local myTable = {key = 'value', 1, 2, 3} -- กำหนด Table (มีทั้ง Key-Value และ Array-like)","local colors = {\"red\", \"green\", \"blue\"} -- Table ใช้เป็น Array","local user_data = {name = \"Bob\", age = 25} -- Table ใช้เป็น Object"]},"functions":{"declaration (การประกาศ)":["function funcName(param1, param2)\\n  -- code\\n  return result\\nend -- การประกาศฟังก์ชันปกติ","local anonFunc = function(x) return x * 2 end -- Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nlocal function add(a, b)\n  return a + b\nend\nprint(add(5, 3)) -- แสดงผล 8\n","// ฟังก์ชัน Recursive สำหรับ Factorial\nlocal function factorial(n)\n  if n == 0 then return 1 end\n  return n * factorial(n - 1)\nend\nprint(factorial(5)) -- แสดงผล 120\n","// ฟังก์ชันที่มี Optional Parameters และ Multiple Returns\nlocal function get_info(name, age)\n  age = age or \"Unknown\"\n  return \"Name: \" .. name, \"Age: \" .. age\nend\nlocal n, a = get_info(\"Alice\")\nprint(n, a) -- Name: Alice    Age: Unknown\nlocal n2, a2 = get_info(\"Bob\", 30)\nprint(n2, a2) -- Name: Bob    Age: 30\n","// Asynchronous Programming (Conceptual - Lua ใช้ Coroutines)\n// Lua รองรับ Coroutines ซึ่งเป็น Lightweight, Co-operative multitasking\n// ที่ช่วยในการจัดการ Asynchronous operations ได้ดี\n\n-- local co = coroutine.create(function ()\n--   print(\"Coroutine: Starting long task...\")\n--   coroutine.yield() -- หยุดการทำงานชั่วคราว\n--   print(\"Coroutine: Resumed and finished!\")\n-- end)\n\n-- print(\"Main: First run of coroutine\")\n-- coroutine.resume(co) -- เริ่ม/รัน Coroutine\n\n-- print(\"Main: Doing other work...\")\n-- -- ทำงานอื่นๆ ใน Main Thread\n\n-- print(\"Main: Resuming coroutine\")\n-- coroutine.resume(co) -- รัน Coroutine ต่อ\n"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","type() // ใช้ตรวจสอบประเภทข้อมูล","tonumber() // ใช้แปลงสตริงเป็นตัวเลข","tostring() // ใช้แปลงค่าเป็นสตริง","require() // ใช้โหลด Module/Library","ipairs() // Iterator สำหรับวนซ้ำ Array-like Table (ตามลำดับ Index)","pairs() // Iterator สำหรับวนซ้ำ Table (Key-Value และ Array-like)","table.insert() // เมธอดสำหรับเพิ่มสมาชิกใน Table","table.remove() // เมธอดสำหรับลบสมาชิกออกจาก Table","math.random() // ใช้สร้างเลขสุ่ม","io.read() // อ่านข้อมูลจาก Input/ไฟล์","io.write() // เขียนข้อมูลไปยัง Output/ไฟล์"]},"syntax":{"comments (คอมเมนต์)":["-- Single-line comment // คอมเมนต์บรรทัดเดียว","--[[ Multi-line\\n  comment --]] // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition then\\n  -- code\\nelseif anotherCondition then\\n  -- code\\nelse\\n  -- code\\nend // คำสั่ง if-elseif-else"],"loops (การวนซ้ำ)":["for i = 1, 10 do\\n  print(i)\\nend // ลูป for (นับเลข)","for i = 1, 10, 2 do\\n  print(i)\\nend -- ลูป for พร้อม Step (เช่น นับทีละ 2)","while condition do\\n  -- code\\nend // ลูป while","repeat\\n  -- code\\nuntil condition // ลูป repeat-until (ทำงานอย่างน้อยหนึ่งครั้ง)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Comparison: ==, ~=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not // ตัวดำเนินการตรรกะ: AND, OR, NOT","Concatenation: .. // ตัวดำเนินการเชื่อมสตริง","# // Length operator (สำหรับหาความยาวของ String หรือ Table)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlocal age = 20\nif age >= 18 then\n  print(\"Adult\")\nelse\n  print(\"Minor\")\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป for (นับเลข)\nfor i = 1, 3 do\n  print(\"Loop: \" .. i)\nend\n","// ตัวอย่างที่ 3: การใช้วงลูป Generic For (สำหรับ Table)\nlocal numbers = {10, 20, 30}\nfor i, v in ipairs(numbers) do -- ipairs สำหรับ Array-like tables (ตาม index)\n  print(i, v) -- แสดงผล Index และ Value\nend\n\nlocal user_info = {name = \"Charlie\", city = \"London\"}\nfor k, v in pairs(user_info) do -- pairs สำหรับทุก Key-Value ใน Table\n  print(k, v) -- แสดงผล Key และ Value\nend\n","// ตัวอย่างที่ 4: การทำงานกับ Table (Object-Oriented Programming แบบ Prototype-based)\nlocal Account = {}\nfunction Account:new(o)\n  o = o or {}\n  setmetatable(o, self)\n  self.__index = self\n  return o\nend\n\nfunction Account:withdraw(amount)\n  self.balance = self.balance - amount\nend\n\nlocal myAccount = Account:new({balance = 1000})\nmyAccount:withdraw(200)\nprint(\"Remaining balance: \" .. myAccount.balance) -- แสดงผล 'Remaining balance: 800'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย Pcall\nlocal function risky_division(a, b)\n  if b == 0 then\n    error(\"Cannot divide by zero!\")\n  end\n  return a / b\nend\n\nlocal success, result = pcall(risky_division, 10, 2) -- pcall จะคืนค่า boolean (success) และผลลัพธ์/error\nif success then\n  print(\"Result: \" .. result)\nelse\n  print(\"Error: \" .. result)\nend\n\nlocal success2, result2 = pcall(risky_division, 10, 0)\nif success2 then\n  print(\"Result: \" .. result2)\nelse\n  print(\"Error: \" .. result2)\nend"]}},{"id":28,"name":"Luau","slug":"luau","logo":"img/luau.png","desc":"Luau เป็นภาษาโปรแกรมที่พัฒนาต่อยอดมาจาก Lua โดยเพิ่มคุณสมบัติ Static Typing และประสิทธิภาพที่สูงขึ้น เน้นการใช้งานในสภาพแวดล้อมของ Roblox สำหรับการพัฒนาเกมและแอปพลิเคชันบนแพลตฟอร์มนี้ ช่วยให้นักพัฒนาสร้างโค้ดที่ปลอดภัย มีประสิทธิภาพ และดูแลรักษาง่ายขึ้น","by":"Roblox Corporation","yr":"2017","level":"3","par":["Procedural","Functional","Object-Oriented (prototype-based)","Statically-typed (Optional)"],"fields":["Game","Script","Plugin"],"rank":"เป็นภาษาหลักสำหรับการพัฒนาใน Roblox (แพลตฟอร์มเกมยอดนิยม)","salary_range":"฿30,000-50,000 บาท/เดือน (Junior), ฿50,000-80,000 บาท/เดือน (Senior) - ในอุตสาหกรรมเกม Roblox","salary":["mid","high"],"pros":["เพิ่มความปลอดภัยของโค้ดด้วย Static Typing (Optional Typing)","ประสิทธิภาพสูงกว่า Lua ดั้งเดิมในหลายกรณี","ไวยากรณ์คล้าย Lua เดิม ทำให้เรียนรู้ได้ง่ายสำหรับผู้ใช้ Lua","เครื่องมือพัฒนาใน Roblox Studio รองรับได้ดี","ลดข้อผิดพลาดในรันไทม์ (Runtime Errors) ด้วย Type Checking","มี Garbage Collection จัดการหน่วยความจำอัตโนมัติ"],"cons":["ผูกติดกับแพลตฟอร์ม Roblox เป็นหลัก","ระบบ Type ยังไม่สมบูรณ์เท่าภาษาที่มี Type System ที่แข็งแกร่งกว่า","ชุมชนนักพัฒนาอาจเล็กกว่าภาษาหลักบางภาษาภายนอก Roblox","การดีบักบางครั้งอาจซับซ้อนขึ้นเมื่อใช้ Type System"],"frameworks":["Roblox API","Roblox Luau Standard Library"],"learn":["Roblox Creator Documentation (Luau)","Luau Official Documentation","The DevKing (YouTube)","AlvinBlox (YouTube)"],"variables":{"declaration (การประกาศ)":["local myVar: number = 10 -- Local variable with type annotation","local name: string = \"Alice\" -- String variable with type annotation","globalVar = \"Hello\" -- Global variable (discouraged, no type annotation here)"],"types (ประเภท)":["nil // ไม่มีค่า (คล้าย null หรือ undefined)","boolean (true, false) // ค่าความจริง","number (integers, floats) // ตัวเลข (ทั้งจำนวนเต็มและทศนิยม)","string // ข้อความ","function // ฟังก์ชัน","userdata // ข้อมูลที่กำหนดโดยผู้ใช้","thread // Coroutine","table<K, V> // Table ที่ระบุประเภท Key และ Value (เช่น table<string, number>)","{[key: string]: any} // Generic table","any // ประเภทใดก็ได้ (ควรหลีกเลี่ยงถ้าเป็นไปได้)","unknown // ไม่ทราบประเภท (ต้องตรวจสอบก่อนใช้)","union types (e.g., number | string) // Union type (เป็นได้หลายประเภท)","enum // ประเภท Enum (ค่าคงที่ที่กำหนดชื่อ)","class // สำหรับการเขียน OOP ด้วย Class syntax (ใน Luau)"],"examples (ตัวอย่าง)":["local score: number = 100 -- กำหนดตัวแปร score เป็นตัวเลข 100","local isActive: boolean = true -- กำหนดตัวแปร isActive เป็น Boolean","local message: string = \"Welcome!\" -- กำหนดตัวแปร message เป็นสตริง","local myTable: { [string]: number } = {x = 10, y = 20} -- กำหนด Table (Map-like) ด้วย Type Annotation","local colors: {string} = {\"red\", \"green\", \"blue\"} -- Table ใช้เป็น Array ด้วย Type Annotation","local user_data: {name: string, age: number} = {name = \"Bob\", age = 25} -- Table ใช้เป็น Object ด้วย Type Annotation"]},"functions":{"declaration (การประกาศ)":["function funcName(param1: Type1, param2: Type2): ReturnType\n  -- code\n  return result\nend -- การประกาศฟังก์ชันปกติพร้อม Type Annotation","local anonFunc = function(x: number): number return x * 2 end -- Anonymous function with Type Annotation"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวนพร้อม Type Annotation\nlocal function add(a: number, b: number): number\n  return a + b\nend\nprint(add(5, 3)) -- แสดงผล 8\n","// ฟังก์ชัน Recursive สำหรับ Factorial พร้อม Type Annotation\nlocal function factorial(n: number): number\n  if n == 0 then return 1 end\n  return n * factorial(n - 1)\nend\nprint(factorial(5)) -- แสดงผล 120\n","// ฟังก์ชันที่มี Optional Parameters และ Multiple Returns พร้อม Type Annotation\nlocal function get_info(name: string, age: number?): (string, string)\n  age = age or \"Unknown\"\n  return \"Name: \" .. name, \"Age: \" .. age\nend\nlocal n, a = get_info(\"Alice\")\nprint(n, a) -- Name: Alice    Age: Unknown\nlocal n2, a2 = get_info(\"Bob\", 30)\nprint(n2, a2) -- Name: Bob    Age: 30\n","// Asynchronous Programming (Conceptual - Luau ใช้ Coroutines และ Event System ของ Roblox)\n// Luau ใน Roblox Studio รองรับ Concurrency ผ่าน Coroutines และ Events\n// ตัวอย่างนี้เป็นการสาธิตแนวคิด ไม่ได้เป็นการรันโค้ดจริงโดยตรงในสภาพแวดล้อมนี้\n\n-- local HttpService = game:GetService(\"HttpService\")\n-- local Players = game:GetService(\"Players\")\n\n-- function fetchDataAsync(url: string): (any, string?)\n--     local success, result = pcall(function()\n--         return HttpService:GetAsync(url)\n--     end)\n--     if success then\n--         return HttpService:JSONDecode(result), nil\n--     else\n--         return nil, result\n--     end\n-- end\n\n-- local function displayPlayerCount(): () -> ()\n--     coroutine.wrap(function()\n--         while true do\n--             local numPlayers = #Players:GetPlayers()\n--             print(\"Current Players: \" .. numPlayers)\n--             task.wait(5) -- รอ 5 วินาที (Luau/Roblox task.wait)\n--         end\n--     end)()\n-- end\n-- \n-- displayPlayerCount()\n"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","type() // ใช้ตรวจสอบประเภทข้อมูล (runtime type)","typeof() // ใช้ตรวจสอบประเภทข้อมูล (static type, Luau-specific)","tonumber() // ใช้แปลงสตริงเป็นตัวเลข","tostring() // ใช้แปลงค่าเป็นสตริง","require() // ใช้โหลด Module/Library","ipairs() // Iterator สำหรับวนซ้ำ Array-like Table (ตามลำดับ Index)","pairs() // Iterator สำหรับวนซ้ำ Table (Key-Value และ Array-like)","table.insert() // เมธอดสำหรับเพิ่มสมาชิกใน Table","table.remove() // เมธอดสำหรับลบสมาชิกออกจาก Table","math.random() // ใช้สร้างเลขสุ่ม","task.spawn() // (Luau/Roblox) ใช้สร้าง Coroutine/Task แบบ Asynchronous","task.wait() // (Luau/Roblox) ใช้หยุดการทำงานชั่วคราว"]},"syntax":{"comments (คอมเมนต์)":["-- Single-line comment // คอมเมนต์บรรทัดเดียว","--[[ Multi-line\n  comment --]] // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition then\n  -- code\nelseif anotherCondition then\n  -- code\nelse\n  -- code\nend // คำสั่ง if-elseif-else"],"loops (การวนซ้ำ)":["for i = 1, 10 do\n  print(i)\nend // ลูป for (นับเลข)","for i = 1, 10, 2 do\n  print(i)\nend -- ลูป for พร้อม Step (เช่น นับทีละ 2)","while condition do\n  -- code\nend // ลูป while","repeat\n  -- code\nuntil condition // ลูป repeat-until (ทำงานอย่างน้อยหนึ่งครั้ง)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Comparison: ==, ~=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not // ตัวดำเนินการตรรกะ: AND, OR, NOT","Concatenation: .. // ตัวดำเนินการเชื่อมสตริง","# // Length operator (สำหรับหาความยาวของ String หรือ Table)",":: // Type assertion (สำหรับบอก Type System ว่า Object นี้มี Type อะไร)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlocal age: number = 20\nif age >= 18 then\n  print(\"Adult\")\nelse\n  print(\"Minor\")\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป for (นับเลข)\nfor i: number = 1, 3 do\n  print(\"Loop: \" .. i)\nend\n","// ตัวอย่างที่ 3: การใช้วงลูป Generic For (สำหรับ Table)\nlocal numbers: {number} = {10, 20, 30}\nfor i, v in ipairs(numbers) do -- ipairs สำหรับ Array-like tables (ตาม index)\n  print(i, v) -- แสดงผล Index และ Value\nend\n\nlocal user_info: {name: string, city: string} = {name = \"Charlie\", city = \"London\"}\nfor k, v in pairs(user_info) do -- pairs สำหรับทุก Key-Value ใน Table\n  print(k, v) -- แสดงผล Key และ Value\nend\n","// ตัวอย่างที่ 4: การทำงานกับ Class (ใน Luau มี Class syntax)\nclass Vehicle\n  public Color: string\n  public Speed: number\n\n  constructor(color: string, speed: number)\n    self.Color = color\n    self.Speed = speed\n  end\n\n  public function Drive()\n    print(`Driving at ${self.Speed} mph with a ${self.Color} vehicle.`)\n  end\nend\n\nlocal myCar: Vehicle = Vehicle.new(\"Blue\", 60)\nmyCar:Drive() -- แสดงผล 'Driving at 60 mph with a Blue vehicle.'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย Pcall\nlocal function risky_division(a: number, b: number): (number?, string?)\n  if b == 0 then\n    error(\"Cannot divide by zero!\")\n  end\n  return a / b\nend\n\nlocal success, result = pcall(risky_division, 10, 2) -- pcall จะคืนค่า boolean (success) และผลลัพธ์/error\nif success then\n  print(\"Result: \" .. result)\nelse\n  print(\"Error: \" .. result)\nend\n\nlocal success2, result2 = pcall(risky_division, 10, 0)\nif success2 then\n  print(\"Result: \" .. result2)\nelse\n  print(\"Error: \" .. result2)\nend"]}},{"id":21,"name":"MATLAB","slug":"matlab","logo":"img/matlab.png","desc":"MATLAB เป็นภาษาและแพลตฟอร์มสำหรับการคำนวณเชิงตัวเลข (Numerical Computing) และการเขียนโปรแกรมเชิงเทคนิค มีชื่อเสียงในการวิเคราะห์ข้อมูล, พัฒนาอัลกอริทึม, สร้างโมเดล และ Simulation ทางวิศวกรรมและวิทยาศาสตร์","by":"MathWorks","yr":"1984","level":"5","par":["Array-oriented","Procedural","Object-Oriented"],"fields":["Scientific","Data","Math","Aero","HPC","Digital"],"rank":"16-20 แข็งแกร่งใน Academic และ Engineering","salary_range":"฿32,000-52,000 บาท/เดือน (Junior), ฿52,000-85,000 บาท/เดือน (Senior)","pros":["ทรงพลังสำหรับการคำนวณเชิงตัวเลขและเมทริกซ์","มี Toolbox เฉพาะทางสำหรับงานวิศวกรรม/วิทยาศาสตร์","สร้าง Plot และ Visualization ได้ง่าย","มีสภาพแวดล้อมการพัฒนา (IDE) ที่ครบวงจร","ใช้ในการวิจัยและพัฒนาในอุตสาหกรรม"],"cons":["เป็นซอฟต์แวร์เชิงพาณิชย์ (มีค่าใช้จ่าย)","ประสิทธิภาพอาจไม่เท่าภาษาคอมไพล์สำหรับงานทั่วไป","ไม่เหมาะสำหรับการพัฒนา Web Application","Learning Curve สำหรับผู้ที่ไม่มีพื้นฐานคณิตศาสตร์/วิศวกรรม"],"frameworks":["None (เป็นแพลตฟอร์ม)"],"learn":["MathWorks Official Documentation","Coursera: MATLAB Programming","MATLAB Academy","Tutorials Point MATLAB"],"variables":{"declaration (การประกาศ)":["x = 10; % Scalar (กำหนดตัวแปรเดี่ยว)","A = [1 2; 3 4]; % Matrix (กำหนดเมทริกซ์)","str = 'Hello MATLAB'; % String (กำหนดสตริง)"],"types (ประเภท)":["double // ประเภทข้อมูลทศนิยมความแม่นยำคู่ (Default)","single // ประเภทข้อมูลทศนิยมความแม่นยำเดี่ยว","int8 // จำนวนเต็ม 8 บิต","uint8 // จำนวนเต็ม 8 บิต (ไม่มีเครื่องหมาย)","logical // ค่าตรรกะ (true/false)","char // ตัวอักขระ (เก็บเป็น Array ของ ASCII values)","string // ประเภทข้อมูลสตริง (ใหม่กว่า char array)","cell // Cell Array (เก็บข้อมูลประเภทต่างกันได้)","struct // Structure (เก็บข้อมูลแบบ Key-Value pairs)","table // Table (คล้าย Data Frame ใน R/Python Pandas)","datetime // วันที่และเวลา"],"examples (ตัวอย่าง)":["my_variable = 100; % กำหนดตัวแปร my_variable เป็นตัวเลข 100","name = 'Data Scientist'; % กำหนดตัวแปร name เป็นสตริง","data_array = [1 2 3 4 5]; % สร้าง Array (Vector แถว) ของตัวเลข","is_valid = true; % กำหนดตัวแปร is_valid เป็น boolean","column_vector = [10; 20; 30]; % สร้าง Column Vector (เมทริกซ์ 3x1)","my_cell = {'text', 123, [1 2; 3 4]}; % สร้าง Cell Array","my_struct.field1 = 'value1'; my_struct.field2 = 99; % สร้าง Structure"]},"functions":{"declaration (การประกาศ)":["function [output1, output2] = func_name(input1, input2)\n  % ... (เนื้อหาฟังก์ชัน)\nend % การประกาศฟังก์ชัน (สามารถคืนค่าได้หลายค่า)"],"examples (ตัวอย่าง)":["function y = my_sum(a, b) % ฟังก์ชันบวกเลขสองจำนวน\n  y = a + b;\nend\n","function print_message(msg) % ฟังก์ชันแสดงข้อความ\n  disp(msg);\nend\n","// การเรียกใช้ฟังก์ชัน\nresult = my_sum(20, 30); % result จะมีค่า 50\nprint_message('Welcome to MATLAB!'); % แสดงผล 'Welcome to MATLAB!'\n","function [mean_val, std_dev] = calculate_stats(data) % ฟังก์ชันที่คืนค่าหลายค่า\n  mean_val = mean(data);\n  std_dev = std(data);\nend\nscores = [85 90 78 92 88];\n[avg_score, std_score] = calculate_stats(scores); % รับค่าคืนหลายค่า\ndisp(['Average Score: ', num2str(avg_score)]);\ndisp(['Standard Deviation: ', num2str(std_score)]);\n","function plot_data(x_data, y_data, plot_title) % ฟังก์ชันสำหรับการสร้างกราฟ\n  plot(x_data, y_data, '-o');\n  title(plot_title);\n  xlabel('X-axis');\n  ylabel('Y-axis');\n  grid on;\nend\n% ตัวอย่างการเรียกใช้\n% x = 1:0.5:10;\n% y = sin(x);\n% plot_data(x, y, 'Sine Wave Plot');\n","// Asynchronous Programming (Toolbox-specific)\n// MATLAB ไม่ได้มี Asynchronous Programming ในตัวแบบภาษาสมัยใหม่ (async/await)\n// แต่สามารถจัดการ Concurrency ได้ผ่าน Parallel Computing Toolbox (parfor, parfeval)\n// หรือใช้ Timer objects สำหรับงานที่ต้องหน่วงเวลา\n/*\n% ตัวอย่างการใช้ Timer object เพื่อเรียกฟังก์ชันแบบ Asynchronous\nfunction async_task_example()\n  t = timer('ExecutionMode', 'single', 'StartDelay', 1, 'TimerFcn', @myCallbackFunction);\n  start(t);\n  disp('Main program continues while timer is running...');\nend\n\nfunction myCallbackFunction(obj, event)\n  disp('Timer callback executed after delay!');\n  delete(obj); % ลบ Timer เมื่อทำงานเสร็จ\nend\n% ใน Command Window หรือ Script อื่น: async_task_example()\n*/"],"built_in (ในตัว)":["disp() // ใช้แสดงผลข้อมูลออกทาง Command Window","plot() // ใช้สร้างกราฟ 2 มิติ","sum() // ใช้คำนวณผลรวมของ Array/Vector","mean() // ใช้คำนวณค่าเฉลี่ย","sin() // คำนวณค่า Sine","cos() // คำนวณค่า Cosine","size() // คืนค่าขนาดของ Array/Matrix","zeros() // สร้าง Array/Matrix ที่มีค่าเป็นศูนย์ทั้งหมด","ones() // สร้าง Array/Matrix ที่มีค่าเป็นหนึ่งทั้งหมด","num2str() // แปลงตัวเลขเป็นสตริง","str2double() // แปลงสตริงเป็น Double","imread() // อ่านไฟล์รูปภาพ","imshow() // แสดงรูปภาพ"]},"syntax":{"comments (คอมเมนต์)":["% Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ % MATLAB ไม่รองรับ Multi-line comment แบบนี้โดยตรง\n             % ควรใช้ % ในทุกบรรทัด หรือใช้ %{ ... %} สำหรับบล็อกคอมเมนต์ (หลัง R2016b)"],"conditions (เงื่อนไข)":["if condition\n  % ... (โค้ด)\nelseif condition\n  % ... (โค้ด)\nelse\n  % ... (โค้ด)\nend // คำสั่ง if-elseif-else","switch expression\n  case value1\n    % ... (โค้ด)\n  case value2\n    % ... (โค้ด)\n  otherwise\n    % ... (โค้ด)\nend // คำสั่ง switch"],"loops (การวนซ้ำ)":["for i = 1:5\n  % ... (โค้ด)\nend // ลูป for (วนซ้ำตามช่วงตัวเลขหรือ Element ใน Array)","while condition\n  % ... (โค้ด)\nend // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, .*, ./, ^, .^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ Matrix, หาร Matrix, คูณ Element-wise, หาร Element-wise, ยกกำลัง Matrix, ยกกำลัง Element-wise","Assignment: = // ตัวดำเนินการกำหนดค่า","Comparison: ==, ~=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ~ (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่",": // Colon operator (ใช้สร้างลำดับตัวเลข หรือเข้าถึง Element ทั้งหมด)"],"examples":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\ntemp = 35;\nif temp > 30\n  disp('Hot weather');\nelseif temp < 10\n  disp('Cold weather');\nelse\n  disp('Normal weather');\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor i = 1:3\n  disp(['Loop MATLAB: ', num2str(i)]); % ใช้ num2str เพื่อแปลงตัวเลขเป็นสตริงก่อนเชื่อม\nend\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nfruit = 'apple';\nswitch fruit\n  case 'apple'\n    disp('It is an apple.');\n  case 'banana'\n    disp('It is a banana.');\n  otherwise\n    disp('Unknown fruit.');\nend\n","// ตัวอย่างที่ 4: การทำงานกับเมทริกซ์และ Vector Operations\nA = [1 2; 3 4];\nB = [5 6; 7 8];\nC_add = A + B; % การบวกเมทริกซ์\nC_multiply = A * B; % การคูณเมทริกซ์\nC_elem_multiply = A .* B; % การคูณแบบ Element-wise\n\ndisp('Matrix Addition:'); disp(C_add);\ndisp('Matrix Multiplication:'); disp(C_multiply);\ndisp('Element-wise Multiplication:'); disp(C_elem_multiply);\n\nv = [10 20 30];\nw = v * 2; % คูณทุก Element ด้วย 2\ndisp('Vector multiplied by scalar:'); disp(w);\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย try-catch\ntry\n  numerator = 10;\n  denominator = 0;\n  result = numerator / denominator; % จะเกิด DivisionByZero error\n  disp(result);\ncatch ME\n  disp(['Error occurred: ', ME.message]);\n  % disp(ME.stack); % แสดง stack trace\nfinally\n  disp('Execution completed.');\nend\n","// ตัวอย่างที่ 6: การอ่านและเขียนไฟล์ (File I/O)\n% การเขียนข้อความลงไฟล์\nfid = fopen('my_file.txt', 'w'); % เปิดไฟล์สำหรับเขียน\nfprintf(fid, 'This is a test line.\\n');\nfprintf(fid, 'Another line.\\n');\nfclose(fid);\ndisp('Text written to my_file.txt');\n\n% การอ่านข้อความจากไฟล์\nfid = fopen('my_file.txt', 'r'); % เปิดไฟล์สำหรับอ่าน\nt1 = fgetl(fid); % อ่านทีละบรรทัด\nt2 = fgetl(fid);\nfclose(fid);\ndisp(['Read line 1: ', t1]);\ndisp(['Read line 2: ', t2]);\n"]}},{"id":45,"name":"Nim","slug":"nim","logo":"img/nim.png","desc":"Nim เป็นภาษาโปรแกรม Statically-typed, Compiled ที่มุ่งเน้นประสิทธิภาพ, ความสามารถในการแสดงออก (Expressiveness), และความยืดหยุ่นในการเขียนโปรแกรม รองรับทั้ง Imperative, Object-Oriented, และ Functional Programming สามารถคอมไพล์เป็น Native Code, JavaScript หรือ C/C++ ได้ เหมาะสำหรับงาน System Programming, Web Development และ Game Development ที่ต้องการความเร็วสูง","by":"Andreas Rumpf","yr":"2008 (เปิดตัวครั้งแรก)","level":"4","par":["Imperative","Object-Oriented","Functional","Metaprogramming"],"fields":["System","Game"],"rank":"35-40 (กำลังเติบโตใน Niche Areas)","salary_range":"฿35,000-60,000 บาท/เดือน (Junior), ฿60,000-100,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["ประสิทธิภาพสูงมาก (ใกล้เคียง C/C++)","ไวยากรณ์ที่อ่านง่ายและกระชับ (คล้าย Python)","มี Garbage Collector ที่ควบคุมได้ (Reference Counting)","รองรับ Metaprogramming (Macros) ที่ทรงพลัง","สามารถคอมไพล์เป็นหลายภาษาเป้าหมาย (Native, JS, C/C++)","มี Native Concurrency ด้วย Async/Await"],"cons":["Learning Curve ที่อาจสูงสำหรับบางแนวคิด (โดยเฉพาะ Metaprogramming)","ชุมชนนักพัฒนาเล็กกว่าภาษาหลัก","ขาด Library และ Frameworks ที่หลากหลายเมื่อเทียบกับภาษาที่มีมานาน","เวลาในการคอมไพล์สำหรับโปรเจกต์ขนาดใหญ่อาจใช้เวลา","การดีบักอาจท้าทายในบางกรณี"],"frameworks":["Nimble (Package Manager)","Karax (Web Frontend)","Jester (Web Framework)","Chronos (Async IO)"],"learn":["Nim-Lang.org Official Documentation","Nim by Example","Nim Tutorial (Official)","Nim Forum"],"variables":{"declaration (การประกาศ)":["var myInt: int = 10 // ตัวแปรที่เปลี่ยนแปลงได้ (Mutable)","let myString = \"Hello Nim\" // ค่าคงที่ (Immutable, อนุมาน Type ได้)","const PI = 3.14159 // ค่าคงที่ที่กำหนดใน Compile-time"],"types (ประเภท)":["int, int8, int16, int32, int64 // จำนวนเต็ม (มีขนาดบิตต่างกัน)","uint, uint8, uint16, uint32, uint64 // จำนวนเต็มบวก (ไม่มีเครื่องหมาย)","float, float32, float64 // ทศนิยม","bool // ค่าตรรกะ (true/false)","char // ตัวอักขระ","string // ข้อความ","array[N, T] // อาร์เรย์ (ขนาดคงที่, เช่น array[5, int])","seq[T] // Sequence (คล้าย Dynamic Array/List, เช่น seq[string])","object // Object (คล้าย Structs ใน C หรือ Class ที่ไม่มีเมธอดในตัว)","ref Object // Reference to an Object (คล้าย Class ใน OOP)","enum // Enumeration Type"],"examples (ตัวอย่าง)":["var counter: int = 0 // กำหนดตัวแปร counter เป็นจำนวนเต็ม เริ่มที่ 0","let username = \"nim_user\" // กำหนดค่าคงที่ username เป็นสตริง","var isActive = true // กำหนดตัวแปร isActive เป็น Boolean","let numbers = @[1, 2, 3, 4, 5] // สร้าง Sequence ของตัวเลข","type Person = object // กำหนด Object Type\n  name: string\n  age: int\nvar john = Person(name: \"John\", age: 30) // สร้าง Instance ของ Object"]},"functions":{"declaration (การประกาศ)":["proc functionName(param1: Type): ReturnType = // การประกาศฟังก์ชัน (proc)","func functionName(param1: Type): ReturnType = // การประกาศฟังก์ชันบริสุทธิ์ (func - ไม่มี Side Effects)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nproc add(a, b: int): int =\n  result = a + b\n\n// การเรียกใช้ฟังก์ชัน: let sum = add(5, 5) # sum จะมีค่า 10\n","// ฟังก์ชันทักทาย (ใช้ echo สำหรับแสดงผล)\nproc greet(name: string) =\n  echo \"Hello, \" & name & \"!\"\n\n// การเรียกใช้ฟังก์ชัน: greet(\"Nim User\") # แสดงผล 'Hello, Nim User!'\n","// ฟังก์ชันที่มี Optional Parameters และ Named Arguments\nproc createMessage(msg: string; prefix = \"Info\": string; suffix = \"!\": string): string =\n  result = prefix & \": \" & msg & suffix\n\n// การเรียกใช้:\n// echo createMessage(\"Task complete\") # Info: Task complete!\n// echo createMessage(\"Error occurred\", prefix = \"ERROR\", suffix = \"!!!\") # ERROR: Error occurred!!!\n","// Asynchronous Programming (Async/Await - ใช้โมดูล Chronos หรือ AsyncSocket)\n// Nim รองรับ Asynchronous Programming ผ่าน Coroutines และ Syntax async/await\n// ซึ่งทำให้การเขียนโค้ดที่ต้องรอ I/O หรือการทำงานคู่ขนานทำได้ง่ายขึ้น\n\n// import asyncdispatch, os, times\n\n// proc simulateApiCall(): Future[string] = async :\n//   echo \"Fetching data...\"\n//   await sleepAsync(1000) # หน่วงเวลา 1 วินาที\n//   echo \"Data fetched!\"\n//   result = \"Data from async source\"\n\n// proc mainAsync() = async :\n//   echo \"Main program started.\"\n//   let data = await simulateApiCall()\n//   echo \"Received: \" & data\n//   echo \"Main program finished.\"\n\n// when isMainModule: # ต้องรันใน Event Loop\n//   mainAsync().waitFor\n"],"built_in (ในตัว)":["echo() // ใช้แสดงผลข้อมูลออกทาง Console","len() // ใช้หาความยาวของ String, Sequence, Array","new() // ใช้สร้าง Object บน Heap (คืนค่า Reference)","alloc() // ใช้จัดสรรหน่วยความจำ","dealloc() // ใช้คืนหน่วยความจำ","readFile() // อ่านเนื้อหาจากไฟล์","writeFile() // เขียนเนื้อหาลงไฟล์","contains() // ตรวจสอบว่า Sequence/String มีค่าที่ระบุหรือไม่","add() // เพิ่ม Element ใน Sequence"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","#[ Multi-line\n   comment ]# // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition: // คำสั่ง if\n  # code\nelif anotherCondition: // คำสั่ง elif\n  # code\nelse: // คำสั่ง else\n  # code","case expression: // คำสั่ง case (Pattern Matching)\n  of value1:\n    # code\n  of value2, value3:\n    # code\n  else:\n    # code"],"loops (การวนซ้ำ)":["for i in 0..5: // ลูป for สำหรับช่วงตัวเลข (รวมค่าสุดท้าย)","for item in mySequence: // ลูป for-in สำหรับวนซ้ำ Sequence/Array","while condition: // ลูป while\n  # code"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, div, mod, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร (ทศนิยม), หาร (จำนวนเต็ม), โมดูลัส, ยกกำลัง","Assignment: =, +=, -=, *=, /=, &=, |=, xor=, shl=, shr= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ","Logical: and, or, not // ตัวดำเนินการตรรกะ","& // Concatenation (เชื่อมสตริง)","[] // Indexing/Slicing (เข้าถึงสมาชิกใน Collection)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-elif-else)\nvar temperature = 25\nif temperature > 30:\n  echo \"Hot day\"\nelif temperature < 10:\n  echo \"Cold day\"\nelse:\n  echo \"Normal day\"\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nfor i in 0..2:\n  echo \"Loop Nim: \" & $i # $i เป็น String interpolation\n","// ตัวอย่างที่ 3: การใช้ Case Statement\nvar command = \"open\"\ncase command:\n  of \"open\":\n    echo \"Opening file...\"\n  of \"save\":\n    echo \"Saving file...\"\n  else:\n    echo \"Unknown command.\"\n","// ตัวอย่างที่ 4: การใช้งาน Object และ Method\ntype Dog = ref object # ref object หมายถึงสร้างบน Heap\n  name: string\n  age: int\n\nproc bark(d: Dog) = # เมธอดสำหรับ Dog\n  echo d.name & \" says Woof!\"\n\nvar myDog = Dog(name: \"Buddy\", age: 3) # สร้าง Object\nmyDog.bark() # แสดงผล 'Buddy says Woof!'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\nproc divide(a, b: int): float = # ใช้ float สำหรับผลลัพธ์การหาร\n  if b == 0:\n    raise newException(DivByZeroError, \"Cannot divide by zero!\")\n  result = float(a) / float(b)\n\ntry:\n  var res = divide(10, 2)\n  echo \"Result: \" & $res\n  var errRes = divide(10, 0)\n  echo \"Result: \" & $errRes\nexcept DivByZeroError as e:\n  echo \"Caught error: \" & e.msg\nexcept: # ดักจับ Exception อื่นๆ ทั้งหมด\n  echo \"An unexpected error occurred.\"\n","// ตัวอย่างที่ 6: การทำงานกับ Sequences (Dynamic Arrays) และ Iterators\nvar fruits = @[\"Apple\", \"Banana\", \"Cherry\"]\nfruits.add(\"Date\") # เพิ่มสมาชิก\necho \"Fruits: \" & $fruits\n\nfor fruit in fruits:\n  echo \"- \" & fruit\n"]}},{"id":19,"name":"Objective-C","slug":"objective-c","logo":"img/objc.png","desc":"Objective-C เป็นภาษาโปรแกรมเชิงวัตถุที่พัฒนามาจากภาษา C และเป็นภาษาหลักสำหรับการพัฒนาแอปพลิเคชันบน macOS และ iOS มายาวนานก่อน Swift จะเข้ามาแทนที่","by":"Brad Cox and Tom Love","yr":"1980s","level":"2","par":["Object-Oriented","Reflective","Imperative"],"fields":["Mobile","Desktop"],"rank":"35-40 ลดลงอย่างรวดเร็วเนื่องจาก Swift","salary_range":"฿30,000-50,000 บาท/เดือน (Junior), ฿50,000-80,000 บาท/เดือน (Senior)","pros":["เคยเป็นภาษาหลักสำหรับ Apple Ecosystem","ทำงานร่วมกับ C และ C++ ได้ดี","มี Dynamic Runtime","รองรับการเขียนโค้ดที่ยืดหยุ่น"],"cons":["Learning Curve สูงมาก","Syntax ค่อนข้างซับซ้อนและยาว","ไม่ได้รับความนิยมเท่าในอดีต (ถูกแทนที่ด้วย Swift)","การจัดการหน่วยความจำ (Manual Reference Counting) อาจเกิดข้อผิดพลาดได้ง่าย"],"frameworks":["Cocoa","Cocoa Touch"],"learn":["Apple Objective-C Documentation","Ray Wenderlich Objective-C","Stanford CS193p (legacy courses)"],"variables":{"declaration (การประกาศ)":["NSString *name = @\"John\"; // ประกาศตัวแปร NSString (Object)","int age = 30; // ประกาศตัวแปรพื้นฐาน (Primitive type)","BOOL isActive = YES; // ประกาศตัวแปร Boolean"],"types (ประเภท)":["id // Dynamic type (สามารถเก็บ Object ชนิดใดก็ได้)","Class // ประเภทข้อมูลสำหรับ Class","SEL // ประเภทข้อมูลสำหรับ Selector (ชื่อเมธอด)","IMP // ประเภทข้อมูลสำหรับ Pointer ไปยัง Method Implementation","BOOL // ประเภทข้อมูล Boolean (YES/NO)","NSInteger // ประเภทข้อมูลจำนวนเต็มที่เหมาะสมกับสถาปัตยกรรม (32-bit/64-bit)","NSUInteger // ประเภทข้อมูลจำนวนเต็มบวกที่เหมาะสมกับสถาปัตยกรรม","NSString // คลาสสำหรับจัดการข้อความ","NSArray // คลาสสำหรับจัดการ Array ของ Object","NSDictionary // คลาสสำหรับจัดการ Key-Value pairs ของ Object"],"examples (ตัวอย่าง)":["NSString *message = @\"Hello Obj-C!\"; // กำหนดตัวแปร message เป็นสตริง","NSNumber *count = @(100); // กำหนดตัวแปร count เป็น Object ตัวเลข","BOOL success = YES; // กำหนดตัวแปร success เป็น Boolean","NSArray *fruits = @[@\"Apple\", @\"Banana\", @\"Cherry\"]; // สร้าง Array ของสตริง","NSDictionary *person = @{@\"name\": @\"Alice\", @\"age\": @(25)}; // สร้าง Dictionary"]},"functions":{"declaration (การประกาศ)":["- (returnType)methodName:(param1Type)param1Name; // การประกาศ Instance Method","+ (returnType)classMethod:(paramType)paramName; // การประกาศ Class Method"],"examples (ตัวอย่าง)":["// Instance Method สำหรับบวกเลขสองจำนวน\n- (int)add:(int)a and:(int)b {\n  return a + b;\n}\n","// Instance Method สำหรับแสดงข้อความ\n- (void)printMessage:(NSString *)msg {\n  NSLog(@\"%@\", msg);\n}\n","// การเรียกใช้ Instance Method (ในคลาสเดียวกัน)\n// สมมติว่ามี instance ของคลาสอยู่ (self)\nint sum = [self add:5 and:5]; // sum จะมีค่า 10\n[self printMessage:@\"Hello, Objective-C!\"]; // แสดงผล 'Hello, Objective-C!'\n","// Class Method (เมธอดที่ไม่ต้องสร้าง Object ก่อนเรียกใช้)\n+ (NSString *)appName {\n  return @\"My Awesome App\";\n}\n// การเรียกใช้ Class Method\nNSString *app = [MyClass appName]; // ถ้าเมธอดอยู่ใน MyClass\nNSLog(@\"App Name: %@\", app);\n","// การสร้าง Object และเรียกใช้เมธอด\n#import <Foundation/Foundation.h>\n@interface MyClass : NSObject\n- (NSString *)sayHelloTo:(NSString *)personName;\n@end\n@implementation MyClass\n- (NSString *)sayHelloTo:(NSString *)personName {\n  return [NSString stringWithFormat:@\"Hello, %@!\", personName];\n}\n@end\n// ใน main function หรือเมธอดอื่น:\n// MyClass *myObject = [[MyClass alloc] init];\n// NSString *greeting = [myObject sayHelloTo:@\"World\"];\n// NSLog(@\"%@\", greeting); // Hello, World!\n","// Asynchronous Programming (Grand Central Dispatch - GCD)\n// Objective-C ใช้ Grand Central Dispatch (GCD) สำหรับการจัดการ Concurrency\n// DispatchQueue เป็นวิธีที่นิยมในการรันโค้ดแบบ Asynchronous\n// #import <Foundation/Foundation.h>\n// - (void)performAsyncTask {\n//   NSLog(@\"Start Async Task\");\n//   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n//     // โค้ดที่ทำงานใน Background thread\n//     [NSThread sleepForTimeInterval:1.0]; // จำลองการทำงานที่ใช้เวลา\n//     NSLog(@\"Async Task Done\");\n//     dispatch_async(dispatch_get_main_queue(), ^{\n//       // โค้ดที่กลับมารันบน Main thread (UI Updates)\n//       NSLog(@\"Update UI on Main Thread\");\n//     });\n//   });\n//   NSLog(@\"Main thread continues...\");\n// }"],"built_in (ในตัว)":["NSLog() // ใช้แสดงผลข้อมูลออกทาง Console (สำหรับ Objective-C)","alloc // เมธอดสำหรับจัดสรรหน่วยความจำสำหรับ Object ใหม่","init // เมธอดสำหรับเริ่มต้น Object ที่จัดสรรหน่วยความจำแล้ว","release // เมธอดสำหรับลด Reference Count (Manual Reference Counting - Deprecated)","retain // เมธอดสำหรับเพิ่ม Reference Count (Manual Reference Counting - Deprecated)","autorelease // เมธอดสำหรับจัดการหน่วยความจำแบบอัตโนมัติใน Autorelease Pool (ARC เข้ามาแทนที่)","viewDidLoad // เมธอด Lifecycle ของ ViewController (iOS)","didReceiveMemoryWarning // เมธอด Lifecycle สำหรับจัดการหน่วยความจำ (iOS)"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for แบบ C-style","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while","for (id object in collection) { /* ... */ } // Fast Enumeration (ลูป foreach สำหรับ Objective-C Collection)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ",". // Dot Syntax (ใช้เข้าถึง Property แทน Message Sending)","[] // Message Sending (รูปแบบหลักในการเรียกเมธอด)","* // Pointer Dereference (เข้าถึงค่าที่ Pointer ชี้ไป)","& // Address-of Operator (หาที่อยู่หน่วยความจำ)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nint score = 70;\nif (score >= 60) {\n  NSLog(@\"Passed\");\n} else {\n  NSLog(@\"Failed\");\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (int i = 0; i < 3; i++) {\n  NSLog(@\"Loop Obj-C: %d\", i);\n}\n","// ตัวอย่างที่ 3: การใช้ Fast Enumeration กับ NSArray\nNSArray *colors = @[@\"Red\", @\"Green\", @\"Blue\"];\nfor (NSString *color in colors) {\n  NSLog(@\"Color: %@\", color);\n}\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Properties\n#import <Foundation/Foundation.h>\n@interface Person : NSObject\n@property (nonatomic, strong) NSString *name;\n@property (nonatomic, assign) NSInteger age;\n- (void)sayHello;\n@end\n@implementation Person\n- (void)sayHello {\n  NSLog(@\"Hello, my name is %@ and I am %ld years old.\", self.name, (long)self.age);\n}\n@end\n// ใน main function หรือเมธอดอื่น:\n// Person *person1 = [[Person alloc] init];\n// person1.name = @\"John\";\n// person1.age = 30;\n// [person1 sayHello]; // Hello, my name is John and I am 30 years old.\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย NSError\n#import <Foundation/Foundation.h>\n- (BOOL)processData:(NSString *)data error:(NSError **)errorPtr {\n  if ([data isEqualToString:@\"invalid\"]) {\n    if (errorPtr) {\n      *errorPtr = [NSError errorWithDomain:@\"com.example.app\"\n                                       code:1001\n                                   userInfo:@{NSLocalizedDescriptionKey: @\"Invalid data provided.\"}];\n    }\n    return NO;\n  }\n  NSLog(@\"Processing data: %@\", data);\n  return YES;\n}\n// ใน main function หรือเมธอดอื่น:\n// NSError *error = nil;\n// BOOL success = [self processData:@\"valid_data\" error:&error];\n// if (success) { NSLog(@\"Data processed successfully.\"); } else { NSLog(@\"Error: %@\", error.localizedDescription); }\n// error = nil;\n// success = [self processData:@\"invalid\" error:&error];\n// if (success) { NSLog(@\"Data processed successfully.\"); } else { NSLog(@\"Error: %@\", error.localizedDescription); }"]}},{"id":49,"name":"OCaml","slug":"ocaml","logo":"img/ocaml.png","desc":"OCaml เป็นภาษาโปรแกรม Multi-paradigm ที่เน้น Functional Programming (โดยเฉพาะอย่างยิ่ง Static Type Inference) มีประสิทธิภาพสูงและมีความน่าเชื่อถือ พัฒนาโดย INRIA ใช้ในการวิจัย, การศึกษา, การสร้าง Compiler, ระบบการเงิน และ Web Development (ผ่าน ReScript/ReasonML)","by":"INRIA (French Institute for Research in Computer Science and Automation)","yr":"1996","level":"4","par":["Functional","Imperative","Object-Oriented"],"fields":["Compiler","Edu"],"rank":"Niche ใน Functional Programming และ Compiler Development","salary_range":"฿40,000-70,000 บาท/เดือน (Junior), ฿70,000-120,000 บาท/เดือน (Senior)","salary":["mid","high","veryhigh"],"pros":["ประสิทธิภาพสูง (ใกล้เคียง C)","Type Inference ที่ทรงพลังและ Type Safety สูง","รองรับ Functional Programming อย่างเต็มรูปแบบ","มีการจัดการ Memory อัตโนมัติ (Garbage Collection)","เหมาะสำหรับงานที่ต้องการความน่าเชื่อถือสูง","ระบบ Module ที่ดีเยี่ยม"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Functional Programming","ชุมชนนักพัฒนาเล็กและ Niche","Ecosystem และ Library ยังจำกัดกว่าภาษาหลัก","ไวยากรณ์อาจดูแปลกตา","การดีบักอาจท้าทายในโค้ดที่ซับซ้อน"],"frameworks":["Opam (Package Manager)","Coq (Proof Assistant, related)","Dune (Build System)","Dream (Web Framework)"],"learn":["OCaml.org Official Documentation","Real World OCaml (Book)","Functional Programming in OCaml (online course)","OCaml Tutorials"],"variables":{"declaration (การประกาศ)":["let x = 10;; // การประกาศค่าคงที่ (Immutable by default)","let mutable y = 20;; // การประกาศตัวแปรที่เปลี่ยนแปลงได้ (Mutable)"],"types (ประเภท)":["int // จำนวนเต็ม","float // ทศนิยม","bool // ค่าตรรกะ (true/false)","char // ตัวอักขระ","string // ข้อความ","unit // ประเภทที่ไม่มีค่า (คล้าย void ใน C/Java)","list<'a> // List ของ Type 'a' ใดๆ (Immutable)","array<'a> // Array ของ Type 'a' ใดๆ (Mutable, Fixed Size)","option<'a> // Optional type (Some(value) or None)","result<'ok, 'error> // Result type (Ok(value) or Error(error))","tuple<'a, 'b> // Tuple (กลุ่มของค่าที่มีประเภทต่างกันได้)","record // Record (คล้าย Struct/Object ที่ Immutable)","variant // Variant (Algebraic Data Types - ADT)"],"examples (ตัวอย่าง)":["// ไม่มีการแสดงตัวอย่างโค้ดตามคำขอ"]},"functions":{"declaration (การประกาศ)":["let func_name param1 param2 = (* code *) ;; // การประกาศฟังก์ชันมาตรฐาน","fun x -> x + 1 // Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ไม่มีการแสดงตัวอย่างโค้ดตามคำขอ"],"built_in (ในตัว)":["print_endline // ใช้แสดงสตริงพร้อมขึ้นบรรทัดใหม่","fst // ดึงสมาชิกตัวแรกของคู่ (Pair)","snd // ดึงสมาชิกตัวที่สองของคู่ (Pair)","List.map // ใช้แปลงทุก Element ใน List","List.filter // ใช้กรอง Element ใน List","Option.map // สำหรับแปลงค่าใน Optional หากมีค่า","string_of_int // แปลง int เป็น string","int_of_string // แปลง string เป็น int"]},"syntax":{"comments (คอมเมนต์)":["(* Multi-line comment *) // คอมเมนต์หลายบรรทัด","// Single-line comment (OCaml 4.02+ syntax) // คอมเมนต์บรรทัดเดียว (ไวยากรณ์ใหม่)"],"conditions (เงื่อนไข)":["if condition then expression1 else expression2 // คำสั่ง If-Else (เป็น Expression ที่คืนค่า)","match expression with // Pattern Matching ด้วย Match Expression\n  | Pattern1 -> result1\n  | Pattern2 -> result2\n  | _ -> defaultResult // Wildcard สำหรับค่าอื่นๆ"],"loops (การวนซ้ำ)":["for i = 1 to 10 do (* code *) done // ลูป for (สำหรับช่วงตัวเลข)","while condition do (* code *) done // ลูป while","// OCaml เน้น Functional Programming ดังนั้นมักใช้ Recursion หรือ Higher-Order Functions (map, filter, fold) สำหรับการวนซ้ำมากกว่าลูป Imperative"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, mod // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: =, <>, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), not (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่",":: // Cons operator (สำหรับเพิ่ม Element เข้าไปใน List)","@ // List concatenation (เชื่อม List)",";; // End of expression (ใช้บอกจุดสิ้นสุดของ Expression ใน Interactive mode)"],"examples (ตัวอย่าง)":["// ไม่มีการแสดงตัวอย่างโค้ดตามคำขอ"]}},{"id":55,"name":"OpenCL","slug":"opencl","logo":"img/opencl.png","desc":"OpenCL (Open Computing Language) เป็นเฟรมเวิร์กมาตรฐานแบบเปิด (Open Standard) สำหรับการเขียนโปรแกรมแบบขนาน (Parallel Programming) บนแพลตฟอร์มต่าง ๆ รวมถึง CPUs, GPUs, DSPs และ FPGAs ช่วยให้นักพัฒนาสามารถเขียนโปรแกรมที่สามารถทำงานบนฮาร์ดแวร์ที่หลากหลายได้เพื่อเร่งประสิทธิภาพการประมวลผล เหมาะสำหรับงานด้าน Scientific Computing, Image Processing, Machine Learning และ Financial Modeling","by":"Apple Inc. (original proposal to Khronos Group)","yr":"2008","level":"1","par":["Parallel Programming","Imperative","Low-level"],"fields":["HPC","Scientific","Hardware"],"rank":"เป็นมาตรฐานสำหรับ GPGPU (General-Purpose computing on Graphics Processing Units) ข้ามแพลตฟอร์ม","salary_range":"฿45,000-85,000 บาท/เดือน (Junior), ฿85,000-160,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["รองรับฮาร์ดแวร์ได้หลากหลาย (Cross-platform) ทั้ง CPU, GPU, FPGA จากผู้ผลิตต่าง ๆ","เพิ่มประสิทธิภาพการประมวลผลด้วยการใช้ Parallel Computing","เป็น Open Standard ทำให้ไม่มีข้อจำกัดด้าน Vendor Lock-in","เหมาะสำหรับงานที่ต้องการการคำนวณจำนวนมากและสามารถทำแบบขนานได้","สามารถทำงานร่วมกับภาษาโปรแกรมหลัก ๆ (C/C++, Python)"],"cons":["Learning Curve สูงมาก (ต้องเข้าใจ Parallel Programming และสถาปัตยกรรมฮาร์ดแวร์)","การจัดการ Memory และ Synchronization ซับซ้อน","การดีบักและการ Optimize โค้ดทำได้ยาก","ประสิทธิภาพอาจแตกต่างกันไปในแต่ละ Vendor/Hardware","โค้ดมีความซับซ้อนและใช้เวลานานในการพัฒนา"],"frameworks":["None (เป็น API มาตรฐาน)","Libraries/SDKs จากผู้ผลิต Hardware (Intel, AMD, NVIDIA)"],"learn":["Khronos OpenCL Website","OpenCL Programming Guide (book)","Udemy/Coursera OpenCL courses","AMD/Intel/NVIDIA Developer Resources"],"variables":{"declaration (การประกาศ)":["__kernel void kernel_name(__global int* data); // การประกาศ Kernel (ฟังก์ชันที่รันบน Device)","cl_mem buffer; // Object สำหรับ Memory Buffer บน Device","cl_program program; // Object สำหรับ OpenCL Program","cl_kernel kernel; // Object สำหรับ OpenCL Kernel"],"types (ประเภท)":["char, short, int, long // ประเภทข้อมูลจำนวนเต็ม","uchar, ushort, uint, ulong // ประเภทข้อมูลจำนวนเต็มแบบไม่มีเครื่องหมาย","float, double // ประเภทข้อมูลทศนิยม","__global // Address space qualifier สำหรับ Global Memory","__local // Address space qualifier สำหรับ Local Memory (Shared Memory ใน Work-group)","__constant // Address space qualifier สำหรับ Constant Memory","__private // Address space qualifier สำหรับ Private Memory (ใน Thread)","size_t // ประเภทข้อมูลสำหรับขนาดและ Index","cl_context // Object สำหรับ OpenCL Context","cl_command_queue // Object สำหรับ Command Queue","cl_device_id // Object สำหรับ Device ID"],"examples (ตัวอย่าง)":["// ในไฟล์ .cl (OpenCL Kernel file)\n// __kernel void add_vectors(__global float* a, __global float* b, __global float* c, int N) {\n//   int idx = get_global_id(0);\n//   if (idx < N) {\n//     c[idx] = a[idx] + b[idx];\n//   }\n// }\n//","// ใน Host Code (C/C++ file)\n// cl_context context; // OpenCL Context\n// cl_command_queue queue; // Command Queue\n// cl_program program; // OpenCL Program\n// cl_kernel kernel; // OpenCL Kernel\n// cl_mem bufferA, bufferB, bufferC; // Memory Buffers\n// cl_uint num_platforms; clGetPlatformIDs(0, NULL, &num_platforms); // การดึงข้อมูล Platform"]},"functions":{"declaration (การประมวลผลแบบขนานบน Device)":["__kernel void kernel_name(parameters) { /* ... */ } // Kernel Function (รันบน Device)","clCreateBuffer(context, flags, size, host_ptr, errcode_ret); // ฟังก์ชันสำหรับจัดสรร Memory Buffer บน Device","clEnqueueNDRangeKernel(queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, event_wait_list, event); // ฟังก์ชันสำหรับ Launch Kernel"],"examples (ตัวอย่าง)":["// การประกาศ Kernel สำหรับ Vector Addition (ในไฟล์ .cl)\n// __kernel void vector_add(__global const float* A, __global const float* B, __global float* C, int num_elements)\n// {\n//    int gid = get_global_id(0); // ได้ Global ID ของ Work-item\n//    if (gid < num_elements)\n//    {\n//        C[gid] = A[gid] + B[gid];\n//    }\n// }\n//","// การเรียกใช้ Kernel จาก Host (ในไฟล์ .c/.cpp)\n// // กำหนดขนาด Global และ Local Work-size\n// size_t global_item_size = N; // จำนวนรวมของ Work-items\n// size_t local_item_size = 256; // จำนวน Work-items ต่อ Work-group\n//\n// // Launch Kernel\n// cl_event event;\n// clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &global_item_size, &local_item_size, 0, NULL, &event);\n// clWaitForEvents(1, &event); // รอให้ Kernel ทำงานเสร็จ\n"],"built_in (ในตัว)":["get_global_id(dim) // ได้ Global ID ของ Work-item ในมิติที่ระบุ","get_local_id(dim) // ได้ Local ID ของ Work-item ภายใน Work-group","get_group_id(dim) // ได้ Group ID ของ Work-group","get_global_size(dim) // ได้ขนาดรวมของ Work-items ในมิติที่ระบุ","get_local_size(dim) // ได้ขนาดของ Work-group ในมิติที่ระบุ","barrier(flags) // Synchronize Work-items ภายใน Work-group","atomic_add() // Atomic Operation (สำหรับ Shared Memory)","async_work_group_copy() // คัดลอกข้อมูลแบบ Asynchronous ภายใน Work-group","printf() // (OpenCL 2.0+) ใช้แสดงผลใน Kernel (สำหรับ Debugging)","clamp() // จำกัดค่าให้อยู่ในช่วงที่กำหนด"],"async (Asynchronous Operations)":["clEnqueueReadBuffer() // อ่านข้อมูลจาก Device Buffer ไป Host (สามารถเป็น Blocking/Non-blocking)","clEnqueueWriteBuffer() // เขียนข้อมูลจาก Host ไป Device Buffer (สามารถเป็น Blocking/Non-blocking)","clEnqueueNDRangeKernel() // Launch Kernel (เป็น Non-blocking โดยธรรมชาติ)","clFinish() // บล็อกจนกว่า Command ทั้งหมดใน Command Queue จะเสร็จสิ้น","clWaitForEvents() // บล็อกจนกว่า Event ที่ระบุจะเสร็จสิ้น"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว (เหมือน C)","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด (เหมือน C)"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else (ใน Kernel หรือ Host Code)","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch (ใน Kernel หรือ Host Code)"],"loops (การวนซ้ำ)":["for (int i = 0; i < N; i++) { /* ... */ } // ลูป for (ใน Kernel หรือ Host Code)","while (condition) { /* ... */ } // ลูป while (ใน Kernel หรือ Host Code)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: &, |, ^, ~, <<, >> // ตัวดำเนินการบิตไวส์","// Pointers and Address-of operators used similar to C/C++"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else ใน Kernel\\n// __kernel void process_threshold(__global float* input, __global float* output, float threshold) {\\n//   int gid = get_global_id(0);\\n//   if (input[gid] > threshold) {\\n//     output[gid] = 1.0f;\\n//   } else {\\n//     output[gid] = 0.0f;\\n//   }\\n// }\\n","// ตัวอย่างที่ 2: การใช้วงลูป For ใน Kernel\\n// __kernel void sum_array(__global const int* input, __local int* temp_sum, __global int* output) {\\n//   int lid = get_local_id(0);\\n//   int gid = get_global_id(0);\\n//   int group_size = get_local_size(0);\\n//   \\n//   temp_sum[lid] = input[gid];\\n//   barrier(CLK_LOCAL_MEM_FENCE); // Synchronize within work-group\\n//   \\n//   for (int offset = group_size / 2; offset > 0; offset /= 2) {\\n//     if (lid < offset) {\\n//       temp_sum[lid] += temp_sum[lid + offset];\\n//     }\\n//     barrier(CLK_LOCAL_MEM_FENCE);\\n//   }\\n//   \\n//   if (lid == 0) {\\n//     output[get_group_id(0)] = temp_sum[0];\\n//   }\\n// }\\n","// ตัวอย่างที่ 3: การจัดการ Memory และ Context ใน Host Code\\n// cl_platform_id platform_id = NULL;\\n// cl_device_id device_id = NULL;\\n// cl_context context = NULL;\\n// cl_command_queue command_queue = NULL;\\n// cl_int ret;\\n\\n// // 1. เลือก Platform และ Device\\n// ret = clGetPlatformIDs(1, &platform_id, NULL);\\n// ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_GPU, 1, &device_id, NULL);\\n\\n// // 2. สร้าง Context\\n// context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &ret);\\n\\n// // 3. สร้าง Command Queue\\n// command_queue = clCreateCommandQueue(context, device_id, 0, &ret);\\n\\n// // 4. สร้าง Memory Buffer (ตัวอย่าง)\\n// float h_data[] = {1.0f, 2.0f, 3.0f, 4.0f};\\n// cl_mem d_data = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(h_data), h_data, &ret);\\n","// ตัวอย่างที่ 4: การโหลดและคอมไพล์ OpenCL Program (ใน Host Code)\\n// // อ่าน Kernel Source Code จากไฟล์\\n// FILE *fp;\\n// char *source_str;\\n// size_t source_size;\\n// fp = fopen(\"kernel.cl\", \"r\");\\n// if (!fp) { /* handle error */ }\\n// source_str = (char*)malloc(MAX_SOURCE_SIZE);\\n// source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);\\n// fclose(fp);\\n\\n// // สร้าง Program จาก Source Code\\n// cl_program program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &ret);\\n\\n// // คอมไพล์ Program\\n// ret = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);\\n// if (ret != CL_SUCCESS) { /* check build log for errors */ }\\n\\n// // สร้าง Kernel\\n// cl_kernel kernel = clCreateKernel(program, \"vector_add\", &ret);\\n"]}},{"id":18,"name":"Perl","slug":"perl","logo":"img/perl.png","desc":"Perl เป็นภาษาโปรแกรมที่ยืดหยุ่นและมีพลังมาก มักใช้สำหรับการจัดการข้อความ, การประมวลผลระบบ และ Web Development ได้รับฉายาว่า 'Swiss Army Chainsaw' ของภาษาโปรแกรม","by":"Larry Wall","yr":"1987","level":"3","par":["Procedural","Object-Oriented","Functional"],"fields":["Script","QA","Testing"],"rank":"30-35 ลดลงมาก แต่ยังใช้ใน Legacy Systems","salary_range":"฿28,000-45,000 บาท/เดือน (Junior), ฿45,000-75,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["มีประสิทธิภาพสูงในการจัดการข้อความและ Regex","มี CPAN (Comprehensive Perl Archive Network) ที่มี Modules จำนวนมาก","ยืดหยุ่นและเขียนโค้ดได้กระชับ","ใช้งานได้หลากหลายแพลตฟอร์ม","ทำงานร่วมกับ Command Line ได้ดี"],"cons":["Syntax อาจอ่านยากและเข้าใจยาก ('write-only language')","ไม่ได้รับความนิยมเท่าในอดีตสำหรับ Web Development","Learning Curve สูงสำหรับบางคุณสมบัติ","การบำรุงรักษาโค้ดอาจเป็นเรื่องยาก"],"frameworks":["Catalyst","Mojolicious"],"learn":["Perl.org","Perl Tutorial","Learning Perl (book)","CPAN"],"variables":{"declaration (การประกาศ)":["$scalar_var = 'hello'; // การประกาศตัวแปร Scalar","@array_var = (1, 2, 3); // การประกาศตัวแปร Array","%hash_var = ('key' => 'value'); // การประกาศตัวแปร Hash"],"types (ประเภท)":["Scalar ($) // ใช้สำหรับค่าเดี่ยว (ตัวเลข, สตริง, บูลีน)","Array (@) // ใช้สำหรับรายการของค่า (เรียงลำดับตาม Index)","Hash (%) // ใช้สำหรับ Key-Value pairs"],"examples (ตัวอย่าง)":["$name = \"Perl\"; // ตัวแปร Scalar เก็บสตริง","@numbers = (10, 20, 30); // ตัวแปร Array เก็บรายการ","%config = ('host' => 'localhost', 'port' => 8080); // ตัวแปร Hash เก็บ Key-Value","$first_number = $numbers[0]; # เข้าถึงสมาชิกแรกของ Array\nprint \"First number: $first_number\\n\"; # แสดงผล 'First number: 10'","$hostname = $config{'host'}; # เข้าถึงค่าของ Hash ด้วย Key\nprint \"Hostname: $hostname\\n\"; # แสดงผล 'Hostname: localhost'"]},"functions":{"declaration (การประกาศ)":["sub my_function { /* ... */ } // การประกาศ Subroutine (ฟังก์ชัน)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nsub add {\n  my ($a, $b) = @_;\n  return $a + $b;\n}\n","// ฟังก์ชันทักทาย\nsub greet {\n  my ($name) = @_;\n  print \"Hello, $name!\\n\";\n}\n","// การเรียกใช้ฟังก์ชัน\nmy $sum = add(5, 7); // $sum จะมีค่า 12\ngreet(\"Perl User\"); // แสดงผล 'Hello, Perl User!'\n","// ฟังก์ชันที่มี Optional Arguments\nsub get_info {\n    my ($name, $age) = @_;\n    $age = $age // 0; # กำหนดค่าเริ่มต้นเป็น 0 ถ้า $age เป็น undefined/false\n    print \"Name: $name, Age: $age\\n\";\n}\nget_info(\"Alice\"); # Name: Alice, Age: 0\nget_info(\"Bob\", 25); # Name: Bob, Age: 25\n","// Asynchronous Programming (Conceptual - ใช้ Modules)\n// Perl สามารถทำงานแบบ Asynchronous ได้โดยใช้ Modules เช่น `AnyEvent` หรือ `Mojo::IOLoop`\n// ตัวอย่างนี้แสดงแนวคิดโดยการใช้ `sleep` สำหรับการจำลองการหน่วงเวลา\n/*\nuse strict;\nuse warnings;\n\n# การจำลอง Asynchronous Task (ในสภาพแวดล้อมจริงจะใช้ Non-blocking I/O)\nsub fetch_data {\n    my ($callback) = @_;\n    print \"Fetching data...\\n\";\n    # ในสภาพแวดล้อมจริง อาจจะเป็นการอ่านจาก Network, Disk\n    sleep(1); # จำลองการหน่วงเวลา\n    print \"Data fetched!\\n\";\n    $callback->(\"Data from async source\");\n}\n\n# Call fetch_data และจัดการผลลัพธ์ผ่าน Callback\n# print \"Main program continues...\\n\";\n# fetch_data(sub { my ($data) = @_; print \"Received: $data\\n\"; });\n# print \"Main program finished...\\n\";\n*/"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","chomp() // ใช้ลบอักขระขึ้นบรรทัดใหม่จากท้ายสตริง","split() // ใช้แบ่งสตริงออกเป็นส่วนๆ โดยใช้ Delimiter","join() // ใช้รวมรายการของสตริงเข้าด้วยกัน","sort() // ใช้เรียงลำดับรายการ","open() // ใช้เปิดไฟล์","close() // ใช้ปิดไฟล์","die() // ใช้หยุดการทำงานของโปรแกรมพร้อมข้อความ Error","warn() // ใช้แสดงข้อความเตือน","scalar() // ใช้บังคับบริบท Scalar"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","=pod\nMulti-line\ncomment\n=cut // คอมเมนต์หลายบรรทัด (Pod-style documentation)"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } elsif (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-elsif-else","unless (condition) { /* ... */ } // คำสั่ง unless (ตรงข้ามกับ if)","given ($variable) { when (value) { /* ... */ } default { /* ... */ } } // คำสั่ง given-when (คล้าย switch - Perl 5.10+)"],"loops (การวนซ้ำ)":["for (my $i = 0; $i < 5; $i++) { /* ... */ } // ลูป for แบบ C-style","while (condition) { /* ... */ } // ลูป while","foreach my $item (@array) { /* ... */ } // ลูป foreach สำหรับวนซ้ำ Array/List","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison (Numeric): ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบตัวเลข: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Comparison (String): eq, ne, lt, gt, le, ge // ตัวดำเนินการเปรียบเทียบสตริง: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่",". // ตัวดำเนินการเชื่อมสตริง (Concatenation)","x // ตัวดำเนินการทำซ้ำสตริง (Replication)","=~ // ตัวดำเนินการ Match Regex","!~ // ตัวดำเนินการ Not Match Regex"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nmy $score = 60;\nif ($score >= 50) {\n  print \"Passed\\n\";\n} else {\n  print \"Failed\\n\";\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (my $i = 0; $i < 3; $i++) {\n  print \"Loop Perl: $i\\n\";\n}\n","// ตัวอย่างที่ 3: การใช้ Foreach Loop กับ Array\nmy @fruits = ('apple', 'banana', 'cherry');\nforeach my $fruit (@fruits) {\n  print \"I like $fruit\\n\";\n}\n","// ตัวอย่างที่ 4: การทำงานกับ Hash (Dictionary)\nmy %user = ('name' => 'John', 'age' => 30);\nprint \"User Name: $user{'name'}\\n\"; # เข้าถึงค่าด้วย Key\n$user{'city'} = 'New York'; # เพิ่ม Key-Value ใหม่\nprint \"User City: $user{'city'}\\n\";\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย eval\n# การใช้ eval เพื่อดักจับข้อผิดพลาด\nmy $result = eval { 10 / $divisor; };\nif ($@) { # $@ จะมีค่าเป็น Error message ถ้า eval ล้มเหลว\n  print \"Error occurred: $@\";\n} else {\n  print \"Result: $result\\n\";\n}\n","// ตัวอย่างที่ 6: การทำงานกับ Regex (Regular Expressions)\nmy $text = \"The quick brown fox\";\nif ($text =~ /fox/) { # ตรวจสอบว่ามีคำว่า 'fox' ในสตริงหรือไม่\n  print \"'fox' found!\\n\";\n}\n$text =~ s/quick/slow/; # แทนที่ 'quick' ด้วย 'slow'\nprint \"Modified text: $text\\n\"; # The slow brown fox\n"]}},{"id":10,"name":"PHP","slug":"php","logo":"img/php.png","desc":"PHP เป็นภาษา Scripting ฝั่ง Server ที่ออกแบบมาเพื่อพัฒนา Web Application โดยเฉพาะ มีความนิยมอย่างมากในการสร้างเว็บไซต์แบบ Dynamic และมีการใช้งานอย่างแพร่หลายใน CMS ยอดนิยมอย่าง WordPress","by":"Rasmus Lerdorf","yr":"1994","level":"4","par":["Procedural","Object-Oriented","Imperative","Functional"],"fields":["Backend","Testing","Script"],"rank":"13-17 ลดลงอย่างต่อเนื่อง (ตำแหน่งต่ำสุดเท่าที่เคยมี)","salary_range":"฿25,000-40,000 บาท/เดือน (Junior), ฿40,000-70,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["เรียนรู้และเริ่มต้นใช้งานง่าย","มี Frameworks และ Libraries ที่หลากหลาย","ทำงานได้ดีกับฐานข้อมูล","มีชุมชนขนาดใหญ่","รองรับ Web Hosting ได้กว้างขวาง"],"cons":["ประสิทธิภาพอาจไม่สูงเท่าบางภาษาในบางกรณี","การจัดการ Error อาจไม่ดีเท่าที่ควรในเวอร์ชันเก่าๆ","ความสอดคล้องของ Syntax อาจไม่ชัดเจนเท่าภาษาอื่น","อาจมีปัญหาเรื่องความปลอดภัยหากไม่ระมัดระวัง"],"frameworks":["Laravel","Symfony","CodeIgniter","Zend Framework","WordPress"],"learn":["PHP.net Official Manual","Laracasts","W3Schools PHP Tutorial","Traversy Media PHP"],"variables":{"declaration (การประกาศ)":["$name = \"John\"; // การประกาศตัวแปรสตริง","$age = 30; // การประกาศตัวแปรจำนวนเต็ม"],"types (ประเภท)":["Integer // ประเภทข้อมูลตัวเลขจำนวนเต็ม","Float // ประเภทข้อมูลตัวเลขทศนิยม","String // ประเภทข้อมูลข้อความ","Boolean // ประเภทข้อมูลค่าจริงหรือเท็จ (true/false)","Array // ประเภทข้อมูลสำหรับเก็บข้อมูลหลายค่าในตัวแปรเดียว","Object // ประเภทข้อมูลสำหรับ Instance ของ Class","NULL // ประเภทข้อมูลสำหรับค่าว่างเปล่าโดยเจตนา","Resource // ประเภทข้อมูลสำหรับ Resource ภายนอก (เช่น การเชื่อมต่อฐานข้อมูล)"],"examples (ตัวอย่าง)":["$product = \"Laptop\"; // กำหนดตัวแปร product เก็บสตริง","$quantity = 10; // กำหนดตัวแปร quantity เก็บตัวเลข","$is_available = true; // กำหนดตัวแปร is_available เก็บค่าความจริง","$prices = [100, 200, 300]; // กำหนดตัวแปร prices เก็บ Array","$user = (object)['name' => 'Alice', 'age' => 30]; // กำหนดตัวแปร user เก็บ Object","$colors = array('red', 'green', 'blue'); // การประกาศ Array แบบเก่า"]},"functions":{"declaration (การประกาศ)":["function functionName($param1, $param2) { /* ... */ } // การประกาศฟังก์ชันทั่วไป","function ($param) use ($variable) { /* ... */ }; // Anonymous function (Closure)"],"examples (ตัวอย่าง)":["// ฟังก์ชันทักทาย\nfunction greet($name) {\n  return \"Hello, \" . $name . \"!\";\n}\n","// ฟังก์ชันบวกเลขสองจำนวน\nfunction add($a, $b) {\n  return $a + $b;\n}\n","// การเรียกใช้ฟังก์ชัน\n$message = greet(\"PHP\"); // $message จะมีค่า 'Hello, PHP!'\n$sum = add(10, 15); // $sum จะมีค่า 25\n","// ฟังก์ชันที่มี Optional Parameter และ Default Value\nfunction calculate_price($base_price, $tax_rate = 0.07) {\n  return $base_price * (1 + $tax_rate);\n}\n$final_price1 = calculate_price(100); // ใช้ tax_rate ค่าเริ่มต้น (107)\n$final_price2 = calculate_price(100, 0.10); // ใช้ tax_rate ที่กำหนด (110)\n","// ฟังก์ชันที่คืนค่าหลายค่า (ด้วย Array)\nfunction get_user_info() {\n  return ['John Doe', 30];\n}\nlist($name, $age) = get_user_info(); // รับค่าที่คืนกลับมา\n// หรือ: [$name, $age] = get_user_info(); (PHP 7.1+)\n","// Asynchronous Programming ใน PHP (แนวคิด)\n// PHP ไม่ได้มี Asynchronous I/O ในตัวเหมือน Node.js หรือ Go\n// แต่สามารถทำได้ผ่าน Extensions เช่น ReactPHP หรือ Swoole\n// ตัวอย่างนี้เป็นการจำลองการทำงานที่ใช้เวลาโดยไม่บล็อกการทำงาน (ใน PHP 8.1+ มี Fibers)\n/*\nfunction simulate_async_task() {\n    echo \"Start long task...\\n\";\n    sleep(2); // จำลองการทำงานที่ใช้เวลา\n    echo \"Long task finished!\\n\";\n}\n// ใน PHP ที่ไม่มี Extension async โดยตรง จะต้องรันแบบ Synchronous\n// หรือใช้ Library อย่าง ReactPHP/Swoole\n*/"],"built_in (ในตัว)":["echo() // ใช้แสดงผลข้อมูลออกทาง Browser/Console","print() // ใช้แสดงผลข้อมูลออกทาง Browser/Console (คืนค่า 1 เสมอ)","strlen() // ใช้หาความยาวของสตริง","str_replace() // ใช้แทนที่ส่วนหนึ่งของสตริง","array_push() // ใช้เพิ่มสมาชิกใน Array","isset() // ใช้ตรวจสอบว่าตัวแปรถูกกำหนดค่าและไม่ใช่ NULL","empty() // ใช้ตรวจสอบว่าตัวแปรว่างเปล่าหรือไม่","var_dump() // ใช้แสดงข้อมูลโครงสร้างของตัวแปรเพื่อ Debug","json_encode() // ใช้แปลงข้อมูล PHP เป็น JSON string"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","# Another single line comment // คอมเมนต์บรรทัดเดียวอีกรูปแบบ","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } elseif (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-elseif-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","foreach ($array as $item) { /* ... */ } // ลูป foreach สำหรับวนซ้ำ Array (ค่าเท่านั้น)","foreach ($array as $key => $value) { /* ... */ } // ลูป foreach สำหรับวนซ้ำ Array (Key และ Value)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, ===, !=, !==, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ (หลวม/เข้มงวด), ไม่เท่ากับ (หลวม/เข้มงวด) ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Concatenation: . // ตัวดำเนินการเชื่อมสตริง","Ternary: ? : // ตัวดำเนินการเงื่อนไขแบบย่อ (Conditional Operator)","Null Coalescing: ?? // ตัวดำเนินการค่า Null (PHP 7+)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\n<?php\n$age = 20;\nif ($age >= 18) {\n  echo \"Adult\";\n} else {\n  echo \"Minor\";\n}\n?>\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\n<?php\nfor ($i = 0; $i < 3; $i++) {\n  echo \"Loop PHP: \" . $i . \"\\n\";\n}\n?>\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\n<?php\n$day = \"Wednesday\";\nswitch ($day) {\n  case \"Monday\":\n    echo \"Start of week\";\n    break;\n  case \"Friday\":\n    echo \"End of week\";\n    break;\n  default:\n    echo \"Mid-week\";\n}\n?>\n","// ตัวอย่างที่ 4: การใช้งานคลาสและ Object-Oriented Programming (OOP)\n<?php\nclass Dog {\n  public $name;\n  public $age;\n\n  public function __construct($name, $age) {\n    $this->name = $name;\n    $this->age = $age;\n  }\n\n  public function bark() {\n    echo $this->name . \" says Woof!\\n\";\n  }\n}\n// สร้าง Object จากคลาส Dog\n$myDog = new Dog(\"Buddy\", 3);\n$myDog->bark(); // แสดงผล \"Buddy says Woof!\"\n?>\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย Try-Catch\n<?php\ntry {\n  $num1 = 10;\n  $num2 = 0;\n  if ($num2 === 0) {\n    throw new Exception(\"Cannot divide by zero\");\n  }\n  $result = $num1 / $num2;\n  echo \"Result: \" . $result . \"\\n\";\n} catch (Exception $e) {\n  echo \"Caught an error: \" . $e->getMessage() . \"\\n\";\n} finally {\n  echo \"Operation finished.\\n\";\n}\n?>\n","// ตัวอย่างที่ 6: การทำงานกับ Array และ Foreach Loop\n<?php\n$fruits = ['Apple', 'Banana', 'Cherry'];\necho \"My favorite fruits:\\n\";\nforeach ($fruits as $fruit) {\n  echo \"- \" . $fruit . \"\\n\";\n}\n// หรือใช้ Key และ Value\n$student_grades = ['Alice' => 'A', 'Bob' => 'B'];\nforeach ($student_grades as $name => $grade) {\n  echo \"{$name} got a grade of {$grade}\\n\";\n}\n?>\n"]}},{"id":39,"name":"PL/SQL","slug":"plsql","logo":"img/oracle.png","desc":"PL/SQL เป็นภาษา Extension ที่เพิ่มความสามารถเชิงโครงสร้าง (Procedural) ให้กับ SQL ในฐานข้อมูล Oracle Database ใช้สำหรับเขียน Stored Procedures, Functions, Packages และ Triggers เพื่อจัดการและประมวลผลข้อมูลที่ซับซ้อนภายในฐานข้อมูลโดยตรง","by":"Oracle Corporation","yr":"1980s","level":"5","par":["Procedural","Declarative (SQL embedded)"],"fields":["DB"],"rank":"35+ แข็งแกร่งใน Oracle Database Ecosystem","salary_range":"฿28,000-45,000 บาท/เดือน (Junior), ฿45,000-78,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ประสิทธิภาพสูงในการประมวลผลข้อมูลใน Database Server","ลด Traffic ระหว่าง Client กับ Server","ช่วยให้การจัดการ Transaction ซับซ้อนทำได้ง่ายขึ้น","เป็นภาษาที่สำคัญสำหรับ Oracle Ecosystem"],"cons":["เฉพาะสำหรับ Oracle Database","การดีบักและจัดการ Version Control อาจทำได้ยาก","Learning Curve สำหรับผู้เริ่มต้น SQL","ไม่เหมาะกับงานนอก Database"],"frameworks":[],"learn":["Oracle PL/SQL Documentation","Oracle Academy"],"variables":{"declaration (การประกาศ)":["variable_name datatype; // รูปแบบการประกาศตัวแปร"],"types (ประเภท)":["VARCHAR2 // สตริงความยาวแปรผัน (สำหรับข้อความ)","NUMBER // ตัวเลข (ทั้งจำนวนเต็มและทศนิยม)","DATE // วันที่และเวลา","BOOLEAN // ค่าจริงหรือเท็จ (TRUE/FALSE)","RECORD // โครงสร้างข้อมูลที่กำหนดเอง (คล้าย Struct)","TABLE // โครงสร้างข้อมูลแบบ Array (ใช้กับ Type ที่กำหนดเอง)"],"examples (ตัวอย่าง)":["DECLARE\n  v_employee_name VARCHAR2(100); // ประกาศตัวแปรสตริง\n  v_salary NUMBER(10, 2) := 50000.00; // ประกาศตัวแปรตัวเลขพร้อมค่าเริ่มต้น\n  v_hire_date DATE := SYSDATE; // ประกาศตัวแปรวันที่\nBEGIN\n  -- เลือกข้อมูลชื่อพนักงานจากตาราง employees ที่มี id = 1 ไปยังตัวแปร v_employee_name\n  SELECT name INTO v_employee_name FROM employees WHERE id = 1;\n  -- แสดงผลค่าของตัวแปร\n  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_name);\n  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);\nEND;\n/"]},"functions":{"declaration (การประกาศ)":["FUNCTION function_name (params) RETURN datatype IS ... END; // รูปแบบการประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["CREATE OR REPLACE FUNCTION get_employee_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM employees;\n  RETURN v_count;\nEND;\n/\n","CREATE OR REPLACE FUNCTION calculate_bonus (p_salary NUMBER, p_performance_rating NUMBER) RETURN NUMBER IS\n  v_bonus NUMBER;\nBEGIN\n  v_bonus := p_salary * (p_performance_rating / 100);\n  RETURN v_bonus;\nEND;\n/\n","// การเรียกใช้ฟังก์ชัน\nDECLARE\n  emp_count NUMBER;\n  bonus_amount NUMBER;\nBEGIN\n  emp_count := get_employee_count(); // เรียกใช้ฟังก์ชัน get_employee_count\n  DBMS_OUTPUT.PUT_LINE('Total Employees: ' || emp_count);\n\n  bonus_amount := calculate_bonus(60000, 10); -- เรียกใช้ฟังก์ชัน calculate_bonus\n  DBMS_OUTPUT.PUT_LINE('Calculated Bonus: ' || bonus_amount);\nEND;\n/"],"built_in (ในตัว)":["DBMS_OUTPUT.PUT_LINE // ใช้แสดงผลข้อมูลออกทาง Console (ใน SQL Developer/SQL*Plus)","TO_DATE // ใช้แปลงสตริงเป็นวันที่","TO_CHAR // ใช้แปลงข้อมูลเป็นสตริง","TRUNC // ตัดทศนิยมหรือส่วนของวันที่","ROUND // ปัดเศษตัวเลข","SYSDATE // วันที่และเวลาปัจจุบันของระบบ","LENGTH // หาความยาวของสตริง","SUBSTR // ดึงสตริงย่อย"],"async (แนวคิด)":["// PL/SQL เป็นภาษาที่ทำงานบน Database Server และโดยธรรมชาติเป็น Synchronous\n-- การทำงานแบบ Asynchronous มักจะทำผ่านเทคนิคเช่น DBMS_SCHEDULER (สำหรับ Background Jobs)\n-- หรือ DBMS_AQ (Advanced Queuing) สำหรับการส่งข้อความระหว่าง Session/Application\n-- ไม่ได้มีโครงสร้าง async/await เหมือนภาษาสมัยใหม่"]},"syntax":{"comments (คอมเมนต์)":["-- Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi line */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["IF condition THEN ... ELSIF condition THEN ... ELSE ... END IF; // คำสั่ง IF-ELSIF-ELSE"],"loops (การวนซ้ำ)":["LOOP ... EXIT WHEN condition ... END LOOP; // ลูปพื้นฐานพร้อมเงื่อนไขออก","FOR variable IN start_val..end_val LOOP ... END LOOP; // ลูป FOR สำหรับช่วงตัวเลข","WHILE condition LOOP ... END LOOP; // ลูป WHILE"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, ยกกำลัง","Comparison: =, <>, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: AND, OR, NOT // ตัวดำเนินการตรรกะ: AND, OR, NOT","Concatenation: || // ตัวดำเนินการเชื่อมสตริง"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (IF-ELSIF-ELSE)\nDECLARE\n  v_salary NUMBER := 70000;\nBEGIN\n  IF v_salary > 60000 THEN\n    DBMS_OUTPUT.PUT_LINE('High Salary');\n  ELSIF v_salary >= 40000 THEN\n    DBMS_OUTPUT.PUT_LINE('Medium Salary');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('Low Salary');\n  END IF;\nEND;\n/\n","// ตัวอย่างที่ 2: การใช้วงลูป FOR\nBEGIN\n  FOR i IN 1..5 LOOP\n    DBMS_OUTPUT.PUT_LINE('Loop Count: ' || i);\n  END LOOP;\nEND;\n/\n","// ตัวอย่างที่ 3: การใช้ LOOP ... EXIT WHEN\nDECLARE\n  v_counter NUMBER := 0;\nBEGIN\n  LOOP\n    v_counter := v_counter + 1;\n    DBMS_OUTPUT.PUT_LINE('Current Counter: ' || v_counter);\n    EXIT WHEN v_counter >= 3;\n  END LOOP;\nEND;\n/\n","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาด (Exception Handling)\nDECLARE\n  v_result NUMBER;\n  v_divisor NUMBER := 0;\nBEGIN\n  v_result := 10 / v_divisor; -- จะเกิด ZERO_DIVIDE Exception\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEXCEPTION\n  WHEN ZERO_DIVIDE THEN\n    DBMS_OUTPUT.PUT_LINE('Error: Cannot divide by zero!');\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);\nEND;\n/\n","// ตัวอย่างที่ 5: การใช้งาน Cursor สำหรับวนซ้ำข้อมูลในตาราง\nDECLARE\n  CURSOR c_employees IS SELECT employee_id, name, salary FROM employees WHERE department_id = 10;\n  v_emp_id   employees.employee_id%TYPE;\n  v_emp_name employees.name%TYPE;\n  v_emp_salary employees.salary%TYPE;\nBEGIN\n  OPEN c_employees;\n  LOOP\n    FETCH c_employees INTO v_emp_id, v_emp_name, v_emp_salary;\n    EXIT WHEN c_employees%NOTFOUND;\n    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ', Name: ' || v_emp_name || ', Salary: ' || v_emp_salary);\n  END LOOP;\n  CLOSE c_employees;\nEND;\n/"]}},{"id":42,"name":"Pony","slug":"pony","logo":"img/pony.jpg","desc":"Pony เป็นภาษาโปรแกรมที่เน้น Concurrency แบบ Actor-model และความปลอดภัยของหน่วยความจำโดยไม่มี Deadlock หรือ Data Race ออกแบบมาสำหรับระบบที่มีประสิทธิภาพสูงและมีความน่าเชื่อถือสูง","by":"Wallaroo Labs","yr":"2015","level":"4","par":["Actor-Oriented","Object-Oriented","Functional","Concurrent"],"fields":["System","Compiler"],"rank":"Niche ในตลาดเฉพาะทาง (ยังไม่เป็นที่นิยมในวงกว้าง)","salary_range":"฿40,000-70,000 บาท/เดือน (Junior), ฿70,000-120,000 บาท/เดือน (Senior)","salary":["mid","high","veryhigh"],"pros":["ปลอดภัยจาก Data Race และ Deadlock โดยธรรมชาติ (Actor Model)","ประสิทธิภาพสูงมาก","มี Type System ที่แข็งแกร่ง","Garbage Collection ที่มี Latency ต่ำ","ไม่มี Null Pointer Exceptions"],"cons":["Learning Curve สูงมาก (แนวคิด Actor Model, Type System ที่เข้มงวด)","ชุมชนนักพัฒนาเล็ก","ไม่เหมาะสำหรับงาน General-purpose programming","ขาด Library และ Frameworks ที่หลากหลาย","เครื่องมือพัฒนาอาจไม่สมบูรณ์เท่าภาษาอื่น"],"frameworks":[],"learn":["Pony Official Website","Pony Tutorial","The Pony Book"],"variables":{"declaration (การประกาศ)":["let x: U64 = 10 // ตัวแปร Immutable (ค่าไม่สามารถเปลี่ยนแปลงได้)","var y: U64 = 20 // ตัวแปร Mutable (ค่าสามารถเปลี่ยนแปลงได้)"],"types (ประเภท)":["U8, U16, U32, U64, U128 // จำนวนเต็มบวก (Unsigned Integers)","I8, I16, I32, I64, I128 // จำนวนเต็ม (Signed Integers)","F32, F64 // ทศนิยม (Floating-point)","Bool // บูลีน (true/false)","String // ข้อความ","Array[T] // อาร์เรย์ (เช่น Array[U64])","Map[K, V] // Map (Key-Value pairs)","Tuple // Tuple (กลุ่มของค่าที่มีประเภทต่างกันได้)","Object (Capabilities) // วัตถุ (Pony ใช้ Capability-based security)"],"examples (ตัวอย่าง)":["let name: String = \"Pony Lang\" // กำหนดตัวแปร name เป็นสตริง","var counter: U64 = 0 // กำหนดตัวแปร counter เป็นตัวเลขเริ่มต้น 0","let primes: Array[U64] = [2; 3; 5; 7] // สร้าง Array ของตัวเลขจำนวนเต็มบวก","let user_data: Map[String, String] = Map[String, String].from([(\"name\", \"Alice\"), (\"city\", \"Wonderland\")]) // สร้าง Map ของสตริง"]},"functions":{"declaration (การประกาศ)":["fun method_name(param: Type): ReturnType => ... // การประกาศฟังก์ชัน/เมธอด"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfun add(a: U64, b: U64): U64 => a + b\n","// ฟังก์ชันส่งข้อความไปหา Actor อื่น (ตัวอย่างใน Actor Context)\nactor Main\n  new create(env: Env) =>\n    env.out.print(\"Hello, Pony!\")\n","// การเรียกใช้ฟังก์ชัน (ต้องอยู่ใน context ของ Actor หรือ Main)\n// let sum_result = add(10, 20) // sum_result จะมีค่า 30\n// env.out.print(sum_result.string()) // แสดงผล '30'\n","// Asynchronous Programming (ผ่าน Actor Model)\n// Pony จัดการ Concurrency ผ่าน Actor Model โดย Actor สื่อสารกันผ่าน Asynchronous Message Passing\nactor Logger\n  new create(env: Env) =>\n    None\n  be log(message: String) => // 'be' หมายถึง Behavior (Asynchronous Method)\n    env.out.print(message)\n\nactor Main\n  new create(env: Env) =>\n    let logger = Logger.create(env) // สร้าง instance ของ Logger actor\n    logger.log(\"This is an async log message\") // ส่ง message แบบ async\n    env.out.print(\"Main actor continues...\")\n"],"built_in (ในตัว)":["print (method on OutStream) // ใช้แสดงผลข้อมูลออกทาง Console (เป็นเมธอดของ Object Env.out)","string (method on many types for conversion) // เมธอดสำหรับแปลงข้อมูลเป็น String","Array.push // เมธอดสำหรับเพิ่มสมาชิกใน Array","Map.insert // เมธอดสำหรับเพิ่ม Key-Value pair ใน Map"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition then ... else ... end // คำสั่ง if-else","match expression then ... end // คำสั่ง match (Pattern Matching)"],"loops (การวนซ้ำ)":["for item in collection do ... end // ลูป for สำหรับวนซ้ำ Collection","while condition do ... end // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and, or, not // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่ (เป็น keyword)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlet x: U64 = 15\nif x > 10 then\n  env.out.print(\"x is greater than 10\")\nelse\n  env.out.print(\"x is 10 or less\")\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nfor i in U64(1) until U64(4) do // ลูป i ตั้งแต่ 1 ถึง 3 (ไม่รวม 4)\n  env.out.print(\"Loop Pony: \" + i.string())\nend\n","// ตัวอย่างที่ 3: การใช้ Match Expression (Pattern Matching)\n// Match expression ใช้สำหรับตรวจสอบรูปแบบของข้อมูลและดำเนินการตามรูปแบบนั้นๆ\nlet value: (U64 | String) = \"hello\" // ตัวแปรที่มี Type เป็น Union (อาจเป็น U64 หรือ String)\nmatch value\nwhen _x: U64 then env.out.print(\"It's a number: \" + _x.string())\nwhen _s: String then env.out.print(\"It's a string: \" + _s)\nend\n","// ตัวอย่างที่ 4: การใช้งาน Actor (Concurrency)\n// Pony ใช้ Actor Model ในการจัดการ Concurrency ซึ่งแต่ละ Actor ทำงานอิสระและสื่อสารกันผ่าน Message Passing\nactor MyActor\n  new create(env: Env) => // Constructor สำหรับ MyActor\n    env.out.print(\"MyActor created\")\n\n  be receive_message(msg: String) => // Behavior (Asynchronous method) ของ MyActor\n    env.out.print(\"MyActor received: \" + msg)\n\nactor Main\n  new create(env: Env) => // Constructor สำหรับ Main Actor\n    let my_actor = MyActor.create(env) // สร้าง instance ของ MyActor\n    my_actor.receive_message(\"Hello from Main!\") // ส่ง message ไปยัง MyActor แบบ Asynchronous\n    env.out.print(\"Main actor finished sending message\")\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling - Result types)\n// Pony ใช้แนวคิดของ Result types (Union types) แทนการใช้ Exceptions เพื่อจัดการข้อผิดพลาด\n// ซึ่งทำให้การจัดการข้อผิดพลาดชัดเจนและปลอดภัยยิ่งขึ้น\n// fun safe_divide(a: U64, b: U64): (U64 | None) => // ฟังก์ชันที่อาจคืน U64 หรือ None\n//   if b == 0 then\n//     None // คืนค่า None ถ้าหารด้วยศูนย์\n//   else\n//     a / b\n//   end\n//\n// actor Main\n//   new create(env: Env) =>\n//     match safe_divide(10, 2)\n//     when let result: U64 => env.out.print(\"Result: \" + result.string()) // ถ้าสำเร็จ ได้ค่า U64\n//     when None => env.out.print(\"Cannot divide by zero\") // ถ้าเป็น None\n//     end\n//\n//     match safe_divide(10, 0)\n//     when let result: U64 => env.out.print(\"Result: \" + result.string())\n//     when None => env.out.print(\"Cannot divide by zero\")\n//     end\n"]}},{"id":37,"name":"PowerShell","slug":"powershell","logo":"img/powershell.png","desc":"PowerShell เป็น Command-line Shell และ Scripting Language ของ Microsoft ที่พัฒนาขึ้นมาเพื่อการจัดการระบบ Windows และ Cloud (Azure) มีความสามารถในการจัดการวัตถุ (Objects) ทำให้มีพลังมากกว่า Command Prompt เดิม และเป็นส่วนสำคัญในงาน DevOps และ Automation บนแพลตฟอร์ม Microsoft","by":"Microsoft (Jeffrey Snover)","yr":"2006","level":"2","par":["Object-Oriented","Imperative","Procedural","Scripting"],"fields":["Script","Admin","Cloud"],"rank":"30+ แข็งแกร่งใน Windows Ecosystem","salary_range":"฿26,000-42,000 บาท/เดือน (Junior), ฿42,000-72,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ทรงพลังในการจัดการระบบ Windows และ Azure","ทำงานกับ Objects ได้ ทำให้จัดการข้อมูลได้มีประสิทธิภาพ","มี Module และ Cmdlet (Command-let) จำนวนมาก","รองรับการทำงานแบบ Cross-platform (Core)"],"cons":["ไวยากรณ์อาจแตกต่างจากภาษา Scripting อื่นๆ","การเริ่มต้นเรียนรู้อาจมี Learning Curve","ประสิทธิภาพไม่สูงเท่าภาษา Compiled","เน้นไปที่ Ecosystem ของ Microsoft เป็นหลัก"],"frameworks":[],"learn":["PowerShell Documentation","Microsoft Learn - PowerShell"],"variables":{"declaration (การประกาศ)":["$variable_name = value // รูปแบบการประกาศตัวแปร"],"types (ประเภท)":["String // สตริง (ข้อความ)","Int32 // จำนวนเต็ม 32 บิต","Boolean // บูลีน (True/False)","Array // อาร์เรย์ (ชุดข้อมูล)","HashTable // ตารางแฮช (Key-Value pairs)","Object // วัตถุทั่วไป"],"examples (ตัวอย่าง)":["$name = \"Jane Doe\" // กำหนดตัวแปร name เก็บสตริง 'Jane Doe'","$age = 25 // กำหนดตัวแปร age เก็บตัวเลข 25","$files = @(\"file1.txt\", \"file2.txt\") // กำหนดอาร์เรย์ files","$config = @{ 'Path' = 'C:\\temp'; 'Verbose' = $true } // กำหนด HashTable"]},"functions":{"declaration (การประกาศ)":["function function-name { ... } // รูปแบบการประกาศฟังก์ชันแบบปกติ","function name { param(...) ... } // รูปแบบการประกาศฟังก์ชันพร้อมการประกาศพารามิเตอร์"],"examples (ตัวอย่าง)":["// ฟังก์ชันทักทายรับพารามิเตอร์\nfunction Get-Greeting {\n    param(\n        [string]$Name\n    )\n    \"Hello, $Name!\"\n}\n","// ฟังก์ชันบวกเลขสองจำนวน\nfunction Add-Numbers {\n    param(\n        [int]$a,\n        [int]$b\n    )\n    return ($a + $b)\n}\n","// การเรียกใช้ฟังก์ชัน\n$msg = Get-Greeting -Name \"PowerShell User\" // $msg จะมีค่า 'Hello, PowerShell User!'\n$sumResult = Add-Numbers -a 10 -b 5 // $sumResult จะมีค่า 15\n"],"built_in (ในตัว)":["Get-Process // ดึงข้อมูล Process ที่กำลังทำงานอยู่","Set-Item // ตั้งค่า Item (เช่น ไฟล์, Registry)","Remove-Item // ลบ Item","Get-Content // อ่านเนื้อหาจากไฟล์","Invoke-WebRequest // ส่ง Web Request","Select-Object // เลือก Property จาก Object","Where-Object // กรอง Object ตามเงื่อนไข","ForEach-Object // วนซ้ำแต่ละ Object ใน Collection","New-Item // สร้าง Item ใหม่ (เช่น ไฟล์, โฟลเดอร์)"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","<# Multi line #> // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { ... } elseif (condition) { ... } else { ... } // คำสั่ง if-elseif-else","switch (expression) { case value { ... } default { ... } } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (initialization; condition; increment) { ... } // ลูป for แบบ C-style","foreach ($item in $collection) { ... } // ลูป foreach สำหรับวนซ้ำ Collection","while (condition) { ... } // ลูป while","do { ... } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)"],"operators (ตัวดำเนินการ)":["Numeric Comparison: -eq (เท่ากับ), -ne (ไม่เท่ากับ), -gt (มากกว่า), -lt (น้อยกว่า), -ge (มากกว่าหรือเท่ากับ), -le (น้อยกว่าหรือเท่ากับ)","String Comparison: -eq (เท่ากับ), -ne (ไม่เท่ากับ), -like (คล้าย), -notlike (ไม่คล้าย), -match (ตรงกับ Regex), -notmatch (ไม่ตรงกับ Regex)","Logical: -and (AND), -or (OR), -not (NOT), -xor (XOR)","Assignment: =, +=, -=, *=, /=, %=","Type Operators: -is (เป็นประเภท), -isnot (ไม่เป็นประเภท)","Join/Split: -join (รวมสตริง), -split (แยกสตริง)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\n$age = 20\nif ($age -ge 18) {\n    \"Adult\"\n} else {\n    \"Minor\"\n}\n","// ตัวอย่างที่ 2: การกรอง Process ที่กำลังทำงานอยู่\nGet-Process | Where-Object {$_.Status -eq 'Running'} | Select-Object Name, Id, CPU\n","// ตัวอย่างที่ 3: การวนลูปประมวลผลไฟล์\n$files = @(\"script1.ps1\", \"script2.ps1\", \"script3.log\")\nforeach ($file in $files) {\n    Write-Host \"Processing $file\"\n}\n","// ตัวอย่างที่ 4: การใช้งาน Switch Statement\n$day = \"Wednesday\"\nswitch ($day) {\n    \"Monday\" { \"Start of week\" }\n    \"Friday\" { \"End of week\" }\n    default { \"Mid-week\" }\n}\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Try-Catch-Finally)\ntry {\n    $num1 = 10\n    $num2 = 0\n    $result = $num1 / $num2 # จะเกิด DivisionByZeroException\n    Write-Host \"Result: $result\"\n} catch [System.DivideByZeroException] {\n    Write-Host \"Error: Cannot divide by zero!\"\n} catch {\n    Write-Host \"An unexpected error occurred: $($_.Exception.Message)\"\n} finally {\n    Write-Host \"Execution completed.\"\n}\n"]}},{"id":26,"name":"Prolog","slug":"prolog","logo":"img/prolog.png","desc":"Prolog (PROgramming in LOGic) เป็นภาษาโปรแกรมเชิงตรรกะ (Logic Programming) ที่ใช้ในการสร้างระบบผู้เชี่ยวชาญ (Expert Systems), การประมวลผลภาษาธรรมชาติ และ AI เป็นหลัก โปรแกรมถูกเขียนในรูปของข้อเท็จจริงและกฎเกณฑ์","by":"Alain Colmerauer and Robert Kowalski","yr":"1972","level":"4","par":["Logic Programming","Declarative"],"fields":["AI","Edu"],"rank":"45+ Niche ใน Logic Programming","salary_range":"฿25,000-42,000 บาท/เดือน (Junior), ฿42,000-75,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["เหมาะสำหรับงาน AI ที่เกี่ยวข้องกับตรรกะและการค้นหา (Search)","สามารถสร้าง Expert Systems ได้ง่าย","มีการ Backtracking ในตัว","มีคุณสมบัติในการประมวลผลภาษาธรรมชาติ","สามารถเขียนโปรแกรมที่กระชับและทรงพลังสำหรับปัญหาบางประเภท"],"cons":["Learning Curve สูงมาก (แนวคิดการเขียนโปรแกรมที่แตกต่าง)","ไม่เหมาะสำหรับการพัฒนาแอปพลิเคชันทั่วไป","ประสิทธิภาพอาจไม่ดีสำหรับงานคำนวณเชิงตัวเลข","ชุมชนนักพัฒนาเล็กและ Niche","การดีบักอาจทำได้ยากเมื่อเกิด Failure"],"frameworks":["None (เป็นภาษาพื้นฐาน)"],"learn":["Learn Prolog Now!","The Art of Prolog","SWI-Prolog Documentation","Tutorials Point Prolog"],"variables":{"declaration (การประกาศ)":["X is 10. % X คือตัวแปร (เริ่มต้นด้วยตัวพิมพ์ใหญ่)","Name = 'Alice'. % Name คือตัวแปร (เริ่มต้นด้วยตัวพิมพ์ใหญ่)"],"types (ประเภท)":["Atoms // ค่าคงที่ที่เริ่มต้นด้วยตัวพิมพ์เล็กหรืออยู่ในเครื่องหมาย Single Quote (เช่น 'hello', world)","Numbers // ตัวเลข (จำนวนเต็ม, ทศนิยม)","Variables // ตัวแปร (เริ่มต้นด้วยตัวพิมพ์ใหญ่ หรือ _)","Lists // รายการ (เช่น [1, 2, 3])","Structures // โครงสร้างข้อมูลที่ซับซ้อน (เช่น person(Name, Age))"],"examples (ตัวอย่าง)":["father(john, mary). % Fact: John เป็นพ่อของ Mary","likes(mary, books). % Fact: Mary ชอบหนังสือ","age(peter, 30). % Fact: อายุของ Peter คือ 30"]},"functions":{"declaration (การประกาศ)":["rule_name(Head) :- Body. % การกำหนด Rule (ถ้า Body เป็นจริง, Head ก็เป็นจริง)","fact_name(Arg1, Arg2). % การกำหนด Fact (ข้อเท็จจริง)"],"examples (ตัวอย่าง)":["// การกำหนด Rules (กฎเกณฑ์)\nparent(X, Y) :- father(X, Y). % X เป็นพ่อแม่ของ Y ถ้า X เป็นพ่อของ Y\nparent(X, Y) :- mother(X, Y). % X เป็นพ่อแม่ของ Y ถ้า X เป็นแม่ของ Y\ngrandparent(X, Z) :- parent(X, Y), parent(Y, Z). % X เป็นปู่ย่าตายายของ Z ถ้า X เป็นพ่อแม่ของ Y และ Y เป็นพ่อแม่ของ Z (ใช้ ',' สำหรับ AND)\n","// การ Query (สอบถาม)\n?- grandparent(john, Z). % Query: ใครคือหลานของ John? (Z จะถูก Binding ด้วยค่าที่เป็นไปได้)\n?- father(F, mary). % Query: ใครคือพ่อของ Mary? (F จะถูก Binding ด้วยค่าที่เป็นไปได้)\n?- parent(john, X). % Query: John เป็นพ่อแม่ของใครบ้าง?\n","// ฟังก์ชัน Recursive สำหรับความสัมพันธ์ทางญาติ\nsibling(X, Y) :- parent(Z, X), parent(Z, Y), X \\= Y. % X เป็นพี่น้องกับ Y ถ้ามีพ่อแม่ร่วมกัน และ X ไม่ใช่ Y\n\n// การทำงานกับ Lists\nmember(X, [X|_]). % X เป็นสมาชิกของ List ถ้า X คือ Head\nmember(X, [_|T]) :- member(X, T). % X เป็นสมาชิกของ List ถ้า X เป็นสมาชิกของ Tail\n\n// การ Query กับ List\n?- member(a, [a, b, c]). % true\n?- member(d, [a, b, c]). % false\n","// Asynchronous Programming (แนวคิด - ผ่านระบบ Multi-threading/External Calls)\n// Prolog โดยพื้นฐานไม่ใช่ภาษาสำหรับการทำงาน Asynchronous I/O ในตัว\n// การทำงานแบบ Concurrency มักจะเกี่ยวข้องกับการใช้ Modules สำหรับ Multi-threading หรือการเชื่อมต่อกับภาษาอื่น\n// ซึ่งเป็นเรื่องที่ซับซ้อนและไม่ได้อยู่ใน Core Concept ของ Logic Programming\n/*\n% ตัวอย่างแนวคิด (ไม่ใช่โค้ด Prolog มาตรฐานสำหรับ Async I/O)\n% การทำ async ใน Prolog มักจะเป็นการเรียกใช้ Predicate ที่ทำงานแบบ non-blocking ผ่าน Foreign Language Interface (FLI)\n% หรือใช้ Library ที่จัดการ Threads\n% :- use_module(library(prolog_threads)).\n% \n% my_async_task(Result) :-\n%     thread_create(long_computation(Result), _, [detached(true)]).\n% \n% long_computation(Result) :-\n%     writeln('Starting long computation...'),\n%     sleep(1), % จำลองการหน่วงเวลา\n%     writeln('Long computation finished!'),\n%     Result = 'Data from async source'.\n% \n% % ใน Console:\n% % ?- my_async_task(R).\n% % R = <thread_id> % จะได้ thread ID กลับมาทันที\n% % ?- thread_join(<thread_id>, Status). % รอผลลัพธ์ (อาจจะ blocking)\n*/"],"built_in (ในตัว)":["write() // ใช้แสดง Term ออกทาง Console","read() // ใช้รับ Term จากผู้ใช้งาน","findall() // ใช้หา Solution ทั้งหมดของ Goal และเก็บใน List","member() // Predicate สำหรับตรวจสอบว่า Element เป็นสมาชิกของ List หรือไม่","is // ใช้ประเมินนิพจน์ทางคณิตศาสตร์ (เช่น X is 5 + 3)","consult() // ใช้โหลดไฟล์ Prolog","nl // ขึ้นบรรทัดใหม่ (Newline)","fail // ทำให้ Goal ล้มเหลว (บังคับ Backtracking)","not // Negation as Failure (การปฏิเสธในฐานะความล้มเหลว)"]},"syntax":{"comments (คอมเมนต์)":["% Single line comment // คอมเมนต์บรรทัดเดียว (เริ่มต้นด้วย %)","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["A :- B, C. % A เป็นจริง ถ้า B เป็นจริง AND C เป็นจริง (ใช้ ',' สำหรับ AND)","A :- B; C. % A เป็นจริง ถ้า B เป็นจริง OR C เป็นจริง (ใช้ ';' สำหรับ OR)"],"loops (การวนซ้ำ)":["// Prolog ไม่มี loop แบบ Imperative โดยตรง (for, while)\n// แต่จะใช้ Recursion (การเรียกตัวเองของ Predicate) และ Backtracking (การค้นหา Solution ทั้งหมด) เพื่อจำลองพฤติกรรมของลูป\n\ncount(0). % Base Case: ถ้า 0, หยุด\ncount(N) :- count(M), N is M+1. % Recursive Case: ถ้า N, ให้หา M และ N คือ M+1 (จะนับขึ้นไปเรื่อยๆ)\n\n% ?- count(X). % จะนับ 0, 1, 2, ... ไปเรื่อยๆ จนกว่าจะหยุดด้วย ; หรือ End Of Solutions"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, mod // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, เศษเหลือ","Comparison: =:=, =\\=, <, >, =<, >= // ตัวดำเนินการเปรียบเทียบตัวเลข: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า, น้อยกว่าหรือเท่ากับ, มากกว่าหรือเท่ากับ","Logical: , (AND), ; (OR), \\+ (NOT) // ตัวดำเนินการตรรกะ: AND, OR, NOT (Negation as Failure)",":- // Implication (ถ้า...แล้ว...)",". // Full Stop (จบ Fact หรือ Rule)","| // List Separator (Head|Tail)"],"examples":["// ตัวอย่างที่ 1: การใช้ Rule (If-Then)\ncan_vote(Person) :- age(Person, Age), Age >= 18. % Person สามารถโหวตได้ ถ้า Person มีอายุ (Age) และ Age มากกว่าหรือเท่ากับ 18\n\n% กำหนด Fact สำหรับทดสอบ\nage(peter, 20).\nage(susan, 16).\n\n% Query:\n% ?- can_vote(peter). % true\n% ?- can_vote(susan). % false\n","// ตัวอย่างที่ 2: Recursion (Loop-like behavior) และ List Processing\n% Predicate สำหรับแสดงสมาชิกของ List ทีละบรรทัด\nlist_items([]). % Base Case: ถ้า List ว่าง, หยุด\nlist_items([Head|Tail]) :- % Recursive Case: ถ้า List มี Head และ Tail\n    write(Head), nl, % แสดง Head และขึ้นบรรทัดใหม่\n    list_items(Tail). % เรียกตัวเองซ้ำกับ Tail\n\n% Query:\n% ?- list_items([apple, banana, cherry]).\n% apple\n% banana\n% cherry\n% true.\n","// ตัวอย่างที่ 3: การทำงานกับ Database (Facts และ Rules)\n% Facts: รายการหนังสือ\nbook(title('The Hitchhiker''s Guide to the Galaxy'), author('Douglas Adams'), year(1979)).\nbook(title('Pride and Prejudice'), author('Jane Austen'), year(1813)).\nbook(title('1984'), author('George Orwell'), year(1949)).\n\n% Rule: หาหนังสือที่ตีพิมพ์ก่อนปีที่กำหนด\nold_book(Title, Year) :- book(title(Title), _, year(Year)), Year < 1950.\n\n% Query:\n% ?- old_book(Title, Year).\n% Title = 'Pride and Prejudice', Year = 1813 ;\n% Title = '1984', Year = 1949 ;\n% false.\n","// ตัวอย่างที่ 4: Expert System (ระบบผู้เชี่ยวชาญ)\n% Facts: อาการต่างๆ\nsymptom(fever, high_temperature).\nsymptom(cough, dry).\nsymptom(sore_throat, mild).\n\n% Rule: วินิจฉัยโรคไข้หวัดใหญ่\ndisease(flu) :- symptom(fever, high_temperature), symptom(cough, dry), symptom(body_ache, yes).\n\n% Query:\n% ?- disease(flu).\n% (ถ้ามี facts body_ache(yes) อยู่ด้วย จะได้ true)\n"]}},{"id":5,"name":"Python","slug":"python","logo":"img/python.png","desc":"Python คือภาษาโปรแกรมที่ใช้งานง่ายและหลากหลาย เน้นความอ่านง่ายของโค้ด เหมาะสำหรับงานด้านวิทยาศาสตร์ข้อมูล, AI, เว็บ และการทำงานอัตโนมัติ","by":"Guido van Rossum","yr":"February 20, 1991","level":"4","par":["Object-Oriented","Imperative","Functional","Procedural","Reflective"],"fields":["AI","Data","Backend","Script","Edu","Testing","Security","Cloud","Robot","Network","Finance","Plugin","Math","Graphics","Render","HPC","Aero","Digital","Hardware"],"rank":"1 ภาษายอดนิยมสูงสุดโลก (TIOBE Index 2025 - 23.88%)","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-120,000 บาท/เดือน (Senior)","salary":["low","mid","high","veryhigh"],"pros":["ไวยากรณ์เรียบง่าย อ่านและเรียนรู้ง่าย","มีไลบรารีมาตรฐานขนาดใหญ่และแพ็กเกจภายนอกจำนวนมาก","รองรับการทำงานหลากหลาย (เว็บ, AI, Data Science)","ชุมชนผู้ใช้งานแข็งแกร่งและให้การสนับสนุนดี"],"cons":["ความเร็วในการประมวลผลช้ากว่าภาษาที่คอมไพล์","การใช้หน่วยความจำสูงในบางแอปพลิเคชัน","Global Interpreter Lock (GIL) จำกัดการทำงานแบบมัลติเธรดสำหรับงานที่ใช้ CPU มาก"],"frameworks":["Django","Flask","FastAPI","NumPy","Pandas","Scikit-learn","TensorFlow","PyTorch"],"learn":["Python.org Official Docs","Codecademy: Learn Python","Real Python","Google's Python Class"],"variables":{"declaration (การประกาศ)":["variable_name = value // วิธีการกำหนดค่าให้กับตัวแปร","x, y, z = 1, 2, 3 // การกำหนดค่าให้กับหลายตัวแปรพร้อมกัน (Multiple Assignment)"],"types (ประเภท)":["int // ประเภทข้อมูลตัวเลขจำนวนเต็ม","float // ประเภทข้อมูลตัวเลขทศนิยม","str // ประเภทข้อมูลสตริง (ข้อความ)","list // ประเภทข้อมูลรายการที่สามารถเปลี่ยนแปลงได้ (คล้าย Array)","tuple // ประเภทข้อมูลรายการที่ไม่สามารถเปลี่ยนแปลงได้)","dict // ประเภทข้อมูลพจนานุกรม (key-value pairs)","set // ประเภทข้อมูลเซต (คอลเลกชันของรายการที่ไม่ซ้ำกัน)","bool // ประเภทข้อมูลบูลีน (True หรือ False)","NoneType // ประเภทข้อมูลสำหรับค่าว่างเปล่า"],"examples (ตัวอย่าง)":["name = \"Alice\" // กำหนดตัวแปร name เก็บสตริง \"Alice\"","age = 25 // กำหนดตัวแปร age เก็บตัวเลข 25","is_active = True // กำหนดตัวแปร is_active เก็บค่าความจริง True","my_list = [10, 20, 30] // กำหนดตัวแปร my_list เก็บรายการตัวเลข"]},"functions":{"declaration (การประกาศ)":["def function_name(params): ... // การประกาศฟังก์ชันแบบปกติโดยใช้คำสั่ง def","lambda args: expression // การประกาศฟังก์ชันแบบไม่ระบุชื่อ (Anonymous Function) แบบย่อ"],"examples (ตัวอย่าง)":["def calculate_area(width, height): // ฟังก์ชันคำนวณพื้นที่\n  return width * height\n","add = lambda x, y: x + y // ฟังก์ชัน add แบบย่อ (Lambda Function) เพื่อบวกเลข\n","def greet(name='Guest'): // ฟังก์ชันพร้อมค่าเริ่มต้นสำหรับพารามิเตอร์\n  return f'Hello, {name}!'\nprint(greet()) // Hello, Guest!\nprint(greet('Alice')) // Hello, Alice!\n","def sum_all(*args): // ฟังก์ชันที่รับจำนวนอาร์กิวเมนต์แบบไม่จำกัด\n  return sum(args)\nprint(sum_all(1, 2, 3)) // 6\n","def build_profile(first, last, **kwargs): // ฟังก์ชันที่รับ keyword arguments แบบไม่จำกัด\n  profile = {'first_name': first, 'last_name': last}\n  profile.update(kwargs)\n  return profile\nprint(build_profile('John', 'Doe', age=30, city='New York'))\n","def create_adder(x): // ฟังก์ชันที่คืนค่าฟังก์ชัน (Closure)\n  def adder(y):\n    return x + y\n  return adder\nadd_5 = create_adder(5)\nprint(add_5(10)) // 15\n","def count_up_to(max): // ฟังก์ชัน Generator\n  i = 1\n  while i <= max:\n    yield i\n    i += 1\n\ncounter = count_up_to(3)\nprint(next(counter)) // 1\nprint(next(counter)) // 2\n","// Asynchronous Function (using asyncio)\n// โค้ดด้านล่างนี้เป็นตัวอย่างการใช้งานฟังก์ชันแบบ Asynchronous ซึ่งต้องรันในสภาพแวดล้อมที่รองรับ `asyncio` และ Event Loop ของ Python\n// import asyncio\n// async def fetch_data():\n//   print(\"Fetching data...\")\n//   await asyncio.sleep(1) // Simulate network delay\n//   print(\"Data fetched!\")\n//   return {\"data\": \"some_data\"}\n//\n// async def main():\n//   result = await fetch_data()\n//   print(result)\n//\n// asyncio.run(main())"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","len() // ใช้หาความยาวของ Object (เช่น สตริง, ลิสต์)","input() // ใช้รับข้อมูลจากผู้ใช้งาน","range() // ใช้สร้างลำดับตัวเลข","type() // ใช้ตรวจสอบประเภทข้อมูลของ Object","str() // ใช้แปลงข้อมูลเป็นสตริง","int() // ใช้แปลงข้อมูลเป็นตัวเลขจำนวนเต็ม","list() // ใช้แปลงข้อมูลเป็นลิสต์"]},"syntax":{"comments (คอมเมนต์)":["# Single line // คอมเมนต์บรรทัดเดียว","\"\"\"Multi line\"\"\" // คอมเมนต์หลายบรรทัด (Docstrings)"],"conditions (เงื่อนไข)":["if...elif...else // ใช้สร้างเงื่อนไข 'ถ้า...ไม่อย่างนั้นถ้า...นอกเหนือจากนั้น'"],"loops (การวนซ้ำ)":["for // วนซ้ำสำหรับแต่ละสมาชิกในลำดับ (เช่น ลิสต์, สตริง)","while // วนซ้ำตราบเท่าที่เงื่อนไขเป็นจริง"],"operators (ตัวดำเนินการ)":["+ // ตัวดำเนินการบวก","- // ตัวดำเนินการลบ","* // ตัวดำเนินการคูณ","/ // ตัวดำเนินการหาร (ผลลัพธ์เป็น float)","% // ตัวดำเนินการโมดูลัส (หารเอาเศษ)","// // ตัวดำเนินการหารเอาส่วนเต็ม","** // ตัวดำเนินการยกกำลัง","== // ตัวดำเนินการเปรียบเทียบเท่ากัน","!= // ตัวดำเนินการเปรียบเทียบไม่เท่ากัน","> // ตัวดำเนินการมากกว่า","< // ตัวดำเนินการน้อยกว่า",">= // ตัวดำเนินการมากกว่าหรือเท่ากับ","<= // ตัวดำเนินการน้อยกว่าหรือเท่ากับ","and // ตัวดำเนินการตรรกะ 'และ'","or // ตัวดำเนินการตรรกะ 'หรือ'","not // ตัวดำเนินการตรรกะ 'ไม่'","in // ตัวดำเนินการสมาชิก 'มีอยู่ใน'","not in // ตัวดำเนินการสมาชิก 'ไม่มีอยู่ใน'","is // ตัวดำเนินการเอกลักษณ์ 'เป็น Object เดียวกัน'","is not // ตัวดำเนินการเอกลักษณ์ 'ไม่เป็น Object เดียวกัน'"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nif score >= 90: print('Grade A')\nelif score >= 70: print('Grade B')\nelse: print('Grade C') // ตรวจสอบคะแนนและแสดงเกรด","// ตัวอย่างที่ 2: การวนลูป (for loop) แบบพื้นฐาน\nfor i in range(3): print(i) // วนลูปให้ i มีค่า 0 ถึง 2","// ตัวอย่างที่ 3: การวนลูป (for loop) ผ่าน List\nfruits = ['apple', 'banana', 'cherry']\nfor fruit in fruits:\n  print(f'I like {fruit}')","// ตัวอย่างที่ 4: การใช้วงลูป (while loop)\ncount = 0\nwhile count < 3:\n  print(f'Count is: {count}')\n  count += 1","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Try-Except)\ntry:\n  result = 10 / 0\nexcept ZeroDivisionError:\n  print('Error: Cannot divide by zero!')","// ตัวอย่างที่ 6: List Comprehension\nsquares = [x**2 for x in range(5)] // สร้างลิสต์ของกำลังสองของตัวเลข 0-4\nprint(squares)","// ตัวอย่างที่ 7: การทำงานกับ Dictionary\nperson = {'name': 'John', 'age': 30}\nprint(person['name']) // เข้าถึงค่าด้วย key\nperson['city'] = 'New York' // เพิ่ม key-value ใหม่\nprint(person) "]}},{"id":14,"name":"R","slug":"r","logo":"img/r.png","desc":"R เป็นภาษาโปรแกรมและสภาพแวดล้อมซอฟต์แวร์สำหรับการวิเคราะห์ทางสถิติ, การแสดงผลข้อมูล และ Data Science มีแพ็กเกจจำนวนมากที่รองรับงานด้านสถิติและ Machine Learning","by":"Ross Ihaka and Robert Gentleman","yr":"1993","level":"5","par":["Functional","Procedural","Object-Oriented"],"fields":["Data","Scientific","Script","HPC"],"rank":"11-13 แต่กำลังลดลงเรื่อยๆ (แพ้ Python ใน Data Science)","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-90,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ประสิทธิภาพสูงสำหรับการวิเคราะห์ข้อมูลทางสถิติ","มีแพ็กเกจ (CRAN) จำนวนมากและหลากหลาย","สร้างกราฟและ Visualization ได้สวยงาม","มีชุมชนนักสถิติและ Data Scientists ที่แข็งแกร่ง","ฟรีและ Open-source"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่มีพื้นฐานสถิติ","ประสิทธิภาพอาจไม่ดีเท่าภาษาอื่นสำหรับการทำงานทั่วไป","การจัดการหน่วยความจำอาจเป็นปัญหาสำหรับ Big Data","เหมาะสำหรับ Data Science เป็นหลัก ไม่ใช่ General-purpose"],"frameworks":["Shiny (Web Apps)","Tidyverse (Data Science)"],"learn":["R-project.org Official Docs","R for Data Science","Coursera: R Programming","DataCamp R Courses"],"variables":{"declaration (การประกาศ)":["my_var <- 10 // การกำหนดค่าให้กับตัวแปร (นิยมใช้)","my_string = \"Hello R\" // การกำหนดค่าให้กับตัวแปร (สามารถใช้ได้)"],"types (ประเภท)":["numeric // ประเภทข้อมูลตัวเลข (รวมทั้งจำนวนเต็มและทศนิยม)","integer // ประเภทข้อมูลตัวเลขจำนวนเต็ม","character // ประเภทข้อมูลสตริง (ข้อความ)","logical // ประเภทข้อมูลบูลีน (TRUE/FALSE)","complex // ประเภทข้อมูลตัวเลขเชิงซ้อน","raw // ประเภทข้อมูลดิบ (bytes)","vector // โครงสร้างข้อมูลพื้นฐานที่สุดของ R (เก็บข้อมูลประเภทเดียวกัน)","matrix // เมทริกซ์ (เก็บข้อมูลประเภทเดียวกันใน 2 มิติ)","array // อาร์เรย์ (เก็บข้อมูลประเภทเดียวกันใน N มิติ)","list // ลิสต์ (เก็บข้อมูลได้หลายประเภท)","data.frame // โครงสร้างข้อมูลแบบตาราง (คล้ายตารางในฐานข้อมูล)","factor // ประเภทข้อมูลสำหรับตัวแปรเชิงหมวดหมู่"],"examples (ตัวอย่าง)":["age <- 30 // กำหนดตัวแปร age เก็บตัวเลข 30","name <- \"Emily\" // กำหนดตัวแปร name เก็บสตริง","is_active <- TRUE // กำหนดตัวแปร is_active เก็บค่าความจริง","numbers <- c(1, 2, 3) // สร้าง vector ของตัวเลข","text_vector <- c(\"apple\", \"banana\", \"cherry\") // สร้าง vector ของสตริง","my_matrix <- matrix(1:9, nrow = 3) // สร้างเมทริกซ์ 3x3","my_list <- list(name = \"John\", age = 25, is_student = TRUE) // สร้างลิสต์","my_df <- data.frame(ID = 1:2, Name = c(\"A\", \"B\")) // สร้าง data.frame"]},"functions":{"declaration (การประกาศ)":["function_name <- function(param1, param2) { /* ... */ } // การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nadd_numbers <- function(a, b) {\n  return(a + b)\n}\n","// ฟังก์ชันแสดงข้อความทักทาย\nprint_greeting <- function(name) {\n  cat(\"Hello, \", name, \"!\\n\")\n}\n","// การเรียกใช้ฟังก์ชัน\nsum_result <- add_numbers(10, 20) // sum_result จะมีค่า 30\nprint_greeting(\"R User\") // แสดงผล 'Hello, R User!'\n","// ฟังก์ชันที่มี Optional Arguments และ Default Values\ncalculate_bmi <- function(weight, height, unit = \"metric\") {\n  if (unit == \"metric\") {\n    bmi <- weight / (height^2)\n  } else if (unit == \"imperial\") {\n    bmi <- (weight * 703) / (height^2)\n  } else {\n    stop(\"Invalid unit. Use 'metric' or 'imperial'.\")\n  }\n  return(bmi)\n}\nprint(calculate_bmi(70, 1.75)) // คำนวณ BMI แบบเมตริก\nprint(calculate_bmi(150, 68, unit = \"imperial\")) // คำนวณ BMI แบบอิมพีเรียล\n","// ฟังก์ชันที่คืนค่าหลายค่า (ด้วย List)\nget_summary_stats <- function(data_vector) {\n  list(\n    mean = mean(data_vector),\n    median = median(data_vector),\n    sd = sd(data_vector)\n  )\n}\nstats <- get_summary_stats(c(1, 2, 3, 4, 5))\nprint(stats$mean) // เข้าถึงค่าเฉลี่ย\n","// การใช้งาน Apply Family Functions (Higher-Order Functions)\n# lapply: ใช้ฟังก์ชันกับแต่ละ Element ใน List/Vector (คืนค่าเป็น List)\nmy_list <- list(a = 1:3, b = 4:6)\nsquares_list <- lapply(my_list, function(x) x^2)\nprint(squares_list) # [[1,4,9], [16,25,36]]\n# sapply: ใช้ฟังก์ชันกับแต่ละ Element ใน List/Vector (คืนค่าเป็น Vector/Matrix หากเป็นไปได้)\nmy_vector <- c(1, 2, 3)\ndouble_vector <- sapply(my_vector, function(x) x * 2)\nprint(double_vector) # [2, 4, 6]\n","// Asynchronous Programming (Conceptual - R ใช้ packages)\n// R ไม่ได้มี Asynchronous Programming ในตัวแบบ native เหมือน Go/JS\n// แต่มี packages เช่น 'future' หรือ 'promises' ที่ช่วยในการทำงานแบบ Asynchronous\n// ตัวอย่างนี้แสดงแนวคิดการทำงานแบบ Non-blocking โดยใช้ future package\n/*\n# install.packages('future')\nlibrary(future)\nplan(multisession) # รัน tasks ใน session แยกต่างหาก\n\nlong_computation <- function() {\n  message(\"Starting long computation...\")\n  Sys.sleep(2) # จำลองการทำงานที่ใช้เวลา\n  message(\"Long computation finished!\")\n  return(42)\n}\n\nasync_result <- future({ long_computation() })\nmessage(\"Main program continues while computation runs...\")\n\n# รอผลลัพธ์ (blocking ในจุดนี้)\nresult <- value(async_result)\nmessage(\"Received result: \", result)\n*/"],"built_in (ในตัว)":["print() // ใช้แสดงผล Object","cat() // ใช้แสดงผลข้อมูลออกทาง Console (เชื่อมสตริงและพิมพ์)","c() // ใช้สร้าง Vector","mean() // ใช้คำนวณค่าเฉลี่ย","sum() // ใช้คำนวณผลรวม","length() // ใช้หาความยาวของ Vector/List","data.frame() // ใช้สร้าง Data Frame","list() // ใช้สร้าง List","matrix() // ใช้สร้าง Matrix","read.csv() // ใช้อ่านไฟล์ CSV","plot() // ใช้สร้างกราฟพื้นฐาน"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","ifelse(test, yes, no) // ฟังก์ชันเงื่อนไขแบบ Vectorized (สำหรับ Vector)"],"loops (การวนซ้ำ)":["for (item in collection) { /* ... */ } // ลูป for-in สำหรับวนซ้ำ Collection (นิยมใช้)","while (condition) { /* ... */ } // ลูป while","repeat { /* ... */ if (condition) break } // ลูป repeat (ทำงานอย่างน้อยหนึ่งครั้ง) พร้อมเงื่อนไขออก","sapply(list, function) // ใช้ฟังก์ชันกับแต่ละ Element ใน List/Vector (คืนค่าเป็น Vector)","lapply(list, function) // ใช้ฟังก์ชันกับแต่ละ Element ใน List/Vector (คืนค่าเป็น List)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %%, ^ // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Assignment: <-, = // ตัวดำเนินการกำหนดค่า: '<-' เป็นที่นิยมมากกว่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ (Vectorized), หรือ (Vectorized), ไม่","Vectorized Logical: & (AND), | (OR) // ตัวดำเนินการตรรกะแบบ Element-wise (สำหรับ Vector)","%in% // ตัวดำเนินการตรวจสอบการเป็นสมาชิก","$ // ตัวดำเนินการเข้าถึง Element ใน List/Data Frame ด้วยชื่อ","[[]] // ตัวดำเนินการเข้าถึง Element ใน List/Data Frame ด้วยชื่อหรือ Index (คืนค่าเป็น Element)","[] // ตัวดำเนินการเข้าถึง Element ใน Vector/List/Data Frame ด้วย Index (คืนค่าเป็น Sub-structure)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nscore <- 75\nif (score >= 90) {\n  print(\"Grade A\")\n} else if (score >= 70) {\n  print(\"Grade B\")\n} else {\n  print(\"Grade C\")\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) และ Vector\nnumbers <- c(10, 20, 30)\nfor (num in numbers) {\n  print(paste(\"Number:\", num))\n}\n","// ตัวอย่างที่ 3: การใช้ ifelse (Vectorized Conditional)\nages <- c(15, 20, 17, 22)\nstatus <- ifelse(ages >= 18, \"Adult\", \"Minor\")\nprint(status) // แสดงผล [1] \"Minor\" \"Adult\" \"Minor\" \"Adult\"\n","// ตัวอย่างที่ 4: การใช้งาน Data Frame\nstudents <- data.frame(\n  Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n  Age = c(20, 22, 21),\n  Major = c(\"CS\", \"Math\", \"Physics\")\n)\nprint(students) # แสดง data frame\nprint(students$Name) # เข้าถึงคอลัมน์ Name\nprint(students[2, \"Age\"]) # เข้าถึงค่าใน row 2, column 'Age'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย tryCatch\ntryCatch({\n  result <- 10 / 0 # จะเกิด error\n  print(result)\n}, error = function(e) {\n  print(paste(\"Error occurred:\", e$message))\n}, finally = {\n  print(\"Execution finished.\")\n})\n","// ตัวอย่างที่ 6: การสร้างกราฟเบื้องต้น (Plotting)\n# plot(x, y, type, main, xlab, ylab)\nx_coords <- c(1, 2, 3, 4, 5)\ny_coords <- c(2, 4, 1, 5, 3)\n# plot(x_coords, y_coords, type = \"b\", \n#      main = \"Simple Line Plot\", \n#      xlab = \"X-axis\", ylab = \"Y-axis\")\n# ผลลัพธ์: กราฟเส้นเชื่อมจุด"]}},{"id":44,"name":"Racket","slug":"racket","logo":"img/racket.png","desc":"Racket เป็นภาษาโปรแกรม Multi-paradigm ในตระกูล Scheme/Lisp ที่เน้นการออกแบบภาษาโปรแกรมและ Metaprogramming มีสภาพแวดล้อมที่ครบวงจรสำหรับการศึกษา, การวิจัย และการพัฒนาซอฟต์แวร์ที่ซับซ้อน เป็นที่รู้จักกันดีในการให้คุณสร้างภาษาโปรแกรมของคุณเอง (DSLs) ได้อย่างง่ายดาย","by":"PLT Inc.","yr":"2010","level":"3","par":["Functional","Procedural","Object-Oriented","Metaprogramming","Logic Programming (with extensions)"],"fields":["Edu","Compiler"],"rank":"Niche ใน Education และ Research","salary_range":"฿28,000-48,000 บาท/เดือน (Junior), ฿48,000-80,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["สภาพแวดล้อมการพัฒนาภาษาที่ทรงพลัง (Language-oriented programming)","มีเครื่องมือสำหรับสร้างภาษาเฉพาะทาง (DSLs) ได้ง่าย","รองรับ Functional Programming และ Meta-programming ได้ดี","เหมาะสำหรับการศึกษาและวิจัยด้านวิทยาการคอมพิวเตอร์","มี IDE ที่ดี (DrRacket) ที่ออกแบบมาเพื่อการเรียนรู้","เป็นภาษา Lisp ที่มีโครงสร้างและ Modules ที่ทันสมัย"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Lisp/Functional Programming","ไวยากรณ์วงเล็บ (Parentheses) อาจดูซับซ้อนสำหรับผู้เริ่มต้น","ชุมชนนักพัฒนาเล็กและเฉพาะทาง","ไม่เหมาะกับการพัฒนาแอปพลิเคชันเชิงพาณิชย์ขนาดใหญ่โดยตรง","ประสิทธิภาพอาจไม่ดีเท่าภาษาที่คอมไพล์แบบ Native สำหรับบางงาน"],"frameworks":["Web Servers (built-in via `web-server` library)","GUI Framework (built-in via `gui/2d` and `racket/gui`)"],"learn":["Racket-Lang.org","How to Design Programs (HtDP)","Realm of Racket","Programming Languages: Application and Interpretation (PLAI)"],"variables":{"declaration (การประกาศ)":["(define variable-name value) ; การประกาศตัวแปร/ค่าคงที่"],"types (ประเภท)":["Numbers (integers, reals, complex) // ตัวเลข (จำนวนเต็ม, ทศนิยม, จำนวนเชิงซ้อน)","Booleans (#t, #f) // ค่าความจริง (#t = true, #f = false)","Characters // ตัวอักขระ","Strings // ข้อความ","Symbols // สัญลักษณ์ (ใช้เป็นชื่อตัวแปร, ฟังก์ชัน, ฯลฯ)","Lists // รายการ (โครงสร้างข้อมูลแบบ Linked List)","Pairs // คู่ (พื้นฐานของ List)","Procedures (Functions) // ฟังก์ชัน (เป็น First-class citizen)","Vectors // เวกเตอร์ (คล้าย Array, เข้าถึงด้วย Index)","Hash Tables // ตาราง Hash (Key-Value pairs)","Structures // โครงสร้างข้อมูลที่กำหนดเอง"],"examples (ตัวอย่าง)":["(define x 10) ; กำหนดตัวแปร x เก็บค่า 10","(define message \"Hello Racket\") ; กำหนดตัวแปร message เก็บสตริง","(define pi 3.14159) ; กำหนดตัวแปร pi เก็บค่าทศนิยม","(define my-list '(1 2 3)) ; สร้าง List ด้วย Quote เพื่อไม่ให้ประเมินค่า","(define my-vector (vector 1 2 3)) ; สร้าง Vector","(define my-hash (hash 'name \"Alice\" 'age 25)) ; สร้าง Hash Table"]},"functions":{"declaration (การประกาศ)":["(define (function-name parameters) body) ; การประกาศฟังก์ชัน (Procedure)","(lambda (parameters) body) ; Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\n(define (add a b) \n  (+ a b))\n","// ฟังก์ชันทักทาย\n(define (greet name) \n  (displayln (string-append \"Hello \" name \"!\")))\n","// การเรียกใช้ฟังก์ชัน\n(define sum (add 5 5)) ; sum จะมีค่า 10\n(greet \"Racket User\") ; แสดงผล 'Hello Racket User!'\n","// ฟังก์ชัน Recursive สำหรับ Factorial\n(define (factorial n)\n  (if (zero? n)\n      1\n      (* n (factorial (sub1 n))))) ; ถ้า n เป็น 0 คืน 1 ไม่งั้น n * factorial(n-1)\n; (factorial 5) ; 120\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\n(define (apply-twice f x) \n  (f (f x)))\n; (apply-twice (lambda (y) (+ y 1)) 5) ; 7 (5 -> 6 -> 7)\n","// การทำงานกับ List โดยใช้ Recursion\n(define (list-sum lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (list-sum (cdr lst))))) ; ถ้า List ว่าง คืน 0 ไม่งั้น Head + Sum ของ Tail\n; (list-sum '(1 2 3 4)) ; 10\n","// Asynchronous Programming (แนวคิด - Racket ใช้ Threads หรือ Libraries)\n// Racket มี `thread` สำหรับการทำงานแบบ Concurrency และ `racket/async-io` สำหรับ Asynchronous I/O\n// ตัวอย่างนี้แสดงแนวคิดการใช้ Threads\n/*\n(require racket/thread)\n\n(define (long-task msg)\n  (displayln (string-append \"Thread: Starting \" msg \"...\"))\n  (sleep 1) ; จำลองการทำงานที่ใช้เวลา\n  (displayln (string-append \"Thread: Finished \" msg \"!\")))\n\n; (thread (lambda () (long-task \"Task A\")))\n; (thread (lambda () (long-task \"Task B\")))\n; (displayln \"Main program continues...\")\n; (sleep 2) ; ให้เวลากับ Threads ได้รัน\n; (displayln \"Main program done.\")\n*/"],"built_in (ในตัว)":["displayln // ใช้แสดงผลข้อมูลออกทาง Console พร้อมขึ้นบรรทัดใหม่","read // ใช้รับข้อมูลจากผู้ใช้งาน","list // สร้าง List","vector // สร้าง Vector","hash // สร้าง Hash Table","map // ใช้แปลงทุก Element ใน Collection","filter // ใช้กรอง Element ใน Collection","foldl // ใช้ลด (Reduce) Collection จากซ้ายไปขวา","car // คืนค่าสมาชิกแรกของ List","cdr // คืนค่า List ที่เหลือทั้งหมด ยกเว้นสมาชิกแรก","cons // สร้าง Pair หรือเพิ่ม Element เข้าไปใน List","lambda // ใช้สร้าง Anonymous Function","define // ใช้กำหนดตัวแปรหรือฟังก์ชัน","if // คำสั่งเงื่อนไข","cond // คำสั่งเงื่อนไขแบบหลายเงื่อนไข","begin // ใช้จัดกลุ่ม Expression ให้เป็น Block","null? // ตรวจสอบว่าเป็น List ว่างหรือไม่","number? // ตรวจสอบว่าเป็นตัวเลขหรือไม่","string-append // ใช้เชื่อมสตริง"]},"syntax":{"comments (คอมเมนต์)":["; Single-line comment ; คอมเมนต์บรรทัดเดียว","#| Multi-line\\n   comment |# ; คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["(if condition then-expression else-expression) // คำสั่ง if-else (เป็น Expression ที่คืนค่า)","(cond (condition1 expr1) (condition2 expr2) (else default-expr)) // คำสั่ง cond (หลายเงื่อนไข คล้าย if-elseif-else หรือ switch)"],"loops (การวนซ้ำ)":["(for ([i (in-range 5)]) (displayln i)) ; ลูป for (สำหรับช่วงตัวเลข)","(for ([item list-of-items]) (displayln item)) ; ลูป for (สำหรับวนซ้ำ Collection)","(let loop ((i 0)) (when (< i 3) (displayln i) (loop (add1 i)))) ; ลูปแบบ Recursive โดยใช้ Named Let (idiomatic loop)","// การใช้ฟังก์ชัน Higher-Order เช่น map, filter, foldl เป็นวิธีที่นิยมสำหรับการวนซ้ำใน Functional Programming"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, remainder // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, เศษเหลือ (เป็นฟังก์ชันทั้งหมด)","Comparison: =, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ (เป็นฟังก์ชันทั้งหมด)","Logical: and, or, not // ตัวดำเนินการตรรกะ: AND, OR, NOT (เป็นฟังก์ชัน/macro)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else\n(define x 10)\n(if (> x 0)\n    (displayln \"Positive\")\n    (displayln \"Non-positive\"))\n","// ตัวอย่างที่ 2: การใช้วงลูป For Comprehension\n(for ([i (in-range 3)]) \n  (displayln (string-append \"Loop Racket: \" (number->string i))))\n","// ตัวอย่างที่ 3: การใช้ Cond (Conditional Expression)\n(define score 75)\n(cond\n  ((>= score 90) (displayln \"Grade A\"))\n  ((>= score 70) (displayln \"Grade B\"))\n  (else (displayln \"Grade C\")))\n","// ตัวอย่างที่ 4: การทำงานกับ List\n(define my-numbers '(10 20 30))\n(displayln (car my-numbers)) ; 10 (ดึงสมาชิกแรก)\n(displayln (cdr my-numbers)) ; (20 30) (ดึงส่วนที่เหลือ)\n(displayln (cons 5 my-numbers)) ; (5 10 20 30) (สร้าง List ใหม่โดยเพิ่ม 5 เข้าไป)\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\n; ใน Racket มีระบบ Exception Handling ที่คล้ายกับภาษาอื่นๆ\n(require racket/exn)\n(define (divide a b)\n  (if (zero? b)\n      (raise (exn:fail:contract \"division by zero\"))\n      (/ a b)))\n\n(with-handlers\n  ([exn:fail:contract? (lambda (exn) (displayln (string-append \"Caught error: \" (exn-message exn))))])\n  (divide 10 0)) ; จะถูกจับโดย handler\n(displayln \"Program continues after error handling.\")\n","// ตัวอย่างที่ 6: การสร้างภาษาเฉพาะทาง (DSL - Domain Specific Language) (Conceptual)\n; Racket มี Macro System ที่ทรงพลัง ทำให้สามารถสร้าง DSL ได้ง่าย\n; ตัวอย่างเช่น การสร้างภาษาที่คล้าย HTML\n; (define-syntax html\n;   (syntax-rules ()\n;     [(_ tag body ...) `(,tag ,@body)]))\n;\n; (html p \"Hello, World!\") ; จะถูกขยายเป็น '(p \"Hello, World!\")'\n"]}},{"id":43,"name":"ReScript","slug":"rescript","logo":"img/rescript.png","desc":"ReScript คือภาษาโปรแกรมที่คอมไพล์เป็น JavaScript ที่มีประสิทธิภาพสูง ออกแบบมาเพื่อการพัฒนา Web Application ที่เน้นความน่าเชื่อถือ, Type Safety และประสิทธิภาพสูงสุด เป็นทางเลือกที่น่าสนใจสำหรับ JavaScript และ TypeScript โดยใช้ Type Inference ที่ทรงพลังและ Functional Programming","by":"Facebook (พัฒนาต่อจาก ReasonML)","yr":"2020","level":"4","par":["Functional","Imperative","Static-Typed"],"fields":["Frontend"],"rank":"Niche ในตลาดเฉพาะทาง (ยังไม่เป็นที่นิยมในวงกว้าง)","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-110,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["Type System ที่แข็งแกร่งและปลอดภัยสูง","คอมไพล์เป็น JavaScript ที่อ่านง่ายและมีขนาดเล็ก","Fast Compilation Speed (คอมไพล์เร็วมาก)","มี Null Safety ในตัว","Interoperability กับ JavaScript ที่ยอดเยี่ยม","เน้น Functional Programming ช่วยลด Bug"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Functional Programming/ML family languages","ชุมชนนักพัฒนาเล็ก","ขาด Library และ Frameworks ที่หลากหลายเมื่อเทียบกับ JavaScript/TypeScript","เครื่องมือพัฒนาอาจยังไม่สมบูรณ์เท่า","จำเป็นต้องเรียนรู้แนวคิดใหม่ๆ"],"frameworks":["Melange (formerly ReScript React)","ReScript Node.js","Rescript-Relay"],"learn":["ReScript Official Documentation","ReScript Forum","ReScript Playground"],"variables":{"declaration (การประกาศ)":["let x = 10 // การประกาศค่าคงที่ (Immutable by default)","let mutable y = 20 // การประกาศตัวแปรที่เปลี่ยนแปลงได้ (Mutable)"],"types (ประเภท)":["int // จำนวนเต็ม (Mapped to JavaScript Number)","float // ทศนิยม (Mapped to JavaScript Number)","string // ข้อความ (Mapped to JavaScript String)","bool // ค่าตรรกะ (true/false, Mapped to JavaScript Boolean)","array<'a> // Array (เช่น array<int>)","list<'a> // List (Functional List, Immutable)","option<'a> // Optional type (Some('a') or None)","result<'ok, 'error> // Result type (Ok('ok') or Error('error'))","tuple<'a, 'b> // Tuple (กลุ่มของค่าที่มีประเภทต่างกันได้)","record // Record (คล้าย Object/Struct ที่มี Type กำหนดชัดเจน)","variant // Variant (Algebraic Data Types - ADT)"],"examples (ตัวอย่าง)":["let greeting = \"Hello, ReScript!\" // กำหนดค่าคงที่สตริง","let count = 0 // กำหนดตัวแปร mutable integer","let isActive = true // กำหนดค่าคงที่ boolean","let numbers = [1, 2, 3] // สร้าง Array ของ int","let user = {name: \"Alice\", age: 30} // สร้าง Record","let optionalValue = Some(123) // ค่า Optional ที่มีค่า\nlet noValue = None // ค่า Optional ที่ไม่มีค่า"]},"functions":{"declaration (การประกาศ)":["let functionName = (param1: Type, param2: Type): ReturnType => { /* ... */ } // การประกาศฟังก์ชัน","let functionName = (param) => ... // ฟังก์ชันแบบย่อ (ถ้ามีพารามิเตอร์เดียวหรือชัดเจน)","let add = (a, b) => a + b // ฟังก์ชันบวกเลขแบบย่อ"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nlet add = (a: int, b: int): int => { a + b }\n","// ฟังก์ชันทักทาย\nlet greet = (name: string): unit => { Js.log(`Hello, ${name}!`) }\n","// การเรียกใช้ฟังก์ชัน\nlet sum = add(5, 5) // sum จะมีค่า 10\ngreet(\"ReScript User\") // แสดงผล 'Hello, ReScript User!'\n","// ฟังก์ชันที่มี Optional Labelled Arguments\nlet introduce = (~name: string, ~age: int=?, ()): unit => {\n  switch age {\n  | Some(a) => Js.log(`Name: ${name}, Age: ${a}`)\n  | None => Js.log(`Name: ${name}, Age: not provided`)\n  }\n}\nintroduce(~name=\"Bob\") // แสดงผล 'Name: Bob, Age: not provided'\nintroduce(~name=\"Charlie\", ~age=25) // แสดงผล 'Name: Charlie, Age: 25'\n","// Asynchronous Programming (Promises)\n// ReScript ใช้ Promises สำหรับ Asynchronous Programming ซึ่งคอมไพล์ไปเป็น JavaScript Promises\nlet fetchData = (): Promise<string> => {\n  Js.log(\"Fetching data...\")\n  Js.Promise.make((~resolve, ~reject) => {\n    Js.Global.setTimeout(() => {\n      Js.log(\"Data fetched!\")\n      resolve(\"Data from async source\", ())\n    }, 1000)\n  })\n}\n// การเรียกใช้ Async Function\n// fetchData()\n// |> Js.Promise.then_(data => {\n//   Js.log(`Received: ${data}`)\n//   Js.Promise.resolve((), ())\n// })\n// |> ignore\n"],"built_in (ในตัว)":["Js.log() // ใช้แสดงผลข้อมูลออกทาง Console (คอมไพล์เป็น console.log())","Array.map // เมธอดสำหรับวนซ้ำและสร้าง Array ใหม่","String.length // Property สำหรับหาความยาวของสตริง","Option.map // สำหรับแปลงค่าใน Optional","Result.map // สำหรับแปลงค่าใน Result"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition { /* ... */ } else { /* ... */ } // คำสั่ง if-else (เป็น Expression ที่คืนค่า)","switch expression { | Pattern1 => Result1 | Pattern2 => Result2 | _ => DefaultResult } // Pattern Matching ด้วย Switch Expression"],"loops (การวนซ้ำ)":["for i in 0 to 5 { /* ... */ } // ลูป for (สำหรับช่วงตัวเลข)","while condition { /* ... */ } // ลูป while","// โดยทั่วไปจะใช้ Recursive functions หรือ Higher-Order Functions (map, filter) สำหรับการวนซ้ำแบบ Functional","Array.forEach(func, array) // วนซ้ำ Array เพื่อ Side Effect"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, mod // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","-> // Function Arrow (สำหรับฟังก์ชัน)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else as expression)\nlet result = if 10 > 5 { \"Greater\" } else { \"Smaller\" }\nJs.log(result) // แสดงผล 'Greater'\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor i in 0 to 2 { Js.log(`Loop ReScript: ${i}`) } // แสดงผล 'Loop ReScript: 0', 'Loop ReScript: 1', 'Loop ReScript: 2'\n","// ตัวอย่างที่ 3: การใช้ Switch Expression (Pattern Matching)\nlet status = `Success\nswitch status {\n| `Success => Js.log(\"Operation Successful\")\n| `Error => Js.log(\"Operation Failed\")\n| _ => Js.log(\"Unknown Status\") // Wildcard สำหรับค่าอื่นๆ\n}\n","// ตัวอย่างที่ 4: การใช้งาน Record และ Variant (Type Safety)\ntype user = { id: int, name: string }\ntype response = | Success(user) | NotFound | ServerError(int)\n\nlet fetchUser = (userId: int): response => {\n  if userId == 1 then Success({id: 1, name: \"Jane\"})\n  else if userId == 2 then NotFound\n  else ServerError(500)\n}\n\nlet userResponse = fetchUser(1)\nswitch userResponse {\n| Success(u) => Js.log(`User found: ${u.name}`)\n| NotFound => Js.log(\"User not found\")\n| ServerError(code) => Js.log(`Server error: ${code}`)\n}\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาดด้วย Option และ Result Types\nlet safeDivide = (a: int, b: int): option<int> => {\n  if b == 0 then None else Some(a / b)\n}\n\nswitch safeDivide(10, 2) {\n| Some(value) => Js.log(`Result: ${value}`)\n| None => Js.log(\"Cannot divide by zero\")\n}\n\nswitch safeDivide(10, 0) {\n| Some(value) => Js.log(`Result: ${value}`)\n| None => Js.log(\"Cannot divide by zero\")\n}\n","// ตัวอย่างที่ 6: Pipe Operator (|>)\n// Pipe operator ช่วยให้อ่านโค้ดได้ง่ายขึ้น โดยส่งผลลัพธ์จากฟังก์ชันหนึ่งไปยังอีกฟังก์ชันหนึ่ง\nlet addOne = (x: int) => x + 1\nlet double = (x: int) => x * 2\n\nlet finalResult = 5\n|> addOne\n|> double\n|> Js.log // (5 + 1) * 2 = 12\n"]}},{"id":11,"name":"Ruby","slug":"ruby","logo":"img/ruby.png","desc":"Ruby เป็นภาษาโปรแกรม Dynamic, Object-Oriented ที่เน้นความเรียบง่ายและ Productivitiy สูง โดยเฉพาะอย่างยิ่งเมื่อใช้ร่วมกับ Ruby on Rails Framework ซึ่งเป็นที่นิยมในการสร้าง Web Application","by":"Yukihiro Matsumoto","yr":"1995","level":"4","par":["Object-Oriented","Imperative","Functional","Reflective"],"fields":["Backend","Script","Testing"],"rank":"14 และลดลงต่อเนื่อง (2.1% ใน TIOBE)","salary_range":"฿35,000-55,000 บาท/เดือน (Junior), ฿55,000-95,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["Syntax สวยงามและอ่านง่าย","มี Ruby on Rails Framework ที่ทรงพลังสำหรับการพัฒนาเว็บ","มีชุมชนที่กระตือรือร้น","การพัฒนาที่รวดเร็ว (Rapid Development)","เน้นความเป็น Object-Oriented"],"cons":["ประสิทธิภาพอาจไม่สูงเท่าภาษาอื่นๆ สำหรับงานที่ต้องใช้ความเร็วสูง","Learning Curve ของ Rails Framework อาจสูงสำหรับผู้เริ่มต้น","ทรัพยากรสำหรับการเรียนรู้ภาษา Ruby อย่างเดียวอาจน้อยกว่าภาษาอื่น","อาจมีปัญหาเรื่อง Scaling ในบางกรณี"],"frameworks":["Ruby on Rails","Sinatra"],"learn":["Ruby-Doc.org","Ruby Guides","Learn Ruby the Hard Way","Codecademy: Learn Ruby"],"variables":{"declaration (การประกาศ)":["name = \"Alice\" // ตัวแปร Local","@instance_var = 10 // ตัวแปร Instance (ของ Object)","@@class_var = 20 // ตัวแปร Class (ของ Class)","$global_var = 30 // ตัวแปร Global"],"types (ประเภท)":["String // ประเภทข้อมูลข้อความ","Integer // ประเภทข้อมูลตัวเลขจำนวนเต็ม","Float // ประเภทข้อมูลตัวเลขทศนิยม","Boolean // ประเภทข้อมูลค่าจริงหรือเท็จ (true/false)","Array // ประเภทข้อมูลสำหรับเก็บข้อมูลหลายค่าในลำดับ","Hash // ประเภทข้อมูลสำหรับ Key-Value Pairs (คล้าย Dictionary/Map)","Symbol // ประเภทข้อมูลสำหรับ Identifier ที่ไม่เปลี่ยนแปลง (ประสิทธิภาพสูง)","NilClass // ประเภทข้อมูลสำหรับค่าว่างเปล่า (nil)"],"examples (ตัวอย่าง)":["product = \"Book\" // กำหนดตัวแปร product เป็นสตริง","quantity = 5 // กำหนดตัวแปร quantity เป็นตัวเลข","is_available = true # กำหนดตัวแปร is_available เป็น Boolean","colors = ['red', 'green', 'blue'] # กำหนด Array","user_data = { name: 'Bob', age: 25 } # กำหนด Hash",":my_symbol # ตัวอย่าง Symbol"]},"functions":{"declaration (การประกาศ)":["def method_name(param1, param2)\n  # ...\nend // การประกาศเมธอด (ฟังก์ชัน) แบบปกติ","lambda { |param| ... } // Lambda expression (ฟังก์ชันนิรนาม)","->(param) { ... } // Lambda expression แบบย่อ"],"examples (ตัวอย่าง)":["// เมธอด (ฟังก์ชัน) ทักทาย\ndef greet(name)\n  \"Hello, \\#{name}!\"\nend\n","// เมธอด (ฟังก์ชัน) บวกเลขสองจำนวน\ndef add(a, b)\n  a + b\nend\n","// การเรียกใช้เมธอด (ฟังก์ชัน)\nmessage = greet(\"Ruby\") # message จะมีค่า 'Hello, Ruby!'\nsum = add(10, 15) # sum จะมีค่า 25\n","// เมธอดที่มี Optional Parameter และ Default Value\ndef describe_item(item, price = nil)\n  if price\n    \"\\#{item} costs \\#{price} baht.\"\n  else\n    \"\\#{item} is available.\"\n  end\nend\nputs describe_item(\"Apple\") # Apple is available.\nputs describe_item(\"Laptop\", 35000) # Laptop costs 35000 baht.\n","// เมธอดที่คืนค่าหลายค่า (ด้วย Array)\ndef get_user_details()\n  ['Jane Doe', 28, 'jane@example.com']\nend\nname, age, email = get_user_details()\nputs \"User: \\#{name}, Age: \\#{age}\"\n","// Asynchronous Programming ใน Ruby (แนวคิด)\n// Ruby ไม่ได้มี Asynchronous I/O ในตัวแบบ C#/Go แต่สามารถทำได้ด้วย Gems/Libraries เช่น Celluloid, EventMachine หรือ Fibers (ใน Ruby 3.0+)\n// ตัวอย่างนี้แสดงการใช้งาน Fibers ซึ่งช่วยให้เขียนโค้ด Asynchronous ได้ง่ายขึ้น\n/*\nrequire 'fiber'\n\ndef long_running_task(name)\n  puts \"\\#{name}: Starting long task...\"\n  Fiber.yield # หยุดการทำงานชั่วคราวและส่งการควบคุมคืน\n  puts \"\\#{name}: Resumed and finished!\"\nend\n\nmain_fiber = Fiber.new do\n  puts \"Main: Starting.\"\n  long_running_task(\"Task 1\")\n  puts \"Main: After Task 1.\"\n  long_running_task(\"Task 2\")\n  puts \"Main: After Task 2.\"\n  puts \"Main: Done.\"\nend\n\nmain_fiber.resume # เริ่มทำงาน Fiber หลัก\nputs \"Outside: Still running!\"\nmain_fiber.resume # กลับมาทำงาน Fiber หลักต่อ\nputs \"Outside: More work.\"\nmain_fiber.resume # กลับมาทำงาน Fiber หลักต่ออีกครั้ง\n*/"],"built_in (ในตัว)":["puts // ใช้แสดงผลข้อมูลออกทาง Console (เพิ่มบรรทัดใหม่)","print // ใช้แสดงผลข้อมูลออกทาง Console (ไม่เพิ่มบรรทัดใหม่)","gets // ใช้รับข้อมูลจากผู้ใช้งาน","length // เมธอดสำหรับหาความยาวของ String หรือ Array","each // เมธอดสำหรับวนซ้ำสมาชิกใน Collection","map // เมธอดสำหรับวนซ้ำและสร้าง Array ใหม่","require // ใช้สำหรับโหลดไฟล์ Ruby หรือ Gems อื่นๆ"]},"syntax":{"comments (คอมเมนต์)":["# Single line comment // คอมเมนต์บรรทัดเดียว","=begin\nMulti-line\ncomment\n=end // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition\n  # ...\nelsif another_condition\n  # ...\nelse\n  # ...\nend // คำสั่ง if-elsif-else","case expression\nwhen value1 then # ...\nwhen value2 then # ...\nelse # ...\nend // คำสั่ง case (คล้าย switch)"],"loops (การวนซ้ำ)":["for item in collection do\n  # ...\nend // ลูป for (ไม่ค่อยนิยมใน Ruby)","while condition do\n  # ...\nend // ลูป while","loop do\n  # ...\n  break if condition # ออกจากลูป\nend // Infinite loop (ลูปไม่รู้จบ) พร้อมเงื่อนไขออก","collection.each { |item| # ... } // Iterator 'each' สำหรับวนซ้ำ Array/Hash (นิยมใช้)","collection.map { |item| # ... } // Iterator 'map' สำหรับสร้าง Array ใหม่จากการแปลงค่า"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <=, <=> // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ ( <=> คือ Spaceship operator)","Logical: && (and), || (or), ! (not) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่",". // Dot operator (เรียกใช้เมธอด)",":: // Scope Resolution operator (เข้าถึงค่าคงที่หรือเมธอดของ Class/Module)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nage = 22\nif age >= 18\n  puts \"Adult\"\nelsif age >= 13\n  puts \"Teenager\"\nelse\n  puts \"Child\"\nend\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) กับ Range\nfor i in 0..2 # Range รวมถึงค่าสุดท้าย\n  puts \"Loop Ruby: \\#{i}\"\nend\n","// ตัวอย่างที่ 3: การใช้ Case Statement (คล้าย Switch)\nstatus = 'active'\ncase status\nwhen 'active'\n  puts \"User is active.\"\nwhen 'inactive'\n  puts \"User is inactive.\"\nelse\n  puts \"Unknown status.\"\nend\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Object-Oriented Programming (OOP)\nclass Animal\n  attr_accessor :name, :species\n\n  def initialize(name, species)\n    @name = name\n    @species = species\n  end\n\n  def make_sound\n    puts \"\\#{name} makes a sound.\"\n  end\nend\n\nclass Dog < Animal # สืบทอดมาจาก Animal\n  def initialize(name)\n    super(name, \"Dog\") # เรียก constructor ของ parent class\n  end\n\n  def make_sound\n    puts \"\\#{name} says Woof!\"\n  end\nend\n\nmy_dog = Dog.new(\"Buddy\") # สร้าง Object\nmy_dog.make_sound # Buddy says Woof!\nputs my_dog.species # Dog\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling) ด้วย Begin-Rescue-Ensure\nbegin\n  result = 10 / 0 # จะเกิด ZeroDivisionError\n  puts \"Result: \\#{result}\"\nrescue ZeroDivisionError => e\n  puts \"Error: \\#{e.message}\"\nrescue => e # ดักจับ Error อื่นๆ ทั้งหมด\n  puts \"An unexpected error occurred: \\#{e.message}\"\nensure\n  puts \"Execution finished.\"\nend\n","// ตัวอย่างที่ 6: การทำงานกับ Array และ Hash\nfruits = ['Apple', 'Banana', 'Cherry']\nputs \"My favorite fruits:\"\nfruits.each do |fruit|\n  puts \"- \\#{fruit}\"\nend\n\nstudent_grades = { 'Alice' => 'A', 'Bob' => 'B' }\nputs \"Student grades:\"\nstudent_grades.each do |name, grade|\n  puts \"\\#{name} got a grade of \\#{grade}\"\nend\n"]}},{"id":8,"name":"Rust","slug":"rust","logo":"img/rust.png","desc":"Rust เป็นภาษาโปรแกรมที่เน้นความปลอดภัยของหน่วยความจำ, ความเร็ว และ Concurrency โดยไม่ใช้ Garbage Collector เหมาะสำหรับ System programming, WebAssembly, และ Blockchain","by":"Mozilla Research","yr":"2010","level":"2","par":["Multi-paradigm","Functional","Imperative","Concurrent"],"fields":["System","Compiler","Security","Security","Cloud","Robot","Network","Tele","Game","Distributed","HPC","Aero","Blockchain","Graphics"],"rank":"15 ใน TIOBE แต่เป็น Most Loved Language (84.9% ของนักพัฒนาชอบ)","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-110,000 บาท/เดือน (Senior)","salary":["low","mid","high","veryhigh"],"pros":["ความปลอดภัยของหน่วยความจำ (Memory Safety) โดยไม่มี GC","ประสิทธิภาพสูงมาก","รองรับ Concurrency ได้อย่างปลอดภัย","ระบบ Type ที่แข็งแกร่ง (Strong Type System)","มีเครื่องมือจัดการแพ็คเกจที่ดี (Cargo)"],"cons":["Learning Curve สูงมาก (โดยเฉพาะเรื่อง Borrowing และ Lifetimes)","เวลาในการคอมไพล์ค่อนข้างนาน","Syntax อาจจะซับซ้อนสำหรับผู้เริ่มต้น","ชุมชนยังเล็กกว่าภาษาหลักๆ"],"frameworks":["Actix Web","Rocket","Yew (WebAssembly)"],"learn":["The Rust Programming Language Book","Rustlings","Rust by Example","Ferris' Guide"],"variables":{"declaration (การประกาศ)":["let x = 5; // Immutable by default (ค่าไม่สามารถเปลี่ยนแปลงได้โดยค่าเริ่มต้น)","let mut y = 10; // Mutable variable (ตัวแปรที่สามารถเปลี่ยนแปลงค่าได้)"],"types (ประเภท)":["i8 // จำนวนเต็ม 8 บิต (มีเครื่องหมาย)","i16 // จำนวนเต็ม 16 บิต (มีเครื่องหมาย)","i32 // จำนวนเต็ม 32 บิต (มีเครื่องหมาย)","i64 // จำนวนเต็ม 64 บิต (มีเครื่องหมาย)","i128 // จำนวนเต็ม 128 บิต (มีเครื่องหมาย)","isize // จำนวนเต็มที่มีขนาดเท่ากับ Pointer (มีเครื่องหมาย)","u8 // จำนวนเต็ม 8 บิต (ไม่มีเครื่องหมาย)","u16 // จำนวนเต็ม 16 บิต (ไม่มีเครื่องหมาย)","u32 // จำนวนเต็ม 32 บิต (ไม่มีเครื่องหมาย)","u64 // จำนวนเต็ม 64 บิต (ไม่มีเครื่องหมาย)","u128 // จำนวนเต็ม 128 บิต (ไม่มีเครื่องหมาย)","usize // จำนวนเต็มที่มีขนาดเท่ากับ Pointer (ไม่มีเครื่องหมาย)","f32 // ทศนิยมความแม่นยำเดี่ยว","f64 // ทศนิยมความแม่นยำคู่","bool // ค่าความจริง (true/false)","char // ตัวอักขระ (Unicode Scalar Value)","tuple // กลุ่มของค่าที่มีประเภทต่างกันได้","array // อาร์เรย์ (ขนาดคงที่)","slice // มุมมองของข้อมูลในอาร์เรย์ (อ้างอิง)","struct // โครงสร้างข้อมูลที่กำหนดเอง","enum // ประเภทข้อมูลที่สามารถเป็นหนึ่งในหลายๆ ค่าที่กำหนดไว้"],"examples (ตัวอย่าง)":["let age = 30; // ตัวแปร age (ค่าเปลี่ยนไม่ได้)","let mut count = 0; // ตัวแปร count (ค่าเปลี่ยนได้)","let greeting = \"Hello, Rust!\"; // ตัวแปร greeting เก็บสตริง","let numbers: [i32; 5] = [1, 2, 3, 4, 5]; // การประกาศอาร์เรย์ขนาดคงที่","let prices = vec![10.5, 20.0, 30.25]; // การประกาศ Vector (Dynamic Array)","let coordinates = (10, 20.5, 'Z'); // การประกาศ Tuple","struct Point { x: i32, y: i32 }; // การประกาศ Struct\nlet origin = Point { x: 0, y: 0 }; // การสร้าง instance ของ Struct"]},"functions":{"declaration (การประกาศ)":["fn function_name(param: Type) -> ReturnType { /* ... */ } // การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfn add(a: i32, b: i32) -> i32 {\n  a + b // Rust คืนค่าสุดท้ายโดยไม่ต้องใช้ 'return' ถ้าไม่มี semicolon\n}\n","// ฟังก์ชันทักทาย\nfn greet(name: &str) {\n  println!(\"Hello, {}\", name); // 'println!' เป็น Macro ใน Rust\n}\n","// การเรียกใช้ฟังก์ชัน\nlet sum = add(5, 5); // sum จะมีค่า 10\ngreet(\"World\"); // แสดงผล 'Hello, World!'\n","// ฟังก์ชันที่คืนค่าหลายค่า (Tuple)\nfn divide_and_remainder(dividend: i32, divisor: i32) -> (i32, i32) {\n  (dividend / divisor, dividend % divisor)\n}\nlet (quotient, remainder) = divide_and_remainder(10, 3); // quotient = 3, remainder = 1\n","// เมธอดบน Struct (Method on Struct)\nstruct Rectangle {\n  width: u32,\n  height: u32,\n}\nimpl Rectangle {\n  fn area(&self) -> u32 { // เมธอดที่รับ immutable reference ของ self\n    self.width * self.height\n  }\n  fn can_hold(&self, other: &Rectangle) -> bool {\n    self.width > other.width && self.height > other.height\n  }\n}\nlet rect1 = Rectangle { width: 30, height: 50 };\nlet rect2 = Rectangle { width: 10, height: 40 };\nprintln!(\"Area of rect1: {}\", rect1.area()); // Area of rect1: 1500\nprintln!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2)); // true\n","// ฟังก์ชัน Generic (ใช้ Type Parameter)\nfn largest<T: PartialOrd + Copy>(list: &[T]) -> T {\n  let mut largest = list[0];\n  for &item in list.iter() {\n    if item > largest {\n      largest = item;\n    }\n  }\n  largest\n}\nlet number_list = vec![34, 50, 25, 100, 65];\nprintln!(\"Largest number: {}\", largest(&number_list)); // Largest number: 100\n","// Asynchronous Programming (Concurrency) ด้วย Tokio/Async-Std\n// Rust จัดการ Concurrency ผ่าน Async/Await และ Executor เช่น Tokio หรือ Async-Std\n// โค้ดด้านล่างนี้เป็นตัวอย่างที่ต้องรันในบริบทของ Async Runtime\n// use tokio::time::{sleep, Duration};\n// async fn fetch_data() -> String {\n//   println!(\"Fetching data...\");\n//   sleep(Duration::from_secs(1)).await; // จำลองการหน่วงเวลา\n//   println!(\"Data fetched!\");\n//   \"Data from async source\".to_string()\n// }\n// async fn main() {\n//   let data = fetch_data().await;\n//   println!(\"Received: {}\", data);\n// }\n// // ต้องรันด้วย: tokio::main (สำหรับ Tokio runtime)\n// // #[tokio::main]\n// // async fn main() { /* ... */ }"],"built_in (ในตัว)":["println!() // Macro สำหรับแสดงผลข้อมูลออกทาง Console","vec![] // Macro สำหรับสร้าง Vector (Dynamic Array)","Option<T> // Enum สำหรับค่าที่อาจจะมีหรือไม่มี (Some(T) หรือ None)","Result<T, E> // Enum สำหรับการจัดการข้อผิดพลาด (Ok(T) หรือ Err(E))","String::from() // ใช้สร้าง String จาก string literal"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition { /* ... */ } else if condition { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","match expression { /* ... */ } // คำสั่ง match (คล้าย switch แต่มีประสิทธิภาพกว่า)"],"loops (การวนซ้ำ)":["loop { /* ... */ } // Infinite loop (ลูปไม่รู้จบ)","while condition { /* ... */ } // ลูป while","for item in collection { /* ... */ } // ลูป for สำหรับวนซ้ำ collection (เช่น Range, Vector)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ",". // Accessor (เข้าถึงสมาชิกของ Struct/Enum)",":: // Path Separator (เข้าถึงไอเท็มใน Module/Crate)","-> // Return Type Arrow (ระบุประเภทค่าที่คืนกลับ)","& // Reference (การยืม)","&mut // Mutable Reference (การยืมแบบแก้ไขได้)","* // Dereference (เข้าถึงค่าที่ Reference ชี้ไป)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nfn main() {\n  let num = 10;\n  if num > 5 {\n    println!(\"Num is greater than 5\");\n  } else {\n    println!(\"Num is not greater than 5\");\n  }\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) และ Range\nfn main() {\n  for i in 0..3 { // Range ไม่รวมค่าสุดท้าย (0, 1, 2)\n    println!(\"Loop Rust: {}\", i);\n  }\n  for i in 0..=3 { // Range รวมถึงค่าสุดท้าย (0, 1, 2, 3)\n    println!(\"Loop inclusive Rust: {}\", i);\n  }\n}\n","// ตัวอย่างที่ 3: การใช้ Match Statement (Powerful Pattern Matching)\nfn main() {\n  let code = 200;\n  match code {\n    200 => println!(\"OK\"),\n    404 => println!(\"Not Found\"),\n    _ => println!(\"Unknown Code\"), // _ คือ Wildcard สำหรับค่าอื่นๆ ที่ไม่ได้ระบุ\n  }\n}\n","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาดด้วย Result (Error Handling)\nfn divide(dividend: f64, divisor: f64) -> Result<f64, String> {\n  if divisor == 0.0 {\n    Err(String::from(\"Cannot divide by zero\"))\n  } else {\n    Ok(dividend / divisor)\n  }\n}\nfn main() {\n  match divide(10.0, 2.0) {\n    Ok(value) => println!(\"Result: {}\", value),\n    Err(error) => println!(\"Error: {}\", error),\n  }\n  match divide(10.0, 0.0) {\n    Ok(value) => println!(\"Result: {}\", value),\n    Err(error) => println!(\"Error: {}\", error),\n  }\n}\n","// ตัวอย่างที่ 5: Ownership และ Borrowing\nfn takes_ownership(some_string: String) { // some_string เข้ามาอยู่ใน Ownership\n  println!(\"{}\", some_string);\n} // some_string ถูก Drop (หน่วยความจำถูกคืน)\n\nfn takes_and_gives_back(a_string: String) -> String { // รับ Ownership และคืนกลับ\n  a_string\n}\n\nfn calculates_length(s: &String) -> usize { // ยืม (Borrow) ค่า String แบบ Immutable\n  s.len()\n}\nfn change_string(some_string: &mut String) { // ยืม (Borrow) ค่า String แบบ Mutable\n  some_string.push_str(\", world!\");\n}\nfn main() {\n  let s1 = String::from(\"hello\");\n  takes_ownership(s1); // s1 ถูกย้าย Ownership ไปแล้ว ไม่สามารถใช้ s1 ได้อีก\n  // println!(\"{}\", s1); // จะเกิด compile error\n\n  let s2 = String::from(\"hello\");\n  let s3 = takes_and_gives_back(s2); // s2 ถูกย้ายไป s3 แต่ S3 ยังใช้งานได้\n  println!(\"{}\", s3);\n\n  let s4 = String::from(\"hello\");\n  let len = calculates_length(&s4); // s4 ถูกยืม (Borrowed) ไม่ได้ถูกย้าย\n  println!(\"The length of '{}' is {}.\", s4, len);\n\n  let mut s5 = String::from(\"hello\");\n  change_string(&mut s5); // s5 ถูกยืมแบบ Mutable\n  println!(\"{}\", s5); // hello, world!\n}"]}},{"id":17,"name":"Scala","slug":"scala","logo":"img/scala.png","desc":"Scala เป็นภาษาโปรแกรม Multi-paradigm ที่ทำงานบน JVM (Java Virtual Machine) ผสมผสานคุณสมบัติของ Object-Oriented และ Functional Programming ได้อย่างลงตัว เหมาะสำหรับ Big Data, Web Backend และ Distributed Systems","by":"Martin Odersky","yr":"2004","level":"3","par":["Object-Oriented","Functional","Concurrent"],"fields":["Backend","Data","Finance","Distributed"],"rank":"20-25 แข็งแกร่งใน Big Data (2.1% แต่เงินเดือนสูง)","salary_range":"฿45,000-70,000 บาท/เดือน (Junior), ฿70,000-125,000 บาท/เดือน (Senior)","salary":["low","mid","high","veryhigh"],"pros":["ทำงานร่วมกับ Java ได้ดีเยี่ยม","รองรับ Functional Programming ที่ทรงพลัง","เหมาะสำหรับ Big Data ด้วย Apache Spark","มี Type System ที่ยืดหยุ่นและปลอดภัย","สามารถเขียนโค้ดที่กระชับและแสดงออกได้ดี"],"cons":["Learning Curve สูงมาก","เวลาในการคอมไพล์ค่อนข้างนาน","Error Messages อาจเข้าใจยากสำหรับผู้เริ่มต้น","Syntax ที่ซับซ้อนและหลายรูปแบบ","ชุมชนนักพัฒนาอาจเล็กกว่าภาษาหลัก"],"frameworks":["Play Framework","Akka","Apache Spark"],"learn":["Scala Documentation","Scala Book","Coursera: Functional Programming in Scala","Rock the JVM"],"variables":{"declaration (การประกาศ)":["val name: String = \"Scala\"; // ค่าคงที่ (Immutable)","var age: Int = 10; // ตัวแปรที่เปลี่ยนแปลงได้ (Mutable)"],"types (ประเภท)":["Int // จำนวนเต็ม","Long // จำนวนเต็มขนาดใหญ่","Float // ทศนิยมความแม่นยำเดี่ยว","Double // ทศนิยมความแม่นยำคู่","Boolean // ค่าจริงหรือเท็จ (true/false)","Char // ตัวอักขระ","String // ข้อความ","List[T] // รายการ (Immutable)","Vector[T] // Vector (Immutable, มีประสิทธิภาพในการเข้าถึง Random)","Map[K, V] // แผนที่ (Key-Value pairs, Immutable)","Set[T] // เซต (ชุดของค่าที่ไม่ซ้ำกัน, Immutable)","Option[T] // ประเภทข้อมูลที่อาจมีค่าหรือไม่ก็ได้ (Some(T) หรือ None)","Unit // ประเภทที่ไม่มีค่าคืนกลับ (คล้าย void ใน Java)"],"examples (ตัวอย่าง)":["val message = \"Hello Scala!\" // กำหนดค่าคงที่ message เป็นสตริง","var counter = 0 // กำหนดตัวแปร counter เป็นตัวเลข","val pi = 3.14159 // กำหนดค่าคงที่ pi เป็น Double (Type Inference)","val numbers = List(1, 2, 3) // กำหนด List ของตัวเลข","var mutableList = scala.collection.mutable.ListBuffer(\"apple\", \"banana\") // กำหนด Mutable List","val userMap = Map(\"name\" -> \"Alice\", \"age\" -> 25) // กำหนด Map"]},"functions":{"declaration (การประกาศ)":["def functionName(param: Type): ReturnType = { /* ... */ } // การประกาศฟังก์ชัน/เมธอด","(param: Type) => expression // Anonymous function / Lambda (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\ndef add(a: Int, b: Int): Int = a + b\n","// ฟังก์ชันทักทาย\ndef greet(name: String): Unit = println(s\"Hello, $name!\")\n","// การเรียกใช้ฟังก์ชัน\nval total = add(10, 10) // total จะมีค่า 20\ngreet(\"Spark\") // แสดงผล 'Hello, Spark!'\n","// ฟังก์ชันที่มี Default Arguments และ Named Arguments\ndef calculateVolume(length: Int, width: Int = 1, height: Int = 1): Int = {\n  length * width * height\n}\nprintln(calculateVolume(10)) // 10\nprintln(calculateVolume(10, height = 5)) // 50 (ใช้ Named Arguments)\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\ndef operate(a: Int, b: Int, operation: (Int, Int) => Int): Int = {\n  operation(a, b)\n}\nval result = operate(5, 3, (x, y) => x * y) // Result: 15\nprintln(s\"Operate Result: $result\")\n","// Curried Function (ฟังก์ชันที่รับ Argument ทีละชุด)\ndef sumCurried(x: Int)(y: Int): Int = x + y\nval addFive = sumCurried(5)_ // Partial Application\nprintln(s\"Curried Sum: ${addFive(10)}\") // Curried Sum: 15\n","// Asynchronous Programming (Futures)\n// Scala จัดการ Asynchronous Programming ด้วย Futures ซึ่งเป็น Immutable Object ที่แสดงถึงผลลัพธ์ของการคำนวณที่อาจจะยังไม่เสร็จสิ้น\n// ต้องมีการ import และใช้งาน ExecutionContext\n// import scala.concurrent.{Future, Await}\n// import scala.concurrent.ExecutionContext.Implicits.global\n// import scala.concurrent.duration._\n//\n// def fetchData(): Future[String] = Future {\n//   println(\"Fetching data...\")\n//   Thread.sleep(1000) // จำลองการหน่วงเวลา 1 วินาที\n//   println(\"Data fetched!\")\n//   \"Data fetched asynchronously\"\n// }\n//\n// // ตัวอย่างการเรียกใช้ Future และรอผลลัพธ์\n// val futureResult: Future[String] = fetchData()\n// println(\"Main thread continues...\")\n// // บล็อกการทำงานของ Main thread ชั่วคราวเพื่อรอผลลัพธ์ (ไม่แนะนำใน Production)\n// val result = Await.result(futureResult, 2.seconds)\n// println(s\"Received: $result\")"],"built_in (ในตัว)":["println() // ใช้แสดงผลข้อมูลออกทาง Console","List() // ใช้สร้าง List (Immutable)","Map() // ใช้สร้าง Map (Immutable)","Option // ใช้จัดการค่าที่อาจมีหรือไม่มี (Some/None)","Try // ใช้จัดการผลลัพธ์ที่อาจสำเร็จหรือล้มเหลว (Success/Failure)","Future // ใช้จัดการการคำนวณแบบ Asynchronous","filter() // เมธอดสำหรับกรองข้อมูลใน Collection","map() // เมธอดสำหรับแปลงข้อมูลใน Collection","reduce() // เมธอดสำหรับรวมข้อมูลใน Collection","foreach() // เมธอดสำหรับวนซ้ำ Collection"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","match expression { case value => /* ... */ case _ => /* ... */ } // คำสั่ง match (Pattern Matching) ที่ทรงพลัง"],"loops (การวนซ้ำ)":["for (i <- 1 to 5) { /* ... */ } // ลูป for-in สำหรับ Range (รวมค่าสุดท้าย)","for (i <- 0 until 3) { /* ... */ } // ลูป for-in สำหรับ Range (ไม่รวมค่าสุดท้าย)","while (condition) { /* ... */ } // ลูป while","// Scala ไม่มี do-while loop โดยตรง แต่สามารถเลียนแบบได้ด้วย while true { ... if (condition) break }","collection.foreach { item => /* ... */ } // เมธอด foreach สำหรับวนซ้ำ Collection (นิยมใช้ใน Functional Style)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","-> // ใช้สำหรับ Key-Value pairs ใน Map (e.g., \"key\" -> value)","<- // Generator Arrow ใน for-comprehensions",":: // Cons operator (สำหรับเพิ่ม Element เข้าไปใน List)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) และ If as Expression\nval temperature = 28\nval message = if (temperature > 30) {\n  \"Hot\"\n} else if (temperature < 10) {\n  \"Cold\"\n} else {\n  \"Normal\"\n}\nprintln(message) // แสดงผล 'Normal'\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) และ String Interpolation\nfor (i <- 0 until 3) {\n  println(s\"Loop Scala: $i\")\n}\n","// ตัวอย่างที่ 3: การใช้ Match Expression (Pattern Matching)\nval status = \"success\"\nval result = status match {\n  case \"success\" => \"Operation Successful\"\n  case \"error\" => \"Operation Failed\"\n  case _ => \"Unknown Status\" // Wildcard สำหรับค่าอื่นๆ ที่ไม่ได้ระบุ\n}\nprintln(result) // แสดงผล 'Operation Successful'\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Object-Oriented Programming (OOP)\nclass Dog(val name: String, var age: Int) { // Primary Constructor\n  def bark(): Unit = {\n    println(s\"$name says Woof!\")\n  }\n}\n// สร้าง Object จากคลาส Dog\nval myDog = new Dog(\"Buddy\", 3)\nmyDog.bark() // แสดงผล 'Buddy says Woof!'\nprintln(s\"Dog's age: ${myDog.age}\")\nmyDog.age = 4 // เปลี่ยนแปลงค่า age เพราะเป็น var\n\ntrait Greeter { // Trait (คล้าย Interface ใน Java)\n  def greet(name: String): Unit\n}\nclass EnglishGreeter extends Greeter { // Implement Trait\n  override def greet(name: String): Unit = {\n    println(s\"Hello, $name!\")\n  }\n}\nval greeter: Greeter = new EnglishGreeter()\ngreeter.greet(\"World\") // Hello, World!\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling) ด้วย Try-Catch-Finally\nimport scala.util.{Try, Success, Failure}\n\ndef divide(a: Int, b: Int): Try[Int] = Try {\n  a / b\n}\n\n// การใช้งาน Try\ndivide(10, 2) match {\n  case Success(value) => println(s\"Result: $value\")\n  case Failure(exception) => println(s\"Error: ${exception.getMessage}\")\n}\ndivide(10, 0) match {\n  case Success(value) => println(s\"Result: $value\")\n  case Failure(exception) => println(s\"Error: ${exception.getMessage}\")\n}\n\n// ตัวอย่าง Try-Catch-Finally แบบ Block\ntry {\n  val x = 10 / 0 // จะเกิด ArithmeticException\n  println(x)\n} catch {\n  case e: ArithmeticException => println(s\"Caught an error: ${e.getMessage}\")\n  case e: Exception => println(s\"An unexpected error occurred: ${e.getMessage}\")\n} finally {\n  println(\"Execution finished.\")\n}\n","// ตัวอย่างที่ 6: การทำงานกับ Collections (List, Map) และ Functional Methods\nval fruits = List(\"Apple\", \"Banana\", \"Cherry\") // Immutable List\nprintln(s\"Fruits: $fruits\")\nval filteredFruits = fruits.filter(_.length > 5) // กรองคำที่ยาวกว่า 5 ตัวอักษร\nprintln(s\"Filtered fruits: $filteredFruits\") // List(Banana, Cherry)\n\nval upperFruits = fruits.map(_.toUpperCase) // แปลงเป็นตัวพิมพ์ใหญ่\nprintln(s\"Upper fruits: $upperFruits\") // List(APPLE, BANANA, CHERRY)\n\nval userMap = Map(\"name\" -> \"John\", \"age\" -> 30) // Immutable Map\nprintln(s\"User Map: $userMap\")\nval ageOption = userMap.get(\"age\") // ได้ Option[Int]\nageOption.foreach(age => println(s\"User age: $age\")) // User age: 30\n"]}},{"id":32,"name":"Scheme","slug":"scheme","logo":"img/scheme.png","desc":"Scheme เป็นภาษาโปรแกรม Functional Programming ในตระกูล Lisp ที่เน้นความเรียบง่าย (Minimalism) และความสอดคล้องทางทฤษฎี (Theoretical Consistency) เป็นอย่างสูง ถูกใช้ในการศึกษาด้านวิทยาการคอมพิวเตอร์, การวิจัย และการพัฒนาแอปพลิเคชันที่ต้องการความยืดหยุ่นสูงและการจัดการโค้ดในฐานะข้อมูล (Code as Data)","by":"Guy L. Steele Jr. and Gerald Jay Sussman","yr":"1975","level":"3","par":["Functional","Procedural","Reflective","Metaprogramming"],"fields":["Edu","Compiler"],"rank":"45+ Niche ใน Education และ Computer Science Research","salary_range":"฿24,000-40,000 บาท/เดือน (Junior), ฿40,000-68,000 บาท/เดือน (Senior)","salary":["n/a"],"pros":["ไวยากรณ์ที่เรียบง่ายและสอดคล้อง (S-expressions)","รองรับ Functional Programming อย่างเต็มที่","ความสามารถในการ Meta-programming สูง (Macro System)","เหมาะสำหรับการเรียนรู้แนวคิดพื้นฐานของวิทยาการคอมพิวเตอร์","มีระบบ Continuations ที่ทรงพลัง"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับ Lisp หรือ Functional Programming","ไวยากรณ์วงเล็บ (Parentheses) อาจดูสับสนสำหรับผู้เริ่มต้น","ชุมชนนักพัฒนาและ Library เล็กกว่าภาษาหลัก","ไม่เหมาะกับแอปพลิเคชันเชิงพาณิชย์ขนาดใหญ่โดยตรง","ประสิทธิภาพอาจไม่ดีเท่าภาษาที่คอมไพล์แบบ Native"],"frameworks":[],"learn":["SICP (Structure and Interpretation of Computer Programs)","Racket (dialect of Scheme)","Scheme R7RS"],"variables":{"declaration (การประกาศ)":["(define variable-name value) ; การประกาศตัวแปร/ค่าคงที่"],"types (ประเภท)":["Numbers (integers, reals, complex) // ตัวเลข (จำนวนเต็ม, ทศนิยม, จำนวนเชิงซ้อน)","Booleans (#t, #f) // ค่าความจริง (#t = true, #f = false)","Characters // ตัวอักขระ","Strings // ข้อความ","Symbols // สัญลักษณ์ (ใช้เป็นชื่อตัวแปร, ฟังก์ชัน, ฯลฯ)","Lists // รายการ (โครงสร้างข้อมูลหลักใน Scheme)","Pairs // คู่ (พื้นฐานของ List)","Procedures (Functions) // ฟังก์ชัน (เป็น First-class citizen)","Vectors // เวกเตอร์ (คล้าย Array, เข้าถึงด้วย Index)"],"examples (ตัวอย่าง)":["(define x 10) ; กำหนดตัวแปร x เก็บค่า 10","(define message \"Hello Scheme\") ; กำหนดตัวแปร message เก็บสตริง","(define pi 3.14159) ; กำหนดตัวแปร pi เก็บค่าทศนิยม","(define my-list '(a b c)) ; สร้าง List ด้วย Quote","(define my-vector (vector 1 2 3)) ; สร้าง Vector"]},"functions":{"declaration (การประกาศ)":["(define (function-name parameters) body) ; การประกาศฟังก์ชัน (Procedure)","(lambda (parameters) body) ; Anonymous function (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\n(define (add a b) (+ a b))","// ฟังก์ชันทักทาย\n(define (greet name) (display \"Hello \") (display name) (newline))","// การเรียกใช้ฟังก์ชัน\n(define sum (add 5 5)) ; sum จะมีค่า 10\n(greet \"World\") ; แสดงผล 'Hello World!'\n","// ฟังก์ชัน Recursive สำหรับ Factorial\n(define (factorial n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1))))) ; ถ้า n เป็น 0 คืน 1 ไม่งั้น n * factorial(n-1)\n; (factorial 5) ; 120\n","// Higher-Order Function (ฟังก์ชันที่รับฟังก์ชันเป็น Argument)\n(define (apply-twice f x) (f (f x)))\n; (apply-twice (lambda (y) (+ y 1)) 5) ; 7 (5 -> 6 -> 7)\n","// การทำงานกับ List โดยใช้ Recursion\n(define (list-sum lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (list-sum (cdr lst))))) ; ถ้า List ว่าง คืน 0 ไม่งั้น Head + Sum ของ Tail\n; (list-sum '(1 2 3 4)) ; 10\n","// Asynchronous Programming (แนวคิด - ผ่าน Continuations หรือ Libraries)\n// Scheme มี Continuations ที่ทรงพลัง ซึ่งสามารถใช้สร้าง Control Flow ที่ซับซ้อน รวมถึง Asynchronous behaviors ได้\n// อย่างไรก็ตาม โดยทั่วไปแล้ว Scheme ไม่ได้มี Model Async/Await ในตัวแบบภาษาสมัยใหม่\n// การทำงาน Asynchronous อาจต้องพึ่งพา Extensions หรือ Libraries ของแต่ละ Implementation\n/*\n; ตัวอย่างแนวคิดของการใช้ Call/CC (Call with Current Continuation) สำหรับควบคุม Flow\n; ซึ่งเป็นพื้นฐานของการทำ Async ในระดับลึกของ Functional Programming\n; (define (producer consumer)\n;   (display \"Producer starts... \") (newline)\n;   (call/cc\n;     (lambda (k) (set! consumer k)))\n;   (display \"Producer yields... \") (newline)\n;   (consumer \"data\"))\n;\n; (define (consumer-fn)\n;   (let ((data (producer (lambda (x) x)))) ; สร้าง Continuation สำหรับ producer\n;     (display \"Consumer received: \") (display data) (newline)))\n;\n; (consumer-fn)\n*/"],"built_in (ในตัว)":["+, -, *, / // ตัวดำเนินการทางคณิตศาสตร์ (เป็นฟังก์ชัน)","display // ใช้แสดงผลข้อมูลออกทาง Console (ไม่ขึ้นบรรทัดใหม่)","newline // ใช้ขึ้นบรรทัดใหม่","car // คืนค่าสมาชิกแรกของ List","cdr // คืนค่า List ที่เหลือทั้งหมด ยกเว้นสมาชิกแรก","cons // สร้าง Pair หรือเพิ่ม Element เข้าไปใน List","list // สร้าง List","lambda // ใช้สร้าง Anonymous Function","define // ใช้กำหนดตัวแปรหรือฟังก์ชัน","if // คำสั่งเงื่อนไข","cond // คำสั่งเงื่อนไขแบบหลายเงื่อนไข","begin // ใช้จัดกลุ่ม Expression ให้เป็น Block","null? // ตรวจสอบว่าเป็น List ว่างหรือไม่","number? // ตรวจสอบว่าเป็นตัวเลขหรือไม่"],"async":[]},"syntax":{"comments (คอมเมนต์)":["; Single-line comment ; คอมเมนต์บรรทัดเดียว","#| Multi line |# ; คอมเมนต์หลายบรรทัด (ใช้ได้ในบาง Implementation เช่น Racket)"],"conditions (เงื่อนไข)":["(if condition then-expression else-expression) // คำสั่ง if-else (เป็น Expression ที่คืนค่า)","(cond (condition1 expr1) (condition2 expr2) (else default-expr)) // คำสั่ง cond (หลายเงื่อนไข คล้าย if-elseif-else หรือ switch)"],"loops (การวนซ้ำ)":["(do ((var init step) ...) (test result ...) body ...) // ลูป do (สำหรับ Imperative-style looping)","recursive functions (common for iteration) // การใช้ฟังก์ชัน Recursive (นิยมใช้สำหรับการวนซ้ำแบบ Functional)","(map (lambda (x) (* x 2)) '(1 2 3)) ; การใช้ map เพื่อวนซ้ำและแปลงค่า (Functional approach)"],"operators (ตัวดำเนินการ)":["(+ a b) ; (ลบ a b) ; (* a b) ; (/ a b) ; (remainder a b) ; ตัวดำเนินการทางคณิตศาสตร์ (เป็นฟังก์ชัน)","(= a b) ; (< a b) ; (> a b) ; (<= a b) ; (>= a b) ; ตัวดำเนินการเปรียบเทียบ (เป็นฟังก์ชัน)","(and cond1 cond2) ; (or cond1 cond2) ; (not cond) ; ตัวดำเนินการตรรกะ (เป็นฟังก์ชัน)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else\n(define x 10)\n(if (> x 0)\n    (display \"Positive\")\n    (display \"Non-positive\"))\n(newline)\n","// ตัวอย่างที่ 2: ฟังก์ชันนับถอยหลัง (Recursive Loop)\n(define (countdown n)\n  (if (= n 0)\n      (display \"Blastoff!\")\n      (begin (display n) (newline) (countdown (- n 1))))) ; นับถอยหลังและแสดงผลทีละบรรทัด\n; (countdown 3)\n; Output:\n; 3\n; 2\n; 1\n; Blastoff!\n","// ตัวอย่างที่ 3: การใช้ Cond (Conditional Expression)\n(define score 75)\n(cond\n  ((>= score 90) (display \"Grade A\"))\n  ((>= score 70) (display \"Grade B\"))\n  (else (display \"Grade C\")))\n(newline)\n","// ตัวอย่างที่ 4: การทำงานกับ List\n(define my-numbers '(10 20 30))\n(display (car my-numbers)) ; 10 (ดึงสมาชิกแรก)\n(newline)\n(display (cdr my-numbers)) ; (20 30) (ดึงส่วนที่เหลือ)\n(newline)\n(display (cons 5 my-numbers)) ; (5 10 20 30) (สร้าง List ใหม่โดยเพิ่ม 5 เข้าไป)\n(newline)\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling)\n; ใน Scheme, Error Handling มักจะใช้ `with-exception-handler` หรือ `guard` (ใน R6RS/R7RS)\n; เพื่อจับ Exceptions หรือ Conditions\n; (with-exception-handler\n;   (lambda (exn) (display (string-append \"Caught error: \" (exn-message exn))) (newline))\n;   (lambda () (/ 10 0))) ; พยายามหารด้วย 0 ซึ่งจะเกิด error\n; Output: Caught error: division by zero\n","// ตัวอย่างที่ 6: การใช้ Macro (Metaprogramming)\n; Macros ใน Scheme เป็นวิธีที่ทรงพลังในการขยายไวยากรณ์ของภาษา\n; ทำให้คุณสามารถสร้างไวยากรณ์ใหม่ได้เอง\n; (define-syntax my-unless\n;   (syntax-rules ()\n;     ((_ condition body ...)\n;      (if (not condition) (begin body ...)))))\n;\n; (my-unless (= 1 2)\n;   (display \"This will print because 1 is not equal to 2.\")\n;   (newline))\n"]}},{"id":33,"name":"Smalltalk","slug":"smalltalk","logo":"img/smalltalk.png","desc":"Smalltalk เป็นภาษาโปรแกรมเชิงวัตถุบริสุทธิ์ (Pure Object-Oriented) ที่มีแนวคิดการทำงานแบบ Message Passing และสภาพแวดล้อมการพัฒนาแบบโต้ตอบ (Interactive Development Environment - IDE) ซึ่งเป็นผู้บุกเบิกแนวคิด GUI และการพัฒนาแบบ Rapid Prototyping มีอิทธิพลอย่างมากต่อภาษาและ Frameworks สมัยใหม่หลายตัว","by":"Alan Kay, Dan Ingalls, Adele Goldberg, etc. (Xerox PARC)","yr":"1970s (Smalltalk-80)","level":"3","par":["Object-Oriented","Reflective","Dynamic"],"fields":["Edu"],"rank":"45+ ลดลงมาก แต่ยังมีใช้ใน Legacy Enterprise","salary_range":"฿26,000-42,000 บาท/เดือน (Junior), ฿42,000-72,000 บาท/เดือน (Senior)","salary":["n/a"],"pros":["Pure Object-Oriented System (ทุกอย่างเป็น Object)","สภาพแวดล้อมการพัฒนาแบบโต้ตอบ (REPL) ที่ทรงพลัง","Hot-swapping code (เปลี่ยนโค้ดขณะรันได้)","Concept ที่เรียบง่ายแต่ทรงพลัง (Message Passing)","เป็นผู้บุกเบิกแนวคิด GUI และ OOP สมัยใหม่"],"cons":["Learning Curve สูงสำหรับผู้ที่ไม่คุ้นเคยกับแนวคิด Pure OOP","ไวยากรณ์ที่แตกต่างจากภาษาตระกูล C อย่างมาก","ชุมชนนักพัฒนาขนาดเล็กและเฉพาะทาง","ไม่ได้รับความนิยมในตลาดหลักในปัจจุบัน (เน้น Legacy Systems)","ประสิทธิภาพอาจไม่ดีเท่าภาษาที่คอมไพล์แบบ Native"],"frameworks":["Seaside (Web Framework)"],"learn":["Pharo (modern Smalltalk environment)","Squeak Smalltalk","Smalltalk-80: The Language and its Implementation"],"variables":{"declaration (การประกาศ)":["| variableName | \"ประกาศตัวแปรชั่วคราว (Temporary variables)\"","ClassName new \"การสร้าง Instance ของคลาส\""],"types (ประเภท)":["Boolean // ค่าตรรกะ (true, false)","Integer // จำนวนเต็ม","Float // ทศนิยม","Fraction // เศษส่วน","Character // ตัวอักขระ","String // ข้อความ","Array // อาร์เรย์","Dictionary // พจนานุกรม (Key-Value pairs)","Block (code block) // บล็อกโค้ด (First-class citizen)","Object (base class) // คลาสพื้นฐานของทุกอย่าง"],"examples (ตัวอย่าง)":["| myNumber | \"ประกาศตัวแปรชั่วคราว myNumber\"","myNumber := 10. \"กำหนดค่า 10 ให้ myNumber\"","| greeting | greeting := 'Hello Smalltalk'. \"กำหนดสตริง\"","Object new \"สร้าง Object ใหม่ (Instance ของคลาส Object)\"","| anArray | anArray := #(1 2 3). \"สร้าง Array\""]},"functions":{"declaration (การประกาศ)":["methodName: argument1 with: argument2\n  \"Comment explaining the method\"\n  | temporaryVar |\n  ... method body ...\n  ^ result // คืนค่า"],"examples (ตัวอย่าง)":["add: a and: b\n  ^ a + b \"เมธอดบวกเลขสองจำนวน\"","greet: aName\n  Transcript show: 'Hello ' , aName; cr \"เมธอดทักทายและแสดงผลออก Transcript\"","// การเรียกใช้เมธอด (Message Sending)\n\"Hello\" size. \"ส่ง Message 'size' ไปยัง Object 'Hello' (คืนค่า 5)\"\n(3 + 4) * 2. \"ส่ง Message '+' ให้ 3 ด้วย Argument 4, แล้วส่ง Message '*' ให้ผลลัพธ์ด้วย Argument 2 (คืนค่า 14)\"\nmyObject myMethod: arg1 anotherArg: arg2. \"ส่ง Message ที่มีหลาย Keyword Argument\"\n\n// เมธอดสำหรับ Factorial (Recursive)\nfactorial\n  ^ self = 0\n    ifTrue: [ 1 ]\n    ifFalse: [ self * (self - 1) factorial ]\n\"ตัวอย่างการใช้งาน: 5 factorial.\" \"คืนค่า 120\"","// Asynchronous Programming (Conceptual - Through Actor Model/Processes)\n// Smalltalk ไม่ได้มี async/await ในตัวแบบภาษาสมัยใหม่ แต่ใช้แนวคิดของ Processes/Blocks\n// และ Message Passing สำหรับ Concurrency\n// Pharo (Modern Smalltalk) มี Block closure และ Processes ที่สามารถทำงานแบบ Concurrent ได้\n/*\n| aProcess |\naProcess := [ \n  1 to: 5 do: [ :i | \n    Transcript show: 'Process running: ' , i asString; cr.\n    (Delay forSeconds: 0.1) wait. \"จำลองการทำงานที่ใช้เวลา\"\n  ]\n] fork. \"สร้างและรัน Process ใน Background\"\n\nTranscript show: 'Main program continues...'; cr.\n(Delay forSeconds: 0.5) wait. \"ให้เวลา Process อื่นรัน\"\nTranscript show: 'Main program finished.'; cr.\n\n\"Output:\nMain program continues...\nProcess running: 1\nProcess running: 2\nMain program running: 3\n...\"\n*/"],"built_in (ในตัว)":["at: // เข้าถึงสมาชิกของ Collection ด้วย Index/Key","put: // กำหนดค่าให้กับสมาชิกของ Collection ด้วย Index/Key","do: // วนซ้ำ (Iterate) ผ่าน Collection","collect: // แปลง Collection (คล้าย map)","select: // กรอง Collection (คล้าย filter)","ifTrue:ifFalse: // เมธอดสำหรับเงื่อนไข (Conditional)","asString // แปลง Object เป็น String","asInteger // แปลง Object เป็น Integer","new // สร้าง Instance ใหม่ของ Class","show: // แสดงผลออก Transcript (Console)","cr // ขึ้นบรรทัดใหม่ใน Transcript"]},"syntax":{"comments (คอมเมนต์)":["\"This is a Smalltalk comment\" // คอมเมนต์บรรทัดเดียวหรือหลายบรรทัด"],"conditions (เงื่อนไข)":["condition ifTrue: [ ... ] ifFalse: [ ... ] // เงื่อนไข If-Else (ใช้ Block closures)","condition ifTrue: [ ... ] // เงื่อนไข If-Then","number isZero ifTrue: [ ... ] // ตรวจสอบว่าตัวเลขเป็นศูนย์หรือไม่"],"loops (การวนซ้ำ)":["1 to: 5 do: [ :i | Transcript show: i asString; cr ] // ลูป For (วนซ้ำตามช่วงตัวเลข)","collection do: [ :each | ... ] // วนซ้ำผ่าน Collection","collection select: [ :each | each > 10 ] // เลือกสมาชิกที่ตรงเงื่อนไข (คล้าย Filter)","collection collect: [ :each | each * 2 ] // แปลงสมาชิก (คล้าย Map)","whileTrue: [ condition ] do: [ ... ] // ลูป While"],"operators (ตัวดำเนินการ)":["+, -, *, / // ตัวดำเนินการทางคณิตศาสตร์ (เป็น Binary Message)","=, <, >, <=, >=, ~= // ตัวดำเนินการเปรียบเทียบ (เป็น Binary Message)","// // Message Sending (การส่งข้อความไปยัง Object)",":= // Assignment (การกำหนดค่า)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else \n10 > 5 ifTrue: [ Transcript show: '10 is greater than 5'; cr ]\n  ifFalse: [ Transcript show: '10 is not greater than 5'; cr ].","// ตัวอย่างที่ 2: การใช้วงลูป For (Iterating over a Range)\n1 to: 3 do: [ :i | Transcript show: 'Loop: ' , i asString; cr ].","// ตัวอย่างที่ 3: การทำงานกับ Collection (Array)\n| numbers |\nnumbers := #(10 20 30 40 50).\nnumbers do: [ :n | Transcript show: 'Number: ' , n asString; cr ]. \"วนซ้ำและแสดงผลแต่ละตัวเลข\"\n\n| doubledNumbers |\ndoubledNumbers := numbers collect: [ :n | n * 2 ]. \"สร้าง Array ใหม่ที่แต่ละตัวคูณสอง\"\nTranscript show: 'Doubled Numbers: ' , doubledNumbers asString; cr. \"แสดงผล Array ที่สร้างขึ้นใหม่\"","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาด (Exception Handling)\n[ \n  1 / 0. \"จะเกิด ZeroDivisionError\"\n] on: ZeroDivisionError do: [ :ex | \n  Transcript show: 'Error caught: ' , ex description; cr.\n].\nTranscript show: 'Program continues after error handling.'; cr.","// ตัวอย่างที่ 5: การทำงานกับ Dictionary (Map)\n| userInfo |\nuserInfo := Dictionary new.\nuserInfo at: #name put: 'Charlie'.\nuserInfo at: #age put: 28.\nTranscript show: 'User name: ' , (userInfo at: #name); cr.\nTranscript show: 'User age: ' , (userInfo at: #age) asString; cr.","// ตัวอย่างที่ 6: การสร้างและการเรียกใช้ Class (Object-Oriented Basics)\n\"ประกาศคลาส Animal\nObject subclass: #Animal\n  instanceVariableNames: 'name'\n  classVariableNames: ''\n  poolDictionaries: ''\n  category: 'My-Examples'\n\n!Animal methodsFor: 'accessing'!\nname\n  ^ name\n!\nname: aString\n  name := aString\n!\n!Animal methodsFor: 'actions'!\nspeak\n  ^ 'Hello, I am ' , name\n!\n\n\"สร้าง Object และเรียกใช้เมธอด\n| myAnimal |\nmyAnimal := Animal new.\nmyAnimal name: 'Leo'.\nTranscript show: myAnimal speak; cr. \"แสดงผล 'Hello, I am Leo'\""]}},{"id":35,"name":"Solidity","slug":"solidity","logo":"img/solidity.png","desc":"Solidity คือภาษาโปรแกรมที่ใช้สำหรับเขียน Smart Contracts ที่ทำงานบน Ethereum Blockchain และ EVM (Ethereum Virtual Machine) Compatible Chains อื่นๆ เช่น BNB Smart Chain, Polygon เป็นภาษาหลักในการพัฒนาแอปพลิเคชันแบบกระจายศูนย์ (dApps) และ Token","by":"Gavin Wood, Christian Reitwiessner, Alex Beregszaszi, Liana Husikyan, Yoichi Hirai","yr":"2014","level":"3","par":["Object-Oriented","Imperative","Contract-Oriented"],"fields":["Blockchain"],"rank":"30+ เติบโตตาม Blockchain และ Web3 Trend","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-130,000 บาท/เดือน (Senior)","salary":["veryhigh"],"pros":["ภาษามาตรฐานสำหรับการพัฒนา Smart Contracts บน Ethereum","มีเครื่องมือและไลบรารีสำหรับ Blockchain Development ค่อนข้างเยอะ","รองรับการทำงานกับเครือข่าย EVM-compatible หลากหลาย","ความต้องการในตลาด Blockchain สูงและรายได้ดี"],"cons":["การเขียนโค้ดต้องระมัดระวังเรื่องความปลอดภัยสูงมาก (ช่องโหว่)","ค่าธรรมเนียม Gas ในการทำงานบน Blockchain ทำให้การทำงานบางอย่างมีต้นทุนสูง","ไม่เหมาะสำหรับงานทั่วไปที่ไม่เกี่ยวข้องกับ Blockchain","การดีบักและการทดสอบอาจซับซ้อนกว่าภาษาทั่วไป"],"frameworks":["Hardhat","Truffle","Foundry","OpenZeppelin"],"learn":["Solidity Documentation","CryptoZombies","freeCodeCamp - Blockchain Development"],"variables":{"declaration (การประกาศ)":["type visibility name; // รูปแบบการประกาศตัวแปร"],"types (ประเภท)":["uint (unsigned integer) // จำนวนเต็มบวก","int (signed integer) // จำนวนเต็มบวก/ลบ","address // ที่อยู่บน Blockchain","bool // บูลีน (true, false)","bytes // ไบต์ (Fixed-size หรือ Dynamic)","string // สตริง","array (fixed/dynamic) // อาร์เรย์ (ขนาดคงที่/ปรับได้)","struct // โครงสร้างข้อมูลที่กำหนดเอง","enum // ประเภทแบบแจงนับ","mapping // Map (Key-Value store)"],"examples (ตัวอย่าง)":["uint public myNumber = 10; // ตัวแปรจำนวนเต็มบวกสาธารณะ","address public owner; // ตัวแปรที่อยู่บน Blockchain","bool private _isActive; // ตัวแปรบูลีนส่วนตัว","string public greeting = \"Hello Solidity\"; // ตัวแปรสตริงสาธารณะ","mapping(address => uint) public balances; // Mapping จาก address ไปยัง uint"]},"functions":{"declaration (การประกาศ)":["function name(params) visibility stateMutability { ... } // รูปแบบการประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันถอนเงิน\nfunction withdraw(uint amount) public {\n    require(balances[msg.sender] >= amount, \"Insufficient balance\"); // ตรวจสอบยอดเงิน\n    balances[msg.sender] -= amount; // ลดจำนวนเงิน\n}\n","// ฟังก์ชันดูยอดคงเหลือ\nfunction getBalance() public view returns (uint) {\n    return balances[msg.sender];\n}\n","// ฟังก์ชันสำหรับฝากเงิน\nfunction deposit() public payable {\n    balances[msg.sender] += msg.value; // เพิ่มยอดเงินด้วยจำนวน ETH ที่ส่งมา\n}\n","// การจัดการ Event (สำหรับ Log การทำงานบน Blockchain)\n// event Transfer(address indexed from, address indexed to, uint value);\n// function transfer(address _to, uint _value) public {\n//     require(balances[msg.sender] >= _value, \"Insufficient balance\");\n//     balances[msg.sender] -= _value;\n//     balances[_to] += _value;\n//     emit Transfer(msg.sender, _to, _value);\n// }\n","// Asynchronous Programming (Conceptual - Through External Calls/Events)\n// Solidity โดยธรรมชาติไม่ได้มี Asynchronous Programming แบบ Threading หรือ Async/Await\n// การทำงาน \"แบบ asynchronous\" ใน Smart Contracts มักจะหมายถึงการเรียกใช้ Smart Contracts อื่นๆ (External Calls)\n// ซึ่งจะมีการทำงานแบบ Non-blocking ในระดับของ Transaction Processing แต่ไม่ใช่ภายใน Execution Flow ของ Contract เดียวกัน\n/*\n// interface IAnotherContract {\n//     function doSomething(uint _value) external;\n// }\n\n// contract MyContract {\n//     address public anotherContractAddress;\n\n//     constructor(address _anotherContractAddress) {\n//         anotherContractAddress = _anotherContractAddress;\n//     }\n\n//     function callAnotherContract(uint _value) public {\n//         IAnotherContract(anotherContractAddress).doSomething(_value); // การเรียกใช้ External Contract (คล้าย Async Call)\n//     }\n\n//     // ฟังก์ชันรับเงินสำรองสำหรับ Fallback/Receive Ether\n//     receive() external payable {\n//         // Handle incoming Ether\n//     }\n// }\n*/"],"built_in (ในตัว)":["msg.sender // ที่อยู่ของผู้ที่เรียกใช้ฟังก์ชันปัจจุบัน","msg.value // จำนวน Ether ที่ส่งมาพร้อมกับการเรียกใช้ฟังก์ชัน","block.timestamp // เวลาปัจจุบันของบล็อกเป็น Unix timestamp","require() // ใช้ตรวจสอบเงื่อนไข ถ้าไม่เป็นจริงจะ revert transaction","revert() // ใช้ยกเลิก transaction และคืนค่า Gas ที่เหลือ","assert() // ใช้ตรวจสอบเงื่อนไข (คล้าย require แต่ใช้สำหรับ Internal Errors)","sha256() // ฟังก์ชัน Hash SHA256","keccak256() // ฟังก์ชัน Hash Keccak256 (นิยมใช้ใน Ethereum)","abi.encodePacked() // เข้ารหัส Argument แบบ Pack","address.balance // ตรวจสอบยอดคงเหลือของ Address นั้นๆ","address.transfer() // ส่ง Ether ไปยัง Address (Depreciated)","address.send() // ส่ง Ether ไปยัง Address (Depreciated)","address.call() // เรียกใช้ External Contract ในระดับ Low-level"]},"syntax":{"comments (คอมเมนต์)":["// Single line // คอมเมนต์บรรทัดเดียว","/* Multi line */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { ... } else { ... } // คำสั่ง if-else"],"loops (การวนซ้ำ)":["for (uint i = 0; i < 10; i++) { ... } // ลูป for","while (condition) { ... } // ลูป while"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Assignment: = // กำหนดค่า","Bitwise: &, |, ^, ~ // Bitwise operators"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nuint public value = 5;\nfunction checkValue() public view returns (string memory) {\n    if (value > 10) {\n        return \"Value is greater than 10\";\n    } else {\n        return \"Value is 10 or less\";\n    }\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nfunction sumUpTo(uint n) public pure returns (uint) {\n    uint sum = 0;\n    for (uint i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n","// ตัวอย่างที่ 3: การทำงานกับ Structs และ Mappings\nstruct User {\n    uint id;\n    string name;\n    address walletAddress;\n}\n\nmapping(address => User) public users;\n\nfunction registerUser(uint _id, string memory _name) public {\n    users[msg.sender] = User(_id, _name, msg.sender);\n}\n\nfunction getUserName(address _userAddress) public view returns (string memory) {\n    return users[_userAddress].name;\n}\n","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาด (Require, Revert, Assert)\nfunction transferFunds(address _to, uint _amount) public {\n    require(balances[msg.sender] >= _amount, \"Insufficient balance.\"); // ตรวจสอบยอดเงิน\n    // assert(balances[msg.sender] - _amount <= balances[msg.sender]); // ใช้สำหรับ internal errors (ไม่ค่อยนิยม)\n    balances[msg.sender] -= _amount;\n    balances[_to] += _amount;\n}\n"]}},{"id":15,"name":"SQL","slug":"sql","logo":"img/sql.png","desc":"SQL (Structured Query Language) ไม่ใช่ภาษาโปรแกรมมิ่งแบบทั่วไป แต่เป็นภาษามาตรฐานที่ใช้ในการจัดการและสอบถามข้อมูลจากฐานข้อมูลเชิงสัมพันธ์ (Relational Databases) เป็นสิ่งจำเป็นสำหรับนักพัฒนาซอฟต์แวร์ทุกคน","by":"Donald D. Chamberlin and Raymond F. Boyce","yr":"1970s","level":"5","par":["Declarative"],"fields":["DB","Script"],"rank":"9-11 แต่กำลังลดลง (ตำแหน่งต่ำสุดเท่าที่เคยมี)","salary_range":"฿28,000-45,000 บาท/เดือน (Junior), ฿45,000-75,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["เป็นมาตรฐานอุตสาหกรรมสำหรับการจัดการฐานข้อมูล","มีประสิทธิภาพสูงในการดึงข้อมูลจำนวนมาก","ใช้งานง่ายและเรียนรู้ได้เร็วสำหรับพื้นฐาน","ทำงานร่วมกับภาษาโปรแกรมอื่นๆ ได้ดี","รองรับการ Query ข้อมูลที่ซับซ้อน"],"cons":["ไม่ใช่ภาษา General-purpose (ใช้สำหรับฐานข้อมูลเท่านั้น)","ประสิทธิภาพอาจลดลงเมื่อ Query ซับซ้อนมาก","แต่ละ Database System (MySQL, PostgreSQL) อาจมี Syntax ต่างกันเล็กน้อย","การ Scale อาจเป็นความท้าทายสำหรับข้อมูลขนาดใหญ่มาก"],"frameworks":["None (เป็นภาษาฐานข้อมูล)","ORMs (Object-Relational Mappers) ในภาษาโปรแกรมต่างๆ"],"learn":["W3Schools SQL Tutorial","SQLBolt","Khan Academy SQL","Mode Analytics SQL Tutorials"],"variables":{"declaration (การประกาศ)":["// ใน SQL ไม่มีการประกาศตัวแปรในลักษณะเดียวกับภาษาโปรแกรมทั่วไป\n// แต่เป็นการกำหนดโครงสร้างของตารางและคอลัมน์ในฐานข้อมูล (Data Definition Language - DDL)\n// หรือประกาศตัวแปรชั่วคราวใน Stored Procedure (ซึ่งเป็นส่วนขยายของ SQL)"],"types (ประเภท)":["INT // จำนวนเต็ม","VARCHAR(size) // สตริงความยาวแปรผัน (ระบุขนาดสูงสุด)","TEXT // สตริงขนาดยาว","DATE // วันที่ (YYYY-MM-DD)","DATETIME // วันที่และเวลา (YYYY-MM-DD HH:MM:SS)","BOOLEAN // ค่าจริงหรือเท็จ (TRUE/FALSE)","DECIMAL(p, s) // ตัวเลขทศนิยมที่มีความแม่นยำคงที่ (p=จำนวนหลักทั้งหมด, s=จำนวนหลักหลังจุดทศนิยม)","FLOAT // ตัวเลขทศนิยมความแม่นยำเดี่ยว","PRIMARY KEY // คีย์หลัก (ใช้ระบุแถวที่ไม่ซ้ำกันในตาราง)","FOREIGN KEY // คีย์นอก (ใช้เชื่อมโยงกับคีย์หลักในตารางอื่น)"],"examples (ตัวอย่าง)":["CREATE TABLE Products ( // สร้างตารางชื่อ Products\n  ProductID INT PRIMARY KEY, // คอลัมน์ ProductID เป็นคีย์หลัก ชนิด INT\n  ProductName VARCHAR(255) NOT NULL, // คอลัมน์ ProductName ชนิด VARCHAR ห้ามเป็น NULL\n  Price DECIMAL(10, 2) // คอลัมน์ Price ชนิด DECIMAL มี 10 หลัก ทศนิยม 2 หลัก\n);","INSERT INTO Users (Name, Age) VALUES ('John Doe', 30); // เพิ่มข้อมูลใหม่ลงในตาราง Users","INSERT INTO Orders (OrderID, CustomerID, OrderDate) VALUES (101, 1, '2023-05-15');","ALTER TABLE Customers ADD Email VARCHAR(255); -- เพิ่มคอลัมน์ Email ในตาราง Customers"]},"functions":{"declaration (การประกาศ)":["// ใน SQL ฟังก์ชันมักจะเป็น Built-in (ฟังก์ชันในตัว) หรือ User-Defined Functions (UDFs)\n// ซึ่งถูกสร้างขึ้นเพื่อใช้ในการประมวลผลข้อมูลใน Query หรือ Stored Procedure\nSELECT COUNT(column_name) FROM table_name; -- ตัวอย่างการใช้งานฟังก์ชัน COUNT"],"examples (ตัวอย่าง)":["SELECT AVG(Price) FROM Products; -- หาค่าเฉลี่ยของราคาในตาราง Products","SELECT MAX(OrderDate) FROM Orders; -- หาวันที่สั่งซื้อล่าสุดในตาราง Orders","SELECT CONCAT(FirstName, ' ', LastName) AS FullName FROM Employees; -- รวมชื่อและนามสกุลเป็น FullName","SELECT LEFT(ProductName, 5) FROM Products; -- ดึง 5 ตัวแรกของชื่อสินค้า\n","SELECT \n  CustomerID, \n  COUNT(OrderID) AS TotalOrders, \n  SUM(TotalAmount) AS TotalSpent \nFROM Orders \nGROUP BY CustomerID \nHAVING COUNT(OrderID) > 5; -- หาจำนวนและยอดรวมคำสั่งซื้อของลูกค้าที่มีมากกว่า 5 คำสั่งซื้อ"],"built_in (ในตัว)":["COUNT() // นับจำนวนแถว","SUM() // หาผลรวม","AVG() // หาค่าเฉลี่ย","MIN() // หาค่าน้อยที่สุด","MAX() // หาค่ามากที่สุด","UPPER() // แปลงสตริงเป็นตัวพิมพ์ใหญ่","LOWER() // แปลงสตริงเป็นตัวพิมพ์เล็ก","LENGTH() // หาความยาวของสตริง","SUBSTR() // ดึงสตริงย่อย","NOW() // วันที่และเวลาปัจจุบัน","CURDATE() // วันที่ปัจจุบัน"]},"syntax":{"comments (คอมเมนต์)":["-- Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["WHERE condition // ใช้กำหนดเงื่อนไขในการเลือกข้อมูล (ใน SELECT, UPDATE, DELETE)","HAVING condition (for grouped data) // ใช้กำหนดเงื่อนไขสำหรับข้อมูลที่ถูกจัดกลุ่ม (หลัง GROUP BY)","CASE WHEN condition THEN result ELSE result END // คำสั่ง Case (คล้าย If-Else หรือ Switch)"],"loops (การวนซ้ำ)":["// ใน SQL มาตรฐานไม่มีคำสั่ง Loop โดยตรงเหมือนภาษาโปรแกรมทั่วไป\n// การวนซ้ำมักจะถูกจัดการผ่าน Stored Procedures, Cursors หรือ Logic ใน Application Layer ที่เรียกใช้ SQL แทน"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Comparison: =, <>, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: AND, OR, NOT // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Special: IN, BETWEEN, LIKE, IS NULL // ตัวดำเนินการพิเศษ: อยู่ในรายการ, อยู่ระหว่าง, คล้ายกับ, เป็นค่าว่าง"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การเลือกข้อมูล (SELECT) พร้อมเงื่อนไข\nSELECT * FROM Customers WHERE Age > 25 AND City = 'New York'; // เลือกข้อมูลลูกค้าที่อายุมากกว่า 25 และอยู่ในนิวยอร์ก","// ตัวอย่างที่ 2: การอัปเดตข้อมูล (UPDATE)\nUPDATE Products SET Price = Price * 1.10 WHERE Category = 'Electronics'; // เพิ่มราคา 10% สำหรับสินค้าหมวด Electronics","// ตัวอย่างที่ 3: การลบข้อมูล (DELETE)\nDELETE FROM Orders WHERE OrderDate < '2023-01-01'; // ลบคำสั่งซื้อที่เกิดขึ้นก่อนปี 2023","// ตัวอย่างที่ 4: การรวมตาราง (JOIN)\nSELECT Orders.OrderID, Customers.Name\nFROM Orders\nJOIN Customers ON Orders.CustomerID = Customers.CustomerID\nWHERE Orders.TotalAmount > 100; // เลือก OrderID และชื่อลูกค้าสำหรับคำสั่งซื้อที่มีมูลค่ามากกว่า 100","// ตัวอย่างที่ 5: การจัดกลุ่มและเรียงลำดับ (GROUP BY, ORDER BY)\nSELECT Category, COUNT(ProductID) AS NumberOfProducts\nFROM Products\nGROUP BY Category\nORDER BY NumberOfProducts DESC; // นับจำนวนสินค้าแต่ละหมวดหมู่และเรียงจากมากไปน้อย","// ตัวอย่างที่ 6: การใช้ Subquery\nSELECT ProductName, Price\nFROM Products\nWHERE ProductID IN (SELECT ProductID FROM OrderDetails WHERE Quantity > 5); // เลือกชื่อและราคาสินค้าที่ถูกสั่งมากกว่า 5 ชิ้น"]}},{"id":12,"name":"Swift","slug":"swift","logo":"img/swift.png","desc":"Swift เป็นภาษาโปรแกรมที่พัฒนาโดย Apple สำหรับสร้างแอปพลิเคชันบน iOS, macOS, watchOS, tvOS และ Linux เน้นความปลอดภัย, ประสิทธิภาพ และความทันสมัยในการเขียนโค้ด","by":"Apple Inc.","yr":"2014","level":"3","par":["Multi-paradigm","Object-Oriented","Functional","Protocol-Oriented"],"fields":["Mobile","Desktop","Script"],"rank":"10-12 สำหรับ iOS Development แต่กำลังลดลง (1.8% ใน TIOBE)","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-110,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["ประสิทธิภาพสูง","ปลอดภัยจากข้อผิดพลาดของหน่วยความจำ (Memory Safety)","Syntax ที่อ่านง่ายและกระชับ","มี Playgrounds สำหรับทดลองโค้ดได้ทันที","รองรับ Concurrency และ Asynchronous Programming ได้ดี"],"cons":["ส่วนใหญ่ผูกติดกับ Ecosystem ของ Apple","Learning Curve อาจสูงสำหรับผู้เริ่มต้น","เครื่องมือพัฒนา (Xcode) อาจใช้ทรัพยากรมาก","ชุมชนนักพัฒนาอาจเล็กกว่าภาษาอื่นๆ"],"frameworks":["UIKit","SwiftUI","Combine","Vapor","Kitura"],"learn":["Apple Swift Documentation","Hacking with Swift","Ray Wenderlich","Codecademy: Learn Swift"],"variables":{"declaration (การประกาศ)":["var greeting = \"Hello\"; // ตัวแปรที่สามารถเปลี่ยนแปลงค่าได้ (Mutable)","let name = \"World\"; // ค่าคงที่ (Immutable)"],"types (ประเภท)":["String // ประเภทข้อมูลข้อความ","Int // ประเภทข้อมูลจำนวนเต็ม","Double // ประเภทข้อมูลทศนิยมความแม่นยำคู่","Bool // ประเภทข้อมูลค่าจริงหรือเท็จ (true/false)","Character // ประเภทข้อมูลตัวอักขระ","Array<T> // Generic Type สำหรับ Array (เช่น Array<Int> หรือ [Int])","Dictionary<K, V> // Generic Type สำหรับ Key-Value Pairs (เช่น Dictionary<String, Int>)","Optional<T> // ประเภทข้อมูลที่อาจมีค่าหรือไม่ก็ได้ (เช่น String? หรือ Int?)"],"examples (ตัวอย่าง)":["var score = 100 // กำหนดตัวแปร score เป็นตัวเลข","let username = \"swift_dev\" // กำหนดค่าคงที่ username เป็นสตริง","var isValid = true // กำหนดตัวแปร isValid เป็น boolean","let numbers: [Int] = [1, 2, 3, 4, 5] // การประกาศ Array","var ages: [String: Int] = [\"Alice\": 25, \"Bob\": 30] // การประกาศ Dictionary","var optionalValue: Int? = nil // ตัวแปร Optional ที่ยังไม่มีค่า"]},"functions":{"declaration (การประกาศ)":["func functionName(param1: Type) -> ReturnType { ... } // การประกาศฟังก์ชันปกติ","{ (param) -> ReturnType in ... } // Closure (ฟังก์ชันนิรนาม)"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfunc add(a: Int, b: Int) -> Int {\n  return a + b\n}\n","// ฟังก์ชันทักทาย\nfunc greet(name: String) {\n  print(\"Hello, \\(name)!\")\n}\n","// การเรียกใช้ฟังก์ชัน\nlet sum = add(a: 10, b: 20) // sum จะมีค่า 30\ngreet(name: \"Swift\") // แสดงผล 'Hello, Swift!'\n","// ฟังก์ชันที่คืนค่าหลายค่า (ด้วย Tuple)\nfunc getUserInfo() -> (name: String, age: Int) {\n  return (\"Alice\", 30)\n}\nlet user = getUserInfo()\nprint(\"User: \\(user.name), Age: \\(user.age)\")\n","// ฟังก์ชันที่มี Optional Binding (การจัดการ Optional)\nfunc displayOptionalMessage(message: String?) {\n  if let msg = message {\n    print(\"Message: \\(msg)\")\n  } else {\n    print(\"No message provided.\")\n  }\n}\ndisplayOptionalMessage(message: \"This is a message.\") // แสดงผล 'Message: This is a message.'\ndisplayOptionalMessage(message: nil) // แสดงผล 'No message provided.'\n","// การใช้งาน Closure (Anonymous Function)\nlet multiply: (Int, Int) -> Int = { (num1, num2) in\n  return num1 * num2\n}\nprint(\"Multiply: \\(multiply(5, 5))\") // แสดงผล 'Multiply: 25'\n","// Asynchronous Programming (Async/Await - Swift 5.5+)\n// Swift จัดการ Asynchronous ผ่านโครงสร้าง async/await ซึ่งทำให้โค้ด Asynchronous อ่านง่ายขึ้น\n// async func fetchData() async -> String {\n//   print(\"Fetching data...\")\n//   try? await Task.sleep(nanoseconds: 1_000_000_000) // จำลองการหน่วงเวลา 1 วินาที\n//   print(\"Data fetched!\")\n//   return \"Data fetched asynchronously\"\n// }\n// // ตัวอย่างการเรียกใช้ Async Function (ต้องอยู่ในบริบทของ Task หรือ Async Context)\n// /*\n// Task {\n//     let data = await fetchData()\n//     print(\"Received: \\(data)\")\n// }\n// */"],"built_in (ในตัว)":["print() // ใช้แสดงผลข้อมูลออกทาง Console","Array.append() // เมธอดสำหรับเพิ่มสมาชิกใน Array","Dictionary.keys // Property สำหรับเข้าถึง Key ทั้งหมดใน Dictionary","String.count // Property สำหรับนับจำนวนอักขระใน String","Optional.map() // เมธอดสำหรับแปลงค่าใน Optional หากมีค่า","min() // ฟังก์ชันสำหรับหาค่าน้อยที่สุด","max() // ฟังก์ชันสำหรับหาค่ามากที่สุด"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if condition { /* ... */ } else if condition { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch expression { case value: /* ... */ default: /* ... */ } // คำสั่ง switch (ต้องครอบคลุมทุกกรณี หรือมี default)"],"loops (การวนซ้ำ)":["for i in 1...5 { /* ... */ } // ลูป for-in สำหรับ Range แบบรวมค่าสุดท้าย","for i in 0..<3 { /* ... */ } // ลูป for-in สำหรับ Range แบบไม่รวมค่าสุดท้าย","while condition { /* ... */ } // ลูป while","repeat { /* ... */ } while condition; // ลูป repeat-while (คล้าย do-while ในภาษาอื่น)","for item in collection { /* ... */ } // ลูป for-in สำหรับวนซ้ำ Collection (เช่น Array)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Range: ... (Inclusive), ..< (Exclusive) // ตัวดำเนินการสำหรับช่วงตัวเลข","?? // Nil-Coalescing Operator (ตัวดำเนินการค่า Nil)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlet score = 85\nif score >= 90 {\n  print(\"Grade A\")\n} else if score >= 75 {\n  print(\"Grade B\")\n} else {\n  print(\"Grade C\")\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop) กับ Range\nfor i in 0..<3 {\n  print(\"Loop Swift: \\(i)\")\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nlet weather = \"Sunny\"\nswitch weather {\ncase \"Sunny\":\n  print(\"Wear sunglasses.\")\ncase \"Rainy\":\n  print(\"Take an umbrella.\")\ndefault:\n  print(\"Check weather app.\")\n}\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Inheritance (OOP)\nclass Vehicle {\n  var brand: String\n  init(brand: String) { self.brand = brand }\n  func drive() { print(\"\\(brand) is driving.\") }\n}\nclass Car: Vehicle {\n  var model: String\n  init(brand: String, model: String) {\n    self.model = model\n    super.init(brand: brand)\n  }\n  override func drive() { // Override เมธอดจาก Parent Class\n    print(\"\\(brand) \\(model) is driving fast!\")\n  }\n}\nlet myCar = Car(brand: \"Honda\", model: \"Civic\")\nmyCar.drive() // แสดงผล 'Honda Civic is driving fast!'\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย Do-Catch\nenum NetworkError: Error {\n  case badURL\n  case serverError(code: Int)\n}\nfunc fetchData(from urlString: String) throws -> String {\n  guard let url = URL(string: urlString) else { throw NetworkError.badURL }\n  // จำลองการเรียก API\n  if urlString.contains(\"error\") { throw NetworkError.serverError(code: 500) }\n  return \"Data from \\(urlString)\"\n}\ndo {\n  let data = try fetchData(from: \"https://api.example.com/data\")\n  print(data)\n  let errorData = try fetchData(from: \"https://api.example.com/error\")\n  print(errorData)\n} catch NetworkError.badURL {\n  print(\"Invalid URL provided.\")\n} catch NetworkError.serverError(let code) {\n  print(\"Server error with code: \\(code)\")\n} catch {\n  print(\"An unexpected error occurred: \\(error)\")\n}\n","// ตัวอย่างที่ 6: การใช้งาน Array และ Dictionary\nvar fruits = [\"Apple\", \"Banana\", \"Cherry\"]\nfruits.append(\"Date\") // เพิ่มสมาชิก\nprint(\"Fruits: \\(fruits)\")\n\nvar scores: [String: Int] = [\"Alice\": 90, \"Bob\": 75]\nscores[\"Charlie\"] = 88 // เพิ่มสมาชิกใหม่\nprint(\"Scores: \\(scores)\")\n"]}},{"id":63,"name":"SystemC","slug":"systemc","logo":"img/systemc.png","desc":"SystemC เป็นไลบรารี C++ มาตรฐานที่ใช้สำหรับ Hardware Design, Modeling, Simulation และ Verification ในระดับ Transaction-Level Modeling (TLM) และ Register-Transfer Level (RTL) ถูกพัฒนาขึ้นเพื่อใช้ในการออกแบบระบบอิเล็กทรอนิกส์ที่ซับซ้อน โดยผสานความสามารถของ C++ กับแนวคิดของ Hardware Description Language (HDL) เพื่อให้สามารถสร้างโมเดลฮาร์ดแวร์และซอฟต์แวร์ร่วมกันได้","by":"Open SystemC Initiative (OSCI) / Accellera Systems Initiative","yr":"1999 (เวอร์ชัน 1.0)","level":"4","par":["Object-Oriented","Imperative","Concurrent","Event-Driven"],"fields":["Embedded","Hardware","Digital","Hardware"],"rank":"Niche (เป็นมาตรฐานในอุตสาหกรรม EDA/Semiconductor)","salary_range":"฿40,000-70,000 บาท/เดือน (Junior), ฿70,000-130,000 บาท/เดือน (Senior)","salary":["veryhigh"],"pros":["ใช้ C++ เป็นพื้นฐาน ทำให้เข้าถึงไลบรารี C++ และประสิทธิภาพของ C++ ได้","รองรับการออกแบบในหลายระดับ Abstraction (TLM, RTL)","จำลองการทำงานแบบ Concurrency ได้ดี (Processes, Events)","ช่วยให้สามารถออกแบบ Hardware/Software Co-design ได้อย่างมีประสิทธิภาพ","มีเครื่องมือ EDA รองรับและเป็นมาตรฐานอุตสาหกรรม"],"cons":["Learning Curve สูง (ต้องเข้าใจทั้ง C++ และแนวคิดฮาร์ดแวร์)","การดีบักอาจซับซ้อน (เนื่องจากการทำงานแบบ Concurrent)","ไม่มี Garbage Collection (ต้องจัดการหน่วยความจำเองเหมือน C++)","ไม่เหมาะสำหรับแอปพลิเคชันทั่วไป","ชุมชนนักพัฒนาเฉพาะทาง"],"frameworks":["Accellera TLM-2.0 Standard"],"learn":["SystemC.org Official Website","Accellera Systems Initiative","Digital Design with SystemC (Book)","Online EDA Tutorials"],"variables":{"declaration (การประกาศ)":["sc_signal<bool> clk; // ประกาศสัญญาณนาฬิกา (ชนิด boolean)","sc_in<int> data_in; // ประกาศพอร์ตอินพุต (ชนิด int)","sc_out<sc_logic> data_out; // ประกาศพอร์ตเอาต์พุต (ชนิด sc_logic)"],"types (ประเภท)":["sc_bit // 1-bit logic type (0 หรือ 1)","sc_logic // 1-bit logic type (0, 1, X (Unknown), Z (High Impedance))","sc_bv<N> // Vector ของ sc_bit ขนาด N บิต","sc_lv<N> // Vector ของ sc_logic ขนาด N บิต","sc_int<N> // Signed integer ขนาด N บิต","sc_uint<N> // Unsigned integer ขนาด N บิต","sc_time // หน่วยเวลาสำหรับการจำลอง","sc_event // Event สำหรับการซิงโครไนซ์ Process"],"examples (ตัวอย่าง)":["// การประกาศสัญญาณและพอร์ต\n#include <systemc>\nusing namespace sc_core;\nusing namespace sc_dt;\nSC_MODULE(my_module) {\n  sc_in<bool> clk;          // พอร์ตอินพุตนาฬิกา\n  sc_in<sc_uint<8>> data;   // พอร์ตอินพุต 8 บิต unsigned integer\n  sc_out<sc_lv<16>> result; // พอร์ตเอาต์พุต 16 บิต logic vector\n\n  SC_CTOR(my_module) {\n    // Constructor ของ Module (ใช้สำหรับ Process binding)\n  }\n};","// การกำหนดค่าให้กับสัญญาณ\nsc_signal<int> counter_val;\ncounter_val = 5; // กำหนดค่าให้กับสัญญาณ","// การอ่านค่าจากพอร์ต\nint input_data = data_in.read();","// การเขียนค่าไปยังพอร์ต\ndata_out.write(SC_LOGIC_1);"]},"functions":{"declaration (การประกาศ)":["SC_METHOD(function_name); // ประกาศ Process แบบ Method (ทำงานเมื่อ Triggered)","SC_THREAD(function_name); // ประกาศ Process แบบ Thread (ทำงานแบบ Concurrent)","SC_CTHREAD(function_name, clock_signal); // ประกาศ Process แบบ Clocked Thread (ทำงานตาม Clock Edge)"],"examples (ตัวอย่าง)":["// การประกาศ Module และ Process\n#include <systemc>\nusing namespace sc_core;\n\nSC_MODULE(Adder) {\n  sc_in<int> in1, in2;  // อินพุต 2 ตัว\n  sc_out<int> sum_out; // ผลรวมเอาต์พุต\n\n  void do_add() { // Process แบบ Method\n    sum_out.write(in1.read() + in2.read());\n    std::cout << sc_time_stamp() << \": Adder: \" << in1.read() << \" + \" << in2.read() << \" = \" << sum_out.read() << std::endl;\n  }\n\n  SC_CTOR(Adder) { // Constructor ของ Module\n    SC_METHOD(do_add); // กำหนด do_add เป็น Method Process\n    sensitive << in1 << in2; // Process นี้จะทำงานเมื่อ in1 หรือ in2 เปลี่ยนแปลง\n  }\n};\n","// การเรียกใช้ฟังก์ชันและ Event Handling\nSC_MODULE(Timer) {\n  sc_out<bool> tick; // สัญญาณ tick\n  void run_timer() {\n    while (true) {\n      wait(10, SC_NS); // รอ 10 นาโนวินาที\n      tick.write(!tick.read()); // สลับค่า tick\n      std::cout << sc_time_stamp() << \": Timer ticked!\\n\";\n    }\n  }\n\n  SC_CTOR(Timer) {\n    SC_THREAD(run_timer); // กำหนด run_timer เป็น Thread Process\n  }\n};\n","// Asynchronous Programming (Processes และ Events)\n// SystemC จัดการ Asynchronous และ Concurrency ผ่าน Built-in Primitives เช่น Processes (SC_METHOD, SC_THREAD)\n// และ Events (sc_event) สำหรับการซิงโครไนซ์\nSC_MODULE(ProducerConsumer) {\n  sc_port<sc_fifo_out_if<int>> producer_port; // Port สำหรับ Producer\\n  sc_port<sc_fifo_in_if<int>> consumer_port; // Port สำหรับ Consumer\\n\\n  void producer_process() {\\n    int data = 0;\\n    while (true) {\\n      wait(2, SC_NS);\\n      producer_port->write(data++); // เขียนข้อมูลลง FIFO\\n      std::cout << sc_time_stamp() << \": Producer wrote \" << data - 1 << std::endl;\\n    }\\n  }\\n\\n  void consumer_process() {\\n    while (true) {\\n      int received_data = consumer_port->read(); // อ่านข้อมูลจาก FIFO\\n      std::cout << sc_time_stamp() << \": Consumer read \" << received_data << std::endl;\\n      wait(3, SC_NS);\\n    }\\n  }\\n\\n  SC_CTOR(ProducerConsumer) {\\n    SC_THREAD(producer_process);\\n    SC_THREAD(consumer_process);\\n  }\\n};"],"built_in (ในตัว)":["sc_start() // เริ่มการจำลอง","sc_stop() // หยุดการจำลอง","sc_time_stamp() // คืนค่าเวลาปัจจุบันของการจำลอง","wait() // ใช้หยุด Process ชั่วคราว (รอเวลาหรือ Event)","notify() // ใช้ Trigger Event","sc_report_error() // รายงานข้อผิดพลาด","sc_report_warning() // รายงานคำเตือน","SC_CTOR() // Macro สำหรับ Constructor ของ SystemC Module","sensitive << signal // กำหนดให้ Process ทำงานเมื่อสัญญาณเปลี่ยนแปลง"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว (C++ style)","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด (C++ style)"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else (C++ style)"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for (C++ style)","while (condition) { /* ... */ } // ลูป while (C++ style)"],"operators (ตัวดำเนินการ)":["C++ Operators: +, -, *, /, %, &&, ||, !, ==, !=, <, >, <=, >=, &, |, ^, ~, <<, >> // ตัวดำเนินการ C++ มาตรฐาน","<< // Operator สำหรับ sensitive list","-> // Operator สำหรับเข้าถึงสมาชิกของ Interface ผ่าน Port"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไขใน Process\nSC_MODULE(ThresholdDetector) {\n  sc_in<int> input_val;\n  sc_out<bool> output_flag;\n\n  void detect_threshold() {\n    if (input_val.read() > 100) {\n      output_flag.write(true);\n    } else {\n      output_flag.write(false);\n    }\n    std::cout << sc_time_stamp() << \": Input: \" << input_val.read() << \", Flag: \" << output_flag.read() << std::endl;\n  }\n\n  SC_CTOR(ThresholdDetector) {\n    SC_METHOD(detect_threshold);\n    sensitive << input_val;\n  }\n};\n","// ตัวอย่างที่ 2: การใช้วงลูปใน Thread Process\nSC_MODULE(Counter) {\n  sc_out<int> count_out;\n  sc_in<bool> reset_in;\n\n  void run_counter() {\n    int counter_val = 0;\n    while (true) {\n      if (reset_in.read()) {\n        counter_val = 0; // รีเซ็ตเคาน์เตอร์ถ้า reset เป็นจริง\n      } else {\n        counter_val++;\n      }\n      count_out.write(counter_val);\n      std::cout << sc_time_stamp() << \": Counter: \" << counter_val << std::endl;\n      wait(1, SC_NS); // รอ 1 นาโนวินาทีต่อรอบ\n    }\n  }\n\n  SC_CTOR(Counter) {\n    SC_THREAD(run_counter);\n    sensitive << reset_in; // หรือ sensitive << clk.pos() ถ้าเป็น clocked counter\n  }\n};\n","// ตัวอย่างที่ 3: การเชื่อมต่อ Module และรัน Simulation\n#include <systemc>\nusing namespace sc_core;\n\n// สมมติว่ามี Module Adder และ Timer ตามตัวอย่างด้านบนแล้ว\n\nint sc_main(int argc, char* argv[]) {\n  sc_signal<int> s_in1, s_in2, s_sum; // สัญญาณสำหรับเชื่อมต่อ\n  sc_signal<bool> s_tick; // สัญญาณสำหรับ Timer\n\n  // สร้าง instances ของ Module\n  Adder adder_inst(\"adder\");\n  Timer timer_inst(\"timer\");\n\n  // เชื่อมต่อพอร์ตกับสัญญาณ\n  adder_inst.in1(s_in1);\n  adder_inst.in2(s_in2);\n  adder_inst.sum_out(s_sum);\n\n  timer_inst.tick(s_tick);\n\n  // กำหนดค่าเริ่มต้นให้กับสัญญาณ\n  s_in1.write(5);\n  s_in2.write(3);\n\n  // กำหนดค่า input ให้เปลี่ยนแปลงระหว่าง Simulation\n  sc_start(10, SC_NS); // รัน Simulation 10 ns\n  s_in1.write(7); // เปลี่ยนค่า s_in1\n  s_in2.write(2); // เปลี่ยนค่า s_in2\n\n  sc_start(10, SC_NS); // รันต่ออีก 10 ns\n\n  sc_stop(); // หยุด Simulation\n  return 0;\n}\n"]}},{"id":52,"name":"SystemVerilog","slug":"systemverilog","logo":"img/systemverilog.png","desc":"SystemVerilog เป็นส่วนขยายที่ทรงพลังของ Verilog Hardware Description Language (HDL) ที่เพิ่มความสามารถด้าน Hardware Description, Hardware Verification และ Software-like Programming เข้าไปในภาษาเดียว ทำให้เป็นภาษามาตรฐานสำหรับงานออกแบบและตรวจสอบวงจรดิจิทัลที่ซับซ้อนในระดับสูง (SoC)","by":"Accellera, IEEE","yr":"2002 (Accellera), 2005 (IEEE 1800-2005)","level":"1","par":["Declarative","Concurrent","Structured","Object-Oriented","Constraint-Random"],"fields":["Embedded","Hardware","Digital"],"rank":"1 ใน HDL และ Verification (ใช้มากที่สุดในอุตสาหกรรม)","salary_range":"฿50,000-90,000 บาท/เดือน (Junior), ฿90,000-180,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ความสามารถในการ Verify Hardware ที่ทรงพลัง (Assertion, Coverage)","รองรับ Object-Oriented Programming (OOP) สำหรับ Testbench","Randomization และ Constraint Solving ในตัว","สามารถเขียน Testbench ที่นำกลับมาใช้ใหม่ได้ง่าย (Reusability)","เป็นภาษามาตรฐานในอุตสาหกรรมการออกแบบชิป"],"cons":["Learning Curve สูงมาก (ต้องเข้าใจทั้ง Hardware และ Software)","Syntax ที่ซับซ้อนและมีคุณสมบัติเยอะมาก","เครื่องมือเฉพาะทาง (EDA Tools) มีราคาแพง","การดีบักซับซ้อนและใช้เวลานาน","เวลาในการสังเคราะห์และรันบน Hardware อาจนานมากสำหรับโปรเจกต์ขนาดใหญ่"],"frameworks":["UVM (Universal Verification Methodology)"],"learn":["SystemVerilog for Verification (book)","Verification Academy","IEEE 1800 Standard","DVCon Papers"],"variables":{"declaration (การประกาศ)":["logic my_signal; // ประกาศ logic (แทน wire/reg, ยืดหยุ่นกว่า)","int my_integer = 10; // ประกาศ integer (สำหรับ Verification)","bit [7:0] data_bus; // ประกาศ bit vector ขนาด 8 บิต","enum {STATE_IDLE, STATE_ACTIVE} current_state; // ประกาศ Enumerated Type","class MyObject; // ประกาศ Class (สำหรับ OOP)"],"types (ประเภท)":["logic // ใช้แทน wire/reg, ยืดหยุ่นกว่า (4-state logic)","bit // 2-state logic (0, 1) เหมาะสำหรับ Verification","byte, shortint, int, longint // Signed Integers ขนาดต่างๆ","time, real, realtime // เวลาและทศนิยม (สำหรับ Simulation)","string // สตริง","enum // Enumerated Type","struct // Structure (รวมข้อมูลหลายประเภทเข้าด้วยกัน)","union // Union (เก็บข้อมูลหลายประเภทในหน่วยความจำเดียวกัน)","class // Class (สำหรับ OOP)","interface // Interface (สำหรับการเชื่อมต่อ Module/Testbench)","mailbox // Mailbox (สำหรับการสื่อสารระหว่าง Processes)"],"examples (ตัวอย่าง)":["logic [15:0] address; // ประกาศ logic vector ขนาด 16 บิต","int counter = 0; // ประกาศตัวแปร int สำหรับนับ","string user_msg = \"SystemVerilog\"; // ประกาศสตริง","typedef struct packed { logic [7:0] opcode; logic [23:0] address; } Instruction; // กำหนด Struct Type\nInstruction my_instr; // ประกาศตัวแปรจาก Struct Type","class Transaction; // การประกาศคลาสสำหรับเก็บข้อมูล Transaction\n  rand int id;\n  rand logic [7:0] data;\nendclass"]},"functions":{"declaration (การออกแบบ Hardware และ Verification)":["module Module_Name (port_list); // การประกาศ Module (สำหรับ Hardware)","program Program_Name; // การประกาศ Program (สำหรับ Testbench Top-level)","function int my_function (input int a); // การประกาศ Function (มีค่าคืนกลับ)","task my_task (input int data); // การประกาศ Task (ไม่มีค่าคืนกลับ, สามารถหน่วงเวลาได้)","initial begin // Initial Block (สำหรับ Simulation Initialization)","always_ff @(posedge clk or negedge reset) begin // Always FF Block (สำหรับ Sequential Logic)","always_comb begin // Always Comb Block (สำหรับ Combinational Logic)"],"examples (ตัวอย่าง)":["// Module: Full Adder (วงจรบวกเต็ม)\nmodule full_adder (input a, b, cin, output sum, cout);\n  logic s1, c1, c2;\n  assign s1 = a ^ b;\n  assign c1 = a & b;\n  assign sum = s1 ^ cin;\n  assign cout = c1 | (s1 & cin);\nendmodule\n","// Task: Write Data (สำหรับ Testbench)\ntask write_data (input logic [7:0] addr, input logic [7:0] data);\n  #10; // หน่วงเวลา 10 units\n  // Code to drive data to DUT\n  $display(\"Writing %h to address %h\", data, addr);\n  #5; // หน่วงเวลา 5 units\nendtask\n","// Function: Calculate Parity (สำหรับ Design หรือ Testbench)\nfunction automatic bit calculate_parity (input bit [7:0] in_data);\n  bit parity = 0;\n  for (int i = 0; i < 8; i++) begin\n    parity = parity ^ in_data[i];\n  end\n  return parity;\nendfunction\n","// Class: Scoreboard (สำหรับ Verification)\nclass Scoreboard;\n  Transaction expected_queue[$]; // Queue of expected transactions\n  Transaction actual_queue[$]; // Queue of actual transactions\n\n  function new();\n    expected_queue = new;\n    actual_queue = new;\n  endfunction\n\n  function void compare();\n    if (expected_queue.size() != actual_queue.size()) begin\n      $error(\"Queue size mismatch: Expected %0d, Actual %0d\", expected_queue.size(), actual_queue.size());\n    end else begin\n      // Detailed comparison logic here\n      $info(\"All transactions matched!\");\n    end\n  endfunction\nendclass\n"],"built_in (ในตัว)":["assign // ใช้กำหนดค่าแบบ Combinational Logic (Continuous Assignment)","always_ff // Always Block สำหรับ Sequential Logic (Synchronous Logic)","always_comb // Always Block สำหรับ Combinational Logic","always_latch // Always Block สำหรับ Latch Logic","initial // Initial Block (สำหรับการจำลอง)","final // Final Block (สำหรับสรุปผลการจำลอง)","$display // ใช้แสดงผลข้อความและค่าตัวแปรใน Simulation Console","$monitor // ใช้แสดงผลค่าตัวแปรเมื่อมีการเปลี่ยนแปลงใน Simulation Console","$time // ฟังก์ชันสำหรับเรียกดูเวลาใน Simulation","$finish // ใช้หยุด Simulation","$error // ใช้แสดง Error Message ใน Simulation","$warning // ใช้แสดง Warning Message ใน Simulation","$info // ใช้แสดง Information Message ใน Simulation","assert // ใช้สำหรับ Hardware Assertion (ตรวจสอบคุณสมบัติ)","cover // ใช้สำหรับ Functional Coverage (ตรวจสอบความครอบคลุมของการทดสอบ)","rand // Property สำหรับ Randomization","constraint // ใช้กำหนดข้อจำกัดในการ Randomization"]},"syntax":{"comments (คอมเมนต์)":["// Single-line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) begin /* ... */ end else if (condition) begin /* ... */ end else begin /* ... */ end // คำสั่ง if-else if-else","case (expression) case_value: /* ... */ default: /* ... */ endcase // คำสั่ง case","unique case (expression) ... endcase // Unique Case (ตรวจสอบว่ามีเพียง Case เดียวที่ตรงกัน)","priority case (expression) ... endcase // Priority Case (ใช้ Case แรกที่ตรงกัน)"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) begin /* ... */ end // ลูป for","while (condition) begin /* ... */ end // ลูป while","repeat (N) begin /* ... */ end // ลูป repeat (วนซ้ำ N ครั้ง)","forever begin /* ... */ end // ลูปไม่รู้จบ (สำหรับสร้าง Clock/Reset ใน Testbench)","foreach (array_name[index]) begin /* ... */ end // ลูป foreach สำหรับวนซ้ำ Array"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: & (AND), | (OR), ^ (XOR), ~ (NOT) // ตัวดำเนินการระดับบิต","Reduction: & (Reduction AND), | (Reduction OR), ^ (Reduction XOR) // ตัวดำเนินการลดบิต","Shift: << (Left Shift), >> (Right Shift) // ตัวดำเนินการ Shift","Concatenation: {a, b} // ตัวดำเนินการเชื่อมต่อบิต/เวกเตอร์","Replication: {N{a}} // ตัวดำเนินการทำซ้ำบิต/เวกเตอร์ N ครั้ง","Blocking Assignment: = // การกำหนดค่าแบบ Blocking (Sequential Execution)","Non-blocking Assignment: <= // การกำหนดค่าแบบ Non-blocking (Concurrent Execution, ใช้สำหรับ Sequential Logic)","Increment/Decrement: ++, -- // ตัวดำเนินการเพิ่ม/ลดค่า (สำหรับ Variable)","Equality/Inequality: ==, !=, ===, !== // เปรียบเทียบ (2-state/4-state)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else ใน Always_Comb (Combinational Logic)\nmodule priority_encoder (input [2:0] in_vec, output logic [1:0] out_enc, output logic valid);\n  always_comb begin\n    valid = 1'b1;\n    case (in_vec)\n      3'b100: out_enc = 2'b00; // if in_vec[2] is 1\n      3'b010: out_enc = 2'b01; // if in_vec[1] is 1\n      3'b001: out_enc = 2'b10; // if in_vec[0] is 1\n      default: begin\n        out_enc = 2'b00; // Or 2'bxx\n        valid = 1'b0;\n      end\n    endcase\n  end\nendmodule\n","// ตัวอย่างที่ 2: การใช้วงลูป For และ Foreach ใน Testbench\nprogram test;\n  initial begin\n    int data_array [5] = '{10, 20, 30, 40, 50};\n    $display(\"--- For Loop ---\");\n    for (int i = 0; i < data_array.size(); i++) begin\n      $display(\"Element at %0d: %0d\", i, data_array[i]);\n    end\n    $display(\"--- Foreach Loop ---\");\n    foreach (data_array[idx]) begin\n      $display(\"Element at %0d: %0d\", idx, data_array[idx]);\n    end\n    $finish;\n  end\nendprogram\n","// ตัวอย่างที่ 3: การใช้ Assertions (สำหรับตรวจสอบคุณสมบัติ)\nmodule dut (input clk, input reset, input data_in, output logic data_out);\n  // Basic design logic\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) data_out <= 1'b0;\n    else data_out <= data_in;\n  end\n\n  // Assertion: data_out should always be 0 if reset is active\n  // property reset_assert;\n  //   @(posedge clk) reset |-> (data_out == 1'b0);\n  // endproperty\n  // assert property (reset_assert) $info(\"Reset assertion passed\");\n\n  // Assertion: data_out should follow data_in after 1 clock cycle when not reset\n  // property data_flow_assert;\n  //   @(posedge clk) (!reset && $fell(data_in)) |-> ##1 (!data_out);\n  // endproperty\n  // assert property (data_flow_assert) $info(\"Data flow assertion passed\");\nendmodule\n","// ตัวอย่างที่ 4: การใช้งาน Randomization และ Constraints ใน Class\nclass Configuration;\n  rand int num_packets;\n  rand int packet_size;\n\n  constraint c_num_packets {\n    num_packets inside {[1:10]};\n  }\n  constraint c_packet_size {\n    packet_size inside {[64:256]};\n    packet_size % 4 == 0; // ต้องเป็นผลคูณของ 4\n  }\n\n  function void print_config();\n    $display(\"Generated Config: Num Packets = %0d, Packet Size = %0d\", num_packets, packet_size);\n  endfunction\nendclass\n\nprogram test_randomization;\n  initial begin\n    Configuration cfg = new();\n    if (cfg.randomize()) begin\n      cfg.print_config();\n    end else begin\n      $error(\"Failed to randomize configuration!\");\n    end\n    // สามารถ override constraint ได้ขณะ randomize\n    if (cfg.randomize() with { num_packets == 20; packet_size > 100; }) begin\n      cfg.print_config();\n    end\n    $finish;\n  end\nendprogram\n","// ตัวอย่างที่ 5: การใช้งาน Interface เพื่อเชื่อมต่อ Design และ Testbench\ninterface axi_bus_if (\n  input logic clk,\n  input logic reset\n);\n  logic [31:0] awaddr;\n  logic [31:0] wdata;\n  logic        wvalid;\n  // ... other signals\n\n  modport master (\n    output awaddr,\n    output wdata,\n    output wvalid,\n    input  clk,\n    input  reset\n  );\n\n  modport slave (\n    input  awaddr,\n    input  wdata,\n    input  wvalid,\n    input  clk,\n    input  reset\n  );\nendinterface\n\n// การใช้งานใน Module (Design)\n// module my_controller (\n//   axi_bus_if.slave s_axi // s_axi เป็น instance ของ interface\n// );\n//   // Access signals: s_axi.awaddr, s_axi.wdata, etc.\n// endmodule\n\n// การใช้งานใน Testbench\n// program my_test_program;\n//   axi_bus_if axi_inst ( .clk(test_clk), .reset(test_reset) );\n//   // Drive signals: axi_inst.master.awaddr = ...\n// endprogram\n"]}},{"id":9,"name":"TypeScript","slug":"typescript","logo":"img/ts.png","desc":"TypeScript คือ Superset ของ JavaScript ที่เพิ่มความสามารถด้าน Static Typing ทำให้โค้ดมีโครงสร้างมากขึ้น, ตรวจสอบข้อผิดพลาดได้ตั้งแต่ตอนพัฒนา และช่วยให้พัฒนาโปรเจกต์ขนาดใหญ่ได้ง่ายขึ้น","by":"Microsoft","yr":"2012","level":"4","par":["Multi-paradigm","Object-Oriented","Functional"],"fields":["Frontend","Backend","Cloud","Plugin","Blockchain","Render"],"rank":"12 แต่เติบโตแรงใน Modern Web Development (ใช้โดย 38.8% ของนักพัฒนา)","salary_range":"฿40,000-65,000 บาท/เดือน (Junior), ฿65,000-120,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["เพิ่มความปลอดภัยของโค้ดด้วย Type Checking","ช่วยให้โค้ดมีโครงสร้างและอ่านง่ายขึ้น","รองรับคุณสมบัติใหม่ๆ ของ JavaScript ล่วงหน้า","เครื่องมือพัฒนา (IDE) รองรับได้ดีเยี่ยม","ปรับปรุงการ Refactor และ Maintenance โค้ด"],"cons":["ต้องใช้เวลาเรียนรู้เพิ่มเติมจาก JavaScript","ต้องมีการตั้งค่าและ Compile ก่อนรัน (Transpilation)","อาจเพิ่มความซับซ้อนในโปรเจกต์ขนาดเล็ก","Error Messages บางครั้งอาจเข้าใจยาก"],"frameworks":["Angular","React (with TS)","Vue.js (with TS)","Node.js (with TS)","NestJS"],"learn":["TypeScript Handbook","Definitely Typed","TypeScript for JavaScript Developers","FreeCodeCamp TypeScript"],"variables":{"declaration (การประกาศ)":["let name: string = \"Alice\"; // การประกาศตัวแปรชนิด string","const age: number = 25; // การประกาศค่าคงที่ชนิด number","let isActive: boolean = true; // การประกาศตัวแปรชนิด boolean"],"types (ประเภท)":["string // ประเภทข้อมูลข้อความ","number // ประเภทข้อมูลตัวเลข (ทั้งจำนวนเต็มและทศนิยม)","boolean // ประเภทข้อมูลค่าจริงหรือเท็จ","null // ประเภทข้อมูลค่าว่างเปล่าโดยเจตนา","undefined // ประเภทข้อมูลค่าที่ยังไม่ได้กำหนด","symbol // ประเภทข้อมูลค่าเฉพาะที่ไม่ซ้ำกัน","bigint // ประเภทข้อมูลตัวเลขขนาดใหญ่มาก","any // ประเภทข้อมูลที่ยอมรับค่าใดก็ได้ (ควรหลีกเลี่ยง)","unknown // ประเภทข้อมูลที่ระบุว่าไม่ทราบประเภท แต่ต้องตรวจสอบก่อนใช้","void // ประเภทข้อมูลสำหรับฟังก์ชันที่ไม่มีค่าคืนกลับ","never // ประเภทข้อมูลสำหรับฟังก์ชันที่ไม่สามารถทำจนจบได้","Array<T> // Generic Type สำหรับ Array (เช่น Array<string>)","T[] // Shorthand สำหรับ Array (เช่น string[])","Object // ประเภทข้อมูลกลุ่มของข้อมูลที่มีโครงสร้าง","Tuple // ประเภทข้อมูลรายการที่มีจำนวนและประเภทที่กำหนดไว้ล่วงหน้า","Enum // ประเภทข้อมูลสำหรับชุดของค่าคงที่ที่กำหนดชื่อ"],"examples (ตัวอย่าง)":["let message: string = \"Hello TS!\"; // กำหนดตัวแปร message เป็นสตริง","let count: number = 50; // กำหนดตัวแปร count เป็นตัวเลข","const PI: number = 3.14159; // กำหนดค่าคงที่ PI","let users: string[] = [\"Bob\", \"Charlie\"]; // กำหนดตัวแปร users เป็น Array ของสตริง","type User = { id: number; name: string; }; // กำหนด Type Alias สำหรับ Object\nlet user: User = { id: 1, name: \"Alice\" }; // กำหนดตัวแปร user เป็น Object ตาม Type","let mixedTuple: [string, number] = [\"TS\", 2024]; // กำหนดตัวแปรเป็น Tuple"]},"functions":{"declaration (การประกาศ)":["function funcName(param: Type): ReturnType { ... } // การประกาศฟังก์ชันแบบปกติ","const arrowFunc = (param: Type): ReturnType => { ... }; // การประกาศฟังก์ชันแบบ Arrow Function"],"examples (ตัวอย่าง)":["function sum(a: number, b: number): number { return a + b; } // ฟังก์ชันบวกเลขสองจำนวน","const greet = (name: string): string => `Hello, ${name}!`; // ฟังก์ชัน Arrow Function สำหรับทักทาย","// การเรียกใช้ฟังก์ชัน\nlet total: number = sum(10, 5); // total จะมีค่า 15\nlet welcome: string = greet(\"TypeScript\"); // welcome จะมีค่า 'Hello, TypeScript!'\n","function printOptional(message: string, count?: number): void { // ฟังก์ชันที่มี Optional Parameter\n  console.log(message);\n  if (count !== undefined) {\n    console.log(`Count: ${count}`);\n  }\n}\nprintOptional(\"Hello\"); // เรียกใช้โดยไม่ส่ง count\nprintOptional(\"Hello\", 5); // เรียกใช้พร้อมส่ง count\n","function sumRest(...numbers: number[]): number { // ฟังก์ชันที่มี Rest Parameters (รับอาร์กิวเมนต์ได้ไม่จำกัด)\n  return numbers.reduce((acc, current) => acc + current, 0);\n}\nconsole.log(sumRest(1, 2, 3, 4)); // แสดงผล 10\n","// Asynchronous Function (using async/await)\n// โค้ดด้านล่างนี้เป็นตัวอย่างการใช้งานฟังก์ชันแบบ Asynchronous ซึ่งต้องรันในบริบทของ JavaScript runtime (เช่น Node.js, Browser)\n// async function fetchData(): Promise<string> {\n//   console.log(\"Fetching data...\");\n//   await new Promise(resolve => setTimeout(resolve, 1000)); // จำลองการหน่วงเวลา (เช่น การเรียก API)\n//   console.log(\"Data fetched!\");\n//   return \"Data fetched asynchronously\";\n// }\n// // ตัวอย่างการเรียกใช้ Async Function (ต้องอยู่ในบริบทของ async function อื่น)\n// /*\n// (async () => {\n//     const data = await fetchData();\n//     console.log(\"Received: \", data);\n// })();\n// */"],"built_in (ในตัว)":["console.log() // ใช้แสดงผลข้อมูลใน Console (สำหรับนักพัฒนา)","Array.prototype.map() // เมธอดสำหรับวนซ้ำและสร้าง Array ใหม่","JSON.parse() // ใช้แปลงข้อความที่เป็นรูปแบบ JSON ให้เป็น Object","Date // Object สำหรับทำงานกับวันที่และเวลา","Promise // Object สำหรับจัดการการทำงานแบบ Asynchronous"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (let i = 0; i < 5; i++) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","for (const item of array) { /* ... */ } // ลูป for...of สำหรับวนซ้ำ Iterable objects (เช่น Array)","array.forEach(item => { /* ... */ }); // เมธอด forEach สำหรับ Array"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, ===, !==, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ (หลวม/เข้มงวด), ไม่เท่ากับ (หลวม/เข้มงวด) ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nlet temperature: number = 25;\nif (temperature > 30) {\n  console.log('Hot day');\n} else if (temperature < 10) {\n  console.log('Cold day');\n} else {\n  console.log('Normal day');\n}\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\nfor (let i = 0; i < 3; i++) {\n  console.log(`Loop TS: ${i}`);\n}\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nlet day: string = \"Wednesday\";\nswitch (day) {\n  case \"Monday\":\n    console.log(\"Start of week\");\n    break;\n  case \"Friday\":\n    console.log(\"End of week\");\n    break;\n  default:\n    console.log(\"Mid-week\");\n}\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Interface (OOP)\ninterface Shape {\n  area(): number;\n}\nclass Circle implements Shape {\n  radius: number;\n  constructor(radius: number) {\n    this.radius = radius;\n  }\n  area(): number {\n    return Math.PI * this.radius * this.radius;\n  }\n}\nlet myCircle = new Circle(5);\nconsole.log(`Area of circle: ${myCircle.area()}`);\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Error Handling) ด้วย Try-Catch\ntry {\n  let num1: number = 10;\n  let num2: number = 0;\n  if (num2 === 0) {\n    throw new Error(\"Cannot divide by zero\");\n  }\n  let result: number = num1 / num2;\n  console.log(\"Result: \", result);\n} catch (error: any) {\n  console.error(\"Caught an error: \", error.message);\n}\n","// ตัวอย่างที่ 6: การใช้งาน Enum\nenum Direction {\n  Up, Down, Left, Right\n}\nlet move: Direction = Direction.Up;\nconsole.log(`Moving: ${Direction[move]}`); // แสดงผล 'Moving: Up'\n"]}},{"id":40,"name":"T-SQL","slug":"tsql","logo":"img/sqlserver.png","desc":"T-SQL เป็นภาษา Extension ที่เพิ่มความสามารถเชิงโครงสร้าง (Procedural) ให้กับ SQL สำหรับ Microsoft SQL Server และ Azure SQL Database ใช้สำหรับสร้าง Stored Procedures, Functions, และ Triggers เพื่อขยายความสามารถของ SQL และประมวลผลข้อมูลที่ซับซ้อนบนฐานข้อมูลฝั่ง Server","by":"Microsoft","yr":"1980s","level":"5","par":["Procedural","Declarative (SQL embedded)"],"fields":["DB"],"rank":"35+ แข็งแกร่งใน Microsoft SQL Server Environment","salary_range":"฿26,000-42,000 บาท/เดือน (Junior), ฿42,000-72,000 บาท/เดือน (Senior)","salary":["low","mid","high"],"pros":["มีประสิทธิภาพในการประมวลผลข้อมูลขนาดใหญ่บน SQL Server","ช่วยลด Network Traffic","รองรับ Transaction Control ได้ดี","เป็นส่วนสำคัญของ Microsoft SQL Server Ecosystem"],"cons":["เฉพาะสำหรับ Microsoft SQL Server","การจัดการ Version Control อาจเป็นเรื่องท้าทาย","ไวยากรณ์และแนวคิดแตกต่างจากภาษาโปรแกรมมิ่งทั่วไป"],"frameworks":[],"learn":["Microsoft T-SQL Documentation","SQL Server Tutorials"],"variables":{"declaration (การประกาศ)":["DECLARE @variable_name datatype; // รูปแบบการประกาศตัวแปร"],"types (ประเภท)":["VARCHAR // สตริงความยาวแปรผัน","NVARCHAR // สตริงความยาวแปรผัน (รองรับ Unicode)","INT // จำนวนเต็ม","DECIMAL // ตัวเลขทศนิยมที่มีความแม่นยำคงที่","DATETIME // วันที่และเวลา","BIT // ค่าบูลีน (0 หรือ 1)","TABLE // ประเภทข้อมูลตาราง (สำหรับตัวแปรตารางชั่วคราว)"],"examples (ตัวอย่าง)":["DECLARE @employeeName VARCHAR(100); // ประกาศตัวแปรสตริงชื่อ @employeeName","DECLARE @salary DECIMAL(10, 2) = 55000.00; // ประกาศตัวแปรตัวเลขทศนิยมพร้อมค่าเริ่มต้น","SELECT @employeeName = Name FROM Employees WHERE Id = 2; // กำหนดค่าให้กับตัวแปรจากผลลัพธ์ Query"]},"functions":{"declaration (การประกาศ)":["CREATE FUNCTION function_name (@params datatype) RETURNS datatype AS BEGIN ... END; // รูปแบบการประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["CREATE FUNCTION dbo.GetTotalSales (@year INT) RETURNS DECIMAL(18,2) AS\nBEGIN\n    DECLARE @total DECIMAL(18,2);\n    SELECT @total = SUM(SalesAmount) FROM Sales WHERE YEAR(SaleDate) = @year;\n    RETURN @total;\nEND;\n","CREATE FUNCTION dbo.GetFullName (@firstName NVARCHAR(50), @lastName NVARCHAR(50)) RETURNS NVARCHAR(100) AS\nBEGIN\n    RETURN @firstName + ' ' + @lastName;\nEND;\n","// การเรียกใช้ฟังก์ชัน\nSELECT dbo.GetTotalSales(2023) AS TotalSalesFor2023;\nSELECT dbo.GetFullName('John', 'Doe') AS EmployeeFullName;"],"built_in (ในตัว)":["PRINT // ใช้แสดงผลข้อความออกทาง Console/Messages Tab","GETDATE // ดึงวันที่และเวลาปัจจุบันของระบบ","SUBSTRING // ดึงสตริงย่อยจากสตริง","SUM // หาผลรวมของกลุ่มข้อมูล","COUNT // นับจำนวนแถวในกลุ่มข้อมูล","AVG // หาค่าเฉลี่ยของกลุ่มข้อมูล","MAX // หาค่าสูงสุดในกลุ่มข้อมูล","MIN // หาค่าต่ำสุดในกลุ่มข้อมูล","CAST // แปลงข้อมูลจากประเภทหนึ่งไปอีกประเภทหนึ่ง","CONVERT // แปลงข้อมูลจากประเภทหนึ่งไปอีกประเภทหนึ่ง (มี Option มากกว่า CAST)"],"async (แนวคิด)":["// T-SQL เป็นภาษาที่ทำงานบน Database Server และโดยธรรมชาติเป็น Synchronous\n-- การทำงานแบบ Asynchronous มักจะทำผ่านเทคนิคเช่น Service Broker (สำหรับ Message Queuing)\n-- หรือการใช้ SQL Agent Jobs สำหรับการรันงาน Background\n-- ไม่ได้มีโครงสร้าง async/await เหมือนภาษาสมัยใหม่"]},"syntax":{"comments (คอมเมนต์)":["-- Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi line */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["IF condition BEGIN ... END ELSE BEGIN ... END // คำสั่ง IF-ELSE","CASE WHEN condition THEN result ELSE result END // คำสั่ง CASE (คล้าย If-Else หรือ Switch)"],"loops (การวนซ้ำ)":["WHILE condition BEGIN ... END // ลูป WHILE"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: = // ตัวดำเนินการกำหนดค่า","Comparison: =, <>, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: AND, OR, NOT // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","+ (Concatenation for strings) // ตัวดำเนินการเชื่อมสตริง"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (IF-ELSE)\nDECLARE @salary DECIMAL(10, 2) = 65000.00;\nIF @salary > 60000\nBEGIN\n    PRINT 'High Salary';\nEND\nELSE\nBEGIN\n    PRINT 'Standard Salary';\nEND;\n","// ตัวอย่างที่ 2: การใช้วงลูป WHILE\nDECLARE @counter INT = 1;\nWHILE @counter <= 5\nBEGIN\n    PRINT 'Loop: ' + CAST(@counter AS VARCHAR); // CAST ใช้แปลง INT เป็น VARCHAR เพื่อเชื่อมสตริง\n    SET @counter = @counter + 1;\nEND;\n","// ตัวอย่างที่ 3: การใช้ CASE Statement\nSELECT\n    ProductName,\n    Price,\n    CASE\n        WHEN Price > 1000 THEN 'Expensive'\n        WHEN Price >= 500 THEN 'Moderate'\n        ELSE 'Affordable'\n    END AS PriceCategory\nFROM Products;\n","// ตัวอย่างที่ 4: การจัดการข้อผิดพลาด (TRY-CATCH)\nBEGIN TRY\n    DECLARE @num1 INT = 10;\n    DECLARE @num2 INT = 0;\n    DECLARE @result INT;\n    SET @result = @num1 / @num2; -- จะเกิด Division by zero error\n    PRINT 'Result: ' + CAST(@result AS VARCHAR);\nEND TRY\nBEGIN CATCH\n    PRINT 'Error occurred: ' + ERROR_MESSAGE();\nEND CATCH;\n","// ตัวอย่างที่ 5: การใช้งาน Stored Procedure\n-- CREATE PROCEDURE dbo.GetEmployeeDetails\n--     @EmployeeId INT\n-- AS\n-- BEGIN\n--     SELECT EmployeeId, Name, Salary FROM Employees WHERE EmployeeId = @EmployeeId;\n-- END;\n-- EXEC dbo.GetEmployeeDetails @EmployeeId = 1; -- การเรียกใช้ Stored Procedure\n"]}},{"id":50,"name":"Vala","slug":"vala","logo":"img/vala.png","desc":"Vala เป็นภาษาโปรแกรมที่คอมไพล์เป็น C โดยอัตโนมัติ ซึ่งออกแบบมาเพื่อพัฒนาแอปพลิเคชันโดยใช้ GLib และ GNOME Libraries โดยเฉพาะ ทำให้สามารถเข้าถึง Object-Oriented Frameworks ที่เขียนด้วย C ได้ง่ายขึ้น มีไวยากรณ์คล้าย C# หรือ Java แต่ให้ประสิทธิภาพใกล้เคียงกับ C/C++","by":"J. B. Evain, Raffaele Sandrini, et al. (GNOME)","yr":"2006","level":"4","par":["Object-Oriented","Imperative","Structured"],"fields":["Desktop"],"rank":"45+ Niche ใน GNOME Development","salary_range":"฿30,000-50,000 บาท/เดือน (Junior), ฿50,000-85,000 บาท/เดือน (Senior)","salary":["mid","high"],"pros":["ประสิทธิภาพสูง (คอมไพล์เป็น Native C)","ไวยากรณ์ทันสมัยและคุ้นเคยสำหรับนักพัฒนา C#/Java","เข้าถึง GNOME/GTK+ Libraries ได้ง่ายและเป็นธรรมชาติ","มี Garbage Collection (Reference Counting)","เหมาะสำหรับพัฒนา Desktop Application บน Linux"],"cons":["ผูกติดกับ GNOME Ecosystem ค่อนข้างมาก","ชุมชนนักพัฒนาเล็กและเฉพาะทาง","ขาด Library และ Frameworks ที่หลากหลายเมื่อเทียบกับภาษาหลัก","ทรัพยากรการเรียนรู้มีจำกัด","การดีบักอาจซับซ้อนขึ้นเมื่อต้องทำงานกับโค้ด C ที่ถูก Generate"],"frameworks":["GTK+ (GUI Library)","GLib (Core Utility Library)"],"learn":["Vala-Lang.org Official Documentation","Vala Tutorial","GNOME Developer Documentation"],"variables":{"declaration (การประกาศ)":["int my_int = 10; // การประกาศตัวแปรจำนวนเต็ม","string my_string = \"Hello Vala\"; // การประกาศตัวแปรสตริง","bool is_active = true; // การประกาศตัวแปรบูลีน"],"types (ประเภท)":["int // จำนวนเต็ม (เช่น int8, int16, int32, int64)","uint // จำนวนเต็มบวก (เช่น uint8, uint16, uint32, uint64)","float // ทศนิยมความแม่นยำเดี่ยว","double // ทศนิยมความแม่นยำคู่","bool // ค่าตรรกะ (true/false)","char // ตัวอักขระ","string // ข้อความ","array<T> // อาร์เรย์ (Fixed-size)","list<T> // List (Dynamic, Generic)","hash_table<K, V> // Hash Table (Key-Value pairs)","enum // Enumeration Type","struct // Structure (โครงสร้างข้อมูล)","class // Class (สำหรับ Object-Oriented)"],"examples (ตัวอย่าง)":["int counter = 0; // กำหนดตัวแปร counter เป็นจำนวนเต็ม 0","string user_name = \"Vala Dev\"; // กำหนดตัวแปร user_name เป็นสตริง","bool is_valid = false; // กำหนดตัวแปร is_valid เป็น Boolean","var numbers = {1, 2, 3}; // สร้าง Array (ใช้ var สำหรับ Type Inference)","List<string> fruit_list = new List<string>(); // สร้าง Generic List\nfruit_list.add(\"Apple\");"]},"functions":{"declaration (การประกาศ)":["public return_type function_name(param1_type param1_name) { /* ... */ } // การประกาศฟังก์ชัน/เมธอด"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\npublic int add(int a, int b) {\n  return a + b;\n}\n","// ฟังก์ชันทักทาย (ใช้ stdout.printf สำหรับแสดงผล)\npublic void greet(string name) {\n  stdout.printf(\"Hello, %s!\\n\", name);\n}\n","// การเรียกใช้ฟังก์ชัน:\n// int sum_result = add(10, 20); // sum_result จะมีค่า 30\n// greet(\"GNOME User\"); // แสดงผล 'Hello, GNOME User!'\n","// เมธอดบนคลาส\npublic class MyClass : GLib.Object {\n  public int value;\n  public MyClass(int initial_value) {\n    this.value = initial_value;\n  }\n  public void print_value() {\n    stdout.printf(\"My value is: %d\\n\", this.value);\n  }\n}\n// การสร้าง Object และเรียกใช้เมธอด:\n// var obj = new MyClass(123);\n// obj.print_value(); // My value is: 123\n","// Asynchronous Programming (Asynchronous Methods / Futures)\n// Vala รองรับ Asynchronous Programming ผ่าน Asynchronous Methods และ Futures\n// ซึ่งทำให้การเขียนโค้ดที่ต้องรอ I/O หรือการทำงานคู่ขนานทำได้ง่ายขึ้น\n// ต้องใช้ GLib.MainLoop สำหรับการจัดการ Event Loop\n// private static async void fetch_data() {\n//   stdout.printf(\"Fetching data...\\n\");\n//   // Simulate a long-running operation with GLib.Timeout.add_seconds\n//   // This part typically involves GIO async operations, for simplicity, we simulate a delay.\n//   var loop = new GLib.MainLoop(null, false);\n//   GLib.Timeout.add_seconds(1, () => {\n//     stdout.printf(\"Data fetched!\\n\");\n//     loop.quit();\n//     return false; // Don't repeat the timeout\n//   });\n//   await loop.run_async(); // Wait for the main loop to quit after timeout\n//   stdout.printf(\"Data processed asynchronously.\\n\");\n// }\n// // ในฟังก์ชัน main หรือในบริบทที่เหมาะสม:\n// // public static int main(string[] args) {\n// //   fetch_data();\n// //   GLib.MainLoop loop = new GLib.MainLoop(null, false);\n// //   loop.run(); // Start the main loop to allow async tasks to run\n// //   return 0;\n// // }\n"],"built_in (ในตัว)":["stdout.printf() // ใช้แสดงผลข้อมูลออกทาง Console (Format String)","stdin.read_line() // ใช้รับข้อมูลจากผู้ใช้งาน","GLib.List<T> // Generic List Collection","GLib.HashTable<K, V> // Generic Hash Table Collection","GLib.MainLoop // สำหรับจัดการ Event Loop (สำคัญสำหรับการทำ Asynchronous)","GLib.Timeout.add_seconds() // สำหรับการตั้งเวลาให้ฟังก์ชันทำงาน","int.parse() // แปลงสตริงเป็นจำนวนเต็ม","double.parse() // แปลงสตริงเป็นทศนิยม"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { case value: /* ... */ break; default: /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["for (int i = 0; i < 5; i++) { /* ... */ } // ลูป for แบบดั้งเดิม","while (condition) { /* ... */ } // ลูป while","do { /* ... */ } while (condition); // ลูป do-while (ทำงานอย่างน้อยหนึ่งครั้ง)","foreach (var item in collection) { /* ... */ } // ลูป foreach สำหรับวนซ้ำ Collection"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า: กำหนดค่า, บวกแล้วกำหนด, ลบแล้วกำหนด ฯลฯ","Comparison: ==, !=, >, <, >=, <= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, มากกว่า, น้อยกว่า ฯลฯ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่",". // Member Access Operator (เข้าถึงสมาชิกของ Object/Struct)",":: // Scope Resolution Operator (ในบางบริบท)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\npublic static void check_age(int age) {\n  if (age >= 18) {\n    stdout.printf(\"Adult\\n\");\n  } else {\n    stdout.printf(\"Minor\\n\");\n  }\n}\n// main: check_age(20); check_age(15);\n","// ตัวอย่างที่ 2: การใช้วงลูป (for loop)\npublic static void simple_loop() {\n  for (int i = 0; i < 3; i++) {\n    stdout.printf(\"Loop Vala: %d\\n\", i);\n  }\n}\n// main: simple_loop();\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\npublic static void check_day(string day) {\n  switch (day) {\n    case \"Monday\":\n      stdout.printf(\"Start of week.\\n\");\n      break;\n    case \"Friday\":\n      stdout.printf(\"End of week!\\n\");\n      break;\n    default:\n      stdout.printf(\"Mid-week.\\n\");\n      break;\n  }\n}\n// main: check_day(\"Monday\"); check_day(\"Sunday\");\n","// ตัวอย่างที่ 4: การใช้งาน Class และ Inheritance (OOP)\npublic class Animal : GLib.Object {\n  public string name { get; set; }\n  public Animal(string name) {\n    this.name = name;\n  }\n  public virtual void make_sound() {\n    stdout.printf(\"%s makes a sound.\\n\", this.name);\n  }\n}\npublic class Dog : Animal {\n  public Dog(string name) {\n    base(name);\n  }\n  public override void make_sound() {\n    stdout.printf(\"%s says Woof!\\n\", this.name);\n  }\n}\n// การสร้าง Object และเรียกใช้เมธอด:\n// var my_dog = new Dog(\"Buddy\");\n// my_dog.make_sound(); // Buddy says Woof!\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Exception Handling)\npublic static void safe_divide(int a, int b) {\n  try {\n    if (b == 0) {\n      throw new Math.ArithmeticError.DIVISION_BY_ZERO(\"Cannot divide by zero!\");\n    }\n    stdout.printf(\"Result: %d\\n\", a / b);\n  } catch (Math.ArithmeticError e) {\n    stdout.printf(\"Caught Math Error: %s\\n\", e.message);\n  } catch (Error e) { // ดักจับ Error อื่นๆ\n    stdout.printf(\"Caught General Error: %s\\n\", e.message);\n  }\n}\n// main: safe_divide(10, 2); safe_divide(10, 0);\n","// ตัวอย่างที่ 6: การทำงานกับ List และ Foreach Loop\npublic static void process_fruits() {\n  List<string> fruits = new List<string>();\n  fruits.add(\"Apple\");\n  fruits.add(\"Banana\");\n  fruits.add(\"Cherry\");\n\n  stdout.printf(\"My fruits:\\n\");\n  foreach (var fruit in fruits) {\n    stdout.printf(\"- %s\\n\", fruit);\n  }\n}\n// main: process_fruits();\n"]}},{"id":51,"name":"Verilog","slug":"verilog","logo":"img/verilog.png","desc":"Verilog เป็นภาษา Hardware Description Language (HDL) ที่ใช้ในการออกแบบ, ตรวจสอบ และสร้างวงจรอิเล็กทรอนิกส์ดิจิทัล ตั้งแต่ระดับ Gate ไปจนถึงระดับ System-on-Chip (SoC) เป็นภาษาหลักในการออกแบบชิป (ASIC) และโปรแกรม FPGA","by":"Gateway Design Automation","yr":"1984","level":"1","par":["Declarative","Concurrent","Structured"],"fields":["Embedded","Hardware","Digital","Aero"],"rank":"Top 2 HDL (ร่วมกับ VHDL)","salary_range":"฿45,000-80,000 บาท/เดือน (Junior), ฿80,000-150,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ใช้ในการออกแบบ Hardware โดยตรง","รองรับการจำลอง (Simulation) พฤติกรรมวงจร","สามารถสังเคราะห์ (Synthesis) เป็น Gate Level ได้","อธิบายการทำงานแบบขนานของ Hardware ได้ดี","มีเครื่องมือและ Ecosystem ที่เป็นมาตรฐานอุตสาหกรรม"],"cons":["เฉพาะทางสูง (ไม่เหมาะกับการเขียน Software ทั่วไป)","Learning Curve สูงสำหรับผู้ที่ไม่มีพื้นฐาน Digital Logic/Electronics","การดีบักซับซ้อนและต้องใช้เครื่องมือเฉพาะ","ไวยากรณ์อาจดูเข้าใจยากสำหรับผู้เริ่มต้น","เวลาในการสังเคราะห์และรันบน Hardware อาจนาน"],"frameworks":["None (เป็นภาษาพื้นฐาน)","EDA Tools (Cadence, Synopsys, Mentor Graphics)"],"learn":["Verilog HDL: A Guide to Digital Design and Synthesis (book)","FPGA4Fun","Verilog Quick Reference Guide","VLSI Design Course Materials"],"variables":{"declaration (การประกาศ)":["wire a; // ประกาศ wire (ใช้เชื่อมต่อวงจร)","reg q; // ประกาศ reg (ใช้เก็บค่าใน Sequential Logic)","input clk; // ประกาศ input port ของ Module","output data_out; // ประกาศ output port ของ Module","parameter WIDTH = 8; // ประกาศ Parameter (ค่าคงที่สำหรับปรับแต่ง Module)"],"types (ประเภท)":["wire // ใช้สำหรับเชื่อมต่อ Element (ไม่มีสถานะเก็บค่า)","reg // ใช้สำหรับเก็บค่าใน Sequential Logic (FF, Latch)","integer // จำนวนเต็ม (สำหรับใช้ใน Behavioral Block)","real // ทศนิยม (สำหรับใช้ใน Behavioral Block, Simulation Only)","time // เวลา (สำหรับ Simulation Only)","parameter // ค่าคงที่ที่สามารถกำหนดค่าได้ตอน Instantiation"],"examples (ตัวอย่าง)":["module my_module (input clk, input reset, output reg q); // การประกาศ Module (บล็อกของ Hardware)","wire data_in; // การประกาศ wire สำหรับรับข้อมูล","reg [7:0] counter; // การประกาศ reg ขนาด 8 บิต","parameter SIZE = 16; // การประกาศ Parameter SIZE มีค่าเป็น 16"]},"functions":{"declaration (การออกแบบ Hardware)":["module Module_Name (port_list); // การประกาศ Module","assign output = input_a & input_b; // การกำหนดค่าแบบ Combinational (Continuous Assignment)","always @(posedge clk or negedge reset) begin // Always Block สำหรับ Sequential/Combinational Logic","initial begin // Initial Block (สำหรับ Simulation Initialization)"],"examples (ตัวอย่าง)":["// Module: Half Adder (วงจรบวกครึ่งหนึ่ง)\nmodule half_adder (input a, input b, output sum, output carry);\n  assign sum = a ^ b; // XOR gate\n  assign carry = a & b; // AND gate\nendmodule\n","// Module: D Flip-Flop\nmodule d_flip_flop (input clk, input d, output reg q);\n  always @(posedge clk) begin // เมื่อ clock ขอบขาขึ้น\n    q <= d; // assign ค่า d ไปยัง q (Non-blocking assignment)\n  end\nendmodule\n","// Behavioral Block: Counter\nmodule counter_8bit (\n  input clk,\n  input reset,\n  output reg [7:0] count_out\n);\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin // ถ้า reset เป็น High (Synchronous Reset)\n      count_out <= 8'b0; // Reset counter เป็น 0\n    end else begin\n      count_out <= count_out + 1; // นับเพิ่มทีละ 1\n    end\n  end\nendmodule\n","// Initial Block (สำหรับการจำลอง Simulation)\nmodule testbench;\n  reg clk, reset;\n  wire [7:0] my_count;\n\n  counter_8bit my_counter_instance (\n    .clk(clk),\n    .reset(reset),\n    .count_out(my_count)\n  );\n\n  initial begin // เริ่มต้นการจำลอง\n    clk = 0;\n    reset = 1; #10 reset = 0; // หน่วงเวลา 10 units แล้ว reset เป็น 0\n  end\n\n  always #5 clk = ~clk; // สร้างสัญญาณ clock ทุกๆ 5 units (ความถี่ 10 units)\n\n  initial begin // หยุดการจำลอง\n    #100 $finish; // หลังจาก 100 units ให้หยุดการจำลอง\n  end\nendmodule\n"],"built_in (ในตัว)":["& (AND Gate) // ตัวดำเนินการ AND ระดับ Bit","| (OR Gate) // ตัวดำเนินการ OR ระดับ Bit","^ (XOR Gate) // ตัวดำเนินการ XOR ระดับ Bit","~ (NOT Gate) // ตัวดำเนินการ NOT ระดับ Bit","assign // ใช้กำหนดค่าแบบ Combinational Logic","always // ใช้กำหนด Behavioral Block (Sequential/Combinational)","initial // ใช้กำหนด Initial Block (สำหรับการจำลอง)","$display // ใช้แสดงผลข้อความและค่าตัวแปรใน Simulation Console","$monitor // ใช้แสดงผลค่าตัวแปรเมื่อมีการเปลี่ยนแปลงใน Simulation Console","$finish // ใช้หยุด Simulation","$time // ฟังก์ชันสำหรับเรียกดูเวลาใน Simulation"]},"syntax":{"comments (คอมเมนต์)":["// Single-line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) begin /* ... */ end else if (condition) begin /* ... */ end else begin /* ... */ end // คำสั่ง if-else if-else (ใน Behavioral Block)","case (expression) case_value: /* ... */ default: /* ... */ endcase // คำสั่ง case (ใน Behavioral Block)"],"loops (การวนซ้ำ)":["for (i = 0; i < 5; i = i + 1) begin /* ... */ end // ลูป for (ใน Behavioral Block)","while (condition) begin /* ... */ end // ลูป while (ใน Behavioral Block)","repeat (N) begin /* ... */ end // ลูป repeat (วนซ้ำ N ครั้ง)","forever begin /* ... */ end // ลูปไม่รู้จบ (สำหรับสร้าง Clock/Reset ใน Testbench)"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ","Bitwise: & (AND), | (OR), ^ (XOR), ~ (NOT) // ตัวดำเนินการระดับบิต","Reduction: & (Reduction AND), | (Reduction OR), ^ (Reduction XOR) // ตัวดำเนินการลดบิต (Reduction)","Shift: << (Left Shift), >> (Right Shift) // ตัวดำเนินการ Shift","Concatenation: {a, b} // ตัวดำเนินการเชื่อมต่อบิต/เวกเตอร์","Replication: {N{a}} // ตัวดำเนินการทำซ้ำบิต/เวกเตอร์ N ครั้ง","Blocking Assignment: = // การกำหนดค่าแบบ Blocking (Sequential Execution)","Non-blocking Assignment: <= // การกำหนดค่าแบบ Non-blocking (Concurrent Execution, ใช้สำหรับ Sequential Logic)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) ใน Combinational Logic (always @*)\nmodule mux2to1 (input a, b, sel, output reg out);\n  always @* begin // always @* หมายถึงเมื่อ input ใดๆ เปลี่ยนแปลง\n    if (sel == 1) begin\n      out = a;\n    end else begin\n      out = b;\n    end\n  end\nendmodule\n","// ตัวอย่างที่ 2: การใช้วงลูป For ใน Behavioral Block (Simulation)\nmodule loop_example;\n  integer i;\n  initial begin\n    for (i = 0; i < 3; i = i + 1) begin\n      $display(\"Loop Verilog: %d\", i);\n    end\n    $finish;\n  end\nendmodule\n","// ตัวอย่างที่ 3: การใช้ Case Statement ใน Behavioral Block\nmodule decoder (input [1:0] sel, output reg [3:0] out);\n  always @* begin\n    case (sel)\n      2'b00: out = 4'b0001;\n      2'b01: out = 4'b0010;\n      2'b10: out = 4'b0100;\n      2'b11: out = 4'b1000;\n      default: out = 4'bxxxx; // Unknown or don't care\n    endcase\n  end\nendmodule\n","// ตัวอย่างที่ 4: การใช้งาน Bitwise และ Reduction Operators\nmodule bit_ops (input [3:0] data, output wire all_ones, output wire any_one);\n  assign all_ones = &data; // Reduction AND (เป็น 1 ถ้าทุกบิตเป็น 1)\n  assign any_one = |data; // Reduction OR (เป็น 1 ถ้ามีบิตใดบิตหนึ่งเป็น 1)\nendmodule\n","// ตัวอย่างที่ 5: การใช้งาน Concatenation และ Replication Operators\nmodule concat_repl (input [1:0] a, input [2:0] b, output wire [4:0] c, output wire [5:0] d);\n  assign c = {a, b}; // Concatenation: c จะเป็น 5 บิต (a[1:0]b[2:0])\n  assign d = {{3{a[0]}}, {3{b[2]}}}; // Replication: d จะเป็น 6 บิต (a[0] 3 ครั้ง, b[2] 3 ครั้ง)\nendmodule\n"]}},{"id":53,"name":"VHDL","slug":"vhdl","logo":"img/vhdl.png","desc":"VHDL (Very High Speed Integrated Circuit Hardware Description Language) เป็นภาษา Hardware Description Language (HDL) มาตรฐาน IEEE ที่ใช้ในการออกแบบ, จำลอง และสังเคราะห์วงจรอิเล็กทรอนิกส์ดิจิทัลและ Mixed-signal มีความนิยมในการออกแบบ FPGA และ ASIC โดยเฉพาะในงานที่เน้นความน่าเชื่อถือและความปลอดภัยสูง เช่น ระบบการบินและอวกาศ","by":"U.S. Department of Defense (Initiated)","yr":"1987 (IEEE 1076-1987)","level":"1","par":["Declarative","Concurrent","Structured","Behavioral","Dataflow"],"fields":["Embedded","Hardware","Digital","Aero"],"rank":"Top 2 HDL (ร่วมกับ Verilog/SystemVerilog)","salary_range":"฿45,000-80,000 บาท/เดือน (Junior), ฿80,000-150,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["เป็นภาษา HDL ที่เป็นมาตรฐาน IEEE","มีความสามารถในการอธิบายพฤติกรรมวงจรและโครงสร้าง Hardware","เหมาะสำหรับงานที่ต้องการความน่าเชื่อถือและความปลอดภัยสูง","รองรับการจำลอง (Simulation) และสังเคราะห์ (Synthesis)","มี Type System ที่แข็งแกร่ง (Strongly-typed)"],"cons":["ไวยากรณ์ที่ละเอียดและซับซ้อน (Verbose Syntax)","Learning Curve สูงมากสำหรับผู้เริ่มต้น","ไม่เหมาะกับการเขียน Software ทั่วไป","การดีบักซับซ้อนและต้องใช้เครื่องมือเฉพาะ","เวลาในการสังเคราะห์และรันบน Hardware อาจนาน"],"frameworks":["None (เป็นภาษาพื้นฐาน)","EDA Tools (Cadence, Synopsys, Mentor Graphics)"],"learn":["VHDL Tutorial","The Designer's Guide to VHDL","VHDL Quick Reference Guide","FPGA design courses"],"variables":{"declaration (การประกาศ)":["signal my_signal : std_logic; -- ประกาศ Signal (ใช้เชื่อมต่อวงจร)","variable my_variable : integer := 0; -- ประกาศ Variable (ใช้ใน Sequential Block)","constant MY_CONSTANT : integer := 10; -- ประกาศ Constant","port (clk : in std_logic; data_out : out std_logic_vector(7 downto 0)); -- ประกาศ Port ของ Entity"],"types (ประเภท)":["std_logic // Standard Logic (4-value: '0', '1', 'X', 'Z')","std_logic_vector // Vector ของ std_logic (เช่น std_logic_vector(7 downto 0))","bit // 2-value logic ('0', '1')","bit_vector // Vector ของ bit","integer // จำนวนเต็ม","real // ทศนิยม (สำหรับ Simulation Only)","time // เวลา (สำหรับ Simulation Only)","boolean // ค่าตรรกะ (TRUE, FALSE)","character // ตัวอักขระ","string // ข้อความ","type state_type is (IDLE, ACTIVE); -- การประกาศ Enumerated Type"],"examples (ตัวอย่าง)":["signal enable : std_logic; -- ประกาศ Signal ชื่อ enable ชนิด std_logic","variable counter : integer range 0 to 255 := 0; -- ประกาศ Variable counter ชนิด integer มีช่วงค่า 0-255 เริ่มต้นที่ 0","constant CLK_PERIOD : time := 10 ns; -- ประกาศ Constant CLK_PERIOD เป็นเวลา 10 นาโนวินาที","signal data_bus : std_logic_vector(15 downto 0); -- ประกาศ Signal data_bus เป็น Vector 16 บิต"]},"functions":{"declaration (การออกแบบ Hardware และ Behavioral Modeling)":["entity Entity_Name is\\n  port (...);\\nend Entity_Name; -- การประกาศ Entity (ส่วนติดต่อภายนอกของ Hardware Block)","architecture Architecture_Name of Entity_Name is\\nbegin\\n  -- Concurrent Statements\\n  process (sensitivity_list)\\n  begin\\n    -- Sequential Statements\\n  end process;\\nend Architecture_Name; -- การประกาศ Architecture (พฤติกรรมหรือโครงสร้างภายใน)","function Function_Name (parameters) return return_type is\\n  -- declarations\\nbegin\\n  -- statements\\n  return value;\\nend Function_Name; -- การประกาศ Function","procedure Procedure_Name (parameters) is\\n  -- declarations\\nbegin\\n  -- statements\\nend Procedure_Name; -- การประกาศ Procedure"],"examples (ตัวอย่าง)":["// Entity และ Architecture: Half Adder (วงจรบวกครึ่งหนึ่ง)\nentity half_adder is\n  port (\n    a, b    : in  std_logic;\n    sum, carry : out std_logic\n  );\nend half_adder;\n\narchitecture behavioral of half_adder is\nbegin\n  sum <= a xor b;\n  carry <= a and b;\nend behavioral;\n","// Process (Always Block): D Flip-Flop\nentity d_flip_flop is\n  port (\n    clk : in  std_logic;\n    d   : in  std_logic;\n    q   : out std_logic\n  );\nend d_flip_flop;\n\narchitecture rtl of d_flip_flop is\nbegin\n  process (clk) -- เมื่อ clk เปลี่ยนแปลง\n  begin\n    if rising_edge(clk) then -- เมื่อ clock ขอบขาขึ้น\n      q <= d; -- กำหนดค่า d ให้ q (Non-blocking assignment)\n    end if;\n  end process;\nend rtl;\n","// Process: Counter 8-bit พร้อม Synchronous Reset\nentity counter_8bit is\n  port (\n    clk   : in  std_logic;\n    reset : in  std_logic;\n    count : out std_logic_vector(7 downto 0)\n  );\nend counter_8bit;\n\narchitecture behavioral of counter_8bit is\n  signal internal_count : std_logic_vector(7 downto 0) := (others => '0');\nbegin\n  process (clk, reset)\n  begin\n    if rising_edge(reset) then -- ถ้า reset เป็น High (Synchronous Reset)\n      internal_count <= (others => '0'); -- Reset counter เป็น 0\n    elsif rising_edge(clk) then -- เมื่อ clock ขอบขาขึ้น\n      internal_count <= internal_count + 1; -- นับเพิ่มทีละ 1\n    end if;\n  end process;\n  count <= internal_count; -- กำหนดค่า Internal_count ให้ Output Port\nend behavioral;\n","// Testbench (สำหรับจำลอง Simulation)\nentity testbench is\nend testbench;\n\narchitecture testbench_arch of testbench is\n  signal clk, reset : std_logic := '0';\n  signal counter_out : std_logic_vector(7 downto 0);\n  constant CLK_PERIOD : time := 10 ns;\nbegin\n  -- Instantiate DUT (Device Under Test)\n  DUT : entity work.counter_8bit\n    port map (\n      clk   => clk,\n      reset => reset,\n      count => counter_out\n    );\n\n  -- Generate Clock\n  clk_process : process\n  begin\n    loop\n      clk <= '0';\n      wait for CLK_PERIOD / 2;\n      clk <= '1';\n      wait for CLK_PERIOD / 2;\n    end loop;\n  end process clk_process;\n\n  -- Generate Reset and Stimulus\n  stimulus_process : process\n  begin\n    reset <= '1';\n    wait for 20 ns; -- Reset active for 20 ns\n    reset <= '0';\n    wait for 100 ns; -- Run for 100 ns\n    report \"Simulation Finished\"; -- แสดงข้อความใน Simulation log\n    wait; -- หยุด Simulation\n  end process stimulus_process;\nend testbench_arch;\n"],"built_in (ในตัว)":["and, or, xor, not // Gate-level operators (สำหรับ Logic Gates)","assign <= // Signal Assignment (Non-blocking)","report // ใช้แสดงข้อความใน Simulation log","assert // ใช้สำหรับ Hardware Assertion (ตรวจสอบคุณสมบัติ)","wait for // หน่วงเวลาใน Simulation","rising_edge(signal) // ตรวจสอบขอบขาขึ้นของ Signal","falling_edge(signal) // ตรวจสอบขอบขาลงของ Signal","to_integer() // แปลง std_logic_vector เป็น Integer","to_signed() // แปลง std_logic_vector เป็น Signed Integer","to_unsigned() // แปลง std_logic_vector เป็น Unsigned Integer"]},"syntax":{"comments (คอมเมนต์)":["-- Single-line comment // คอมเมนต์บรรทัดเดียว (เริ่มต้นด้วย Double Dash)"],"conditions (เงื่อนไข)":["if condition then\\n  -- statements\\nelsif another_condition then\\n  -- statements\\nelse\\n  -- statements\\nend if; -- คำสั่ง if-elsif-else (ใน Process)","case expression is\\n  when value1 =>\\n    -- statements\\n  when value2 | value3 =>\\n    -- statements (หลายค่า)\\n  when others =>\\n    -- statements (กรณีอื่นๆ)\\nend case; -- คำสั่ง case (ใน Process)"],"loops (การวนซ้ำ)":["for Loop_Variable in Range loop\\n  -- statements\\nend loop; -- ลูป for (สำหรับช่วงตัวเลข)","while Condition loop\\n  -- statements\\nend loop; -- ลูป while","loop\\n  -- statements\\n  exit when Condition;\\nend loop; -- Infinite loop พร้อมเงื่อนไขออก"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, mod, rem, abs, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, Modulo, Remainder, Absolute, ยกกำลัง","Comparison: =, /=, <, <=, >, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, น้อยกว่าหรือเท่ากับ, มากกว่า, มากกว่าหรือเท่ากับ","Logical: and, or, nand, nor, xor, xnor, not // ตัวดำเนินการตรรกะ: AND, OR, NAND, NOR, XOR, XNOR, NOT","Concatenation: & // ตัวดำเนินการเชื่อมต่อ Vector/String"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้ If-Else ใน Process (Combinational Logic)\narchitecture comb_logic of example is\n  signal a, b, sel : std_logic;\n  signal result : std_logic;\nbegin\n  process (a, b, sel)\n  begin\n    if sel = '1' then\n      result <= a;\n    else\n      result <= b;\n    end if;\n  end process;\nend comb_logic;\n","// ตัวอย่างที่ 2: การใช้วงลูป For ใน Process (Simulation หรือ Synthesizable Logic บางกรณี)\narchitecture loop_example of example is\n  signal data_in : std_logic_vector(3 downto 0);\n  signal sum_bits : std_logic;\nbegin\n  process (data_in)\n    variable temp_sum : std_logic := '0';\n  begin\n    temp_sum := '0';\n    for i in 0 to 3 loop\n      temp_sum := temp_sum xor data_in(i);\n    end loop;\n    sum_bits <= temp_sum;\n  end process;\nend loop_example;\n","// ตัวอย่างที่ 3: การใช้ Case Statement ใน Process\narchitecture case_example of example is\n  type state_type is (IDLE, READ, WRITE);\n  signal current_state : state_type := IDLE;\n  signal opcode : std_logic_vector(1 downto 0);\n  signal next_state : state_type;\nbegin\n  process (current_state, opcode)\n  begin\n    case current_state is\n      when IDLE =>\n        if opcode = \"01\" then\n          next_state <= READ;\n        else\n          next_state <= IDLE;\n        end if;\n      when READ =>\n        next_state <= IDLE;\n      when WRITE =>\n        next_state <= IDLE;\n      when others => -- ต้องมี when others สำหรับทุกกรณีที่เป็นไปได้ (Synthesizable)\n        next_state <= IDLE;\n    end case;\n  end process;\nend case_example;\n","// ตัวอย่างที่ 4: การใช้งาน Components (Instantiation) และ Port Mapping\n-- ตัวอย่างการเรียกใช้ Half Adder ที่ประกาศไว้ข้างต้น\n-- entity top_level is\n--   port (\n--     x, y    : in  std_logic;\n--     s_out, c_out : out std_logic\n--   );\n-- end top_level;\n--\n-- architecture structure of top_level is\n--   component half_adder\n--     port (\n--       a, b    : in  std_logic;\n--       sum, carry : out std_logic\n--     );\n--   end component;\n-- begin\n--   U1 : half_adder\n--     port map (\n--       a     => x,\n--       b     => y,\n--       sum   => s_out,\n--       carry => c_out\n--     );\n-- end structure;\n","// ตัวอย่างที่ 5: การจัดการข้อผิดพลาด (Assertion) ใน Simulation\narchitecture assertion_example of example is\n  signal data_valid : boolean := false;\n  signal count_val : integer := 0;\nbegin\n  process (clk) -- สมมติมี clk\n  begin\n    if rising_edge(clk) then\n      -- Simulate some logic\n      if count_val = 5 then\n        data_valid <= true;\n      else\n        count_val <= count_val + 1;\n      end if;\n    end if;\n  end process;\n\n  -- Assertion: data_valid should be true after count_val reaches 5\n  -- assert data_valid report \"Data did not become valid after counter reached 5\" severity ERROR;\n  -- (Assertion สามารถวางใน process หรือเป็น concurrent statement ก็ได้)\nend assertion_example;\n"]}},{"id":59,"name":"WGSL","slug":"wgsl","logo":"img/webgpu.png","desc":"WGSL (WebGPU Shading Language) เป็นภาษา Shading Language ใหม่ล่าสุดที่ออกแบบมาสำหรับ WebGPU API โดยเฉพาะ มีเป้าหมายเพื่อให้เป็นภาษาที่ปลอดภัย, มีประสิทธิภาพสูง และทำงานได้หลากหลายแพลตฟอร์มสำหรับกราฟิก 3D บนเว็บและ Native แอปพลิเคชัน เป็นส่วนหนึ่งของวิวัฒนาการในการแสดงผลกราฟิกบนเว็บให้มีประสิทธิภาพเทียบเท่า Native Desktop Graphics APIs","by":"W3C (GPU for the Web Community Group)","yr":"2020 (ร่างมาตรฐาน)","level":"2","par":["Procedural","Imperative","Concurrent (implicitly)"],"fields":["Game","Graphics","Scientific","Render"],"rank":"กำลังจะกลายเป็นมาตรฐานใหม่สำหรับ Web Graphics (ร่วมกับ WebGPU)","salary_range":"฿45,000-80,000 บาท/เดือน (Junior), ฿80,000-150,000 บาท/เดือน (Senior)","salary":["high","veryhigh"],"pros":["ออกแบบมาเพื่อ WebGPU โดยเฉพาะ ทำให้เข้ากันได้อย่างสมบูรณ์","ความปลอดภัยสูงกว่า GLSL/HLSL ในบริบทของเว็บ","ประสิทธิภาพสูงใกล้เคียง Native Graphics APIs (DirectX, Vulkan, Metal)","เป็นภาษาที่ทันสมัย มี Type System ที่ชัดเจนและ Features ที่ดีขึ้น","สามารถ Compile จาก HLSL/GLSL ได้ในบางกรณี","ทำงานบนหลายแพลตฟอร์มและ GPU Vendors ได้"],"cons":["ใหม่มากและยังอยู่ในช่วงการพัฒนา/นำไปใช้","Ecosystem และ Community ยังเล็กมากเมื่อเทียบกับ GLSL/HLSL","Learning Curve สูงสำหรับผู้ที่ไม่มีพื้นฐาน Graphics Programming","เครื่องมือดีบักและ Optimize ยังไม่สมบูรณ์เท่าที่ควร","ยังไม่ได้รับการรองรับเต็มรูปแบบในทุก Browser/Hardware"],"frameworks":["WebGPU (Graphics API)"],"learn":["WebGPU Specification","WebGPU Samples","Mozilla WebGPU Docs","Khronos Group WGSL Tutorials"],"variables":{"declaration (การประกาศ)":["var my_var: f32; // การประกาศตัวแปร float","let my_const: i32 = 10; // การประกาศค่าคงที่ integer","struct VertexInput { position: vec4<f32>; color: vec4<f32>; }; // การประกาศ Struct"],"types (ประเภท)":["bool // ค่าตรรกะ (true/false)","i32 // จำนวนเต็ม 32 บิต","u32 // จำนวนเต็มบวก 32 บิต","f32 // ทศนิยมความแม่นยำเดี่ยว","f16 // ทศนิยมความแม่นยำครึ่ง (ถ้ามี Hardware Support)","vec2<T>, vec3<T>, vec4<T> // Vector (เช่น vec3<f32>)","mat2x2<T>, mat3x3<T>, mat4x4<T> // Matrix (เช่น mat4x4<f32>)","array<T, N> // Array (ขนาดคงที่)","sampler // Sampler สำหรับ Texture","texture_2d<f32> // Texture Object (ระบุมิติและประเภทข้อมูล)","ptr<address_space, type> // Pointer สำหรับการเข้าถึง Memory"],"examples (ตัวอย่าง)":["var position: vec3<f32>; // ตัวแปร Vector 3 มิติของ float","let PI: f32 = 3.14159; // ค่าคงที่ PI","var vertices: array<vec4<f32>, 4>; // Array ของ vec4<f32> 4 ตัว","var my_color: vec4<f32> = vec4<f32>(1.0, 0.0, 0.0, 1.0); // กำหนดสีแดง"]},"functions":{"declaration (การเขียน Shader)":["@vertex fn vs_main(parameters) -> ReturnType { /* ... */ } // Vertex Shader Entry Point","@fragment fn fs_main(parameters) -> ReturnType { /* ... */ } // Fragment Shader Entry Point","fn my_function(param: Type) -> ReturnType { /* ... */ } // User-defined Function"],"examples (ตัวอย่าง)":["// Vertex Shader\\n@vertex\\nfn vs_main(\\n  @builtin(vertex_index) vertex_index : u32\\n) -> @builtin(position) vec4<f32> {\\n  let pos = array<vec2<f32>, 3>(\\n    vec2<f32>(0.0, 0.5),\\n    vec2<f32>(-0.5, -0.5),\\n    vec2<f32>(0.5, -0.5)\\n  );\\n  return vec4<f32>(pos[vertex_index], 0.0, 1.0);\\n}\\n","// Fragment Shader\\n@fragment\\nfn fs_main(\\n  @builtin(position) frag_coord : vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  return vec4<f32>(1.0, 0.0, 0.0, 1.0); // สีแดง\\n}\\n","// User-defined Function\\nfn calculate_light(normal: vec3<f32>, light_dir: vec3<f32>) -> f32 {\\n  return max(dot(normal, light_dir), 0.0);\\n}\\n"],"built_in (ในตัว)":["@builtin(position) // Vertex/Fragment position","@builtin(vertex_index) // Index ของ Vertex","@location(n) // Binding location สำหรับ Input/Output","vec2<T>(), vec3<T>(), vec4<T>() // Constructor สำหรับ Vector","mat2x2<T>(), mat3x3<T>(), mat4x4<T>() // Constructor สำหรับ Matrix","length() // หาความยาว Vector","dot() // Dot Product","cross() // Cross Product","normalize() // ทำให้ Vector เป็น Unit Vector","mix() // Linear Interpolation","clamp() // จำกัดค่าให้อยู่ในช่วง","max(), min() // หาค่าสูงสุด/ต่ำสุด","textureSample() // Sample ค่าจาก Texture","sin(), cos(), tan() // ฟังก์ชันตรีโกณมิติ"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi-line\n   comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else"],"loops (การวนซ้ำ)":["for (var i: i32 = 0; i < 5; i = i + 1) { /* ... */ } // ลูป for","while (condition) { /* ... */ } // ลูป while","loop { /* ... */ break if condition; } // ลูปไม่รู้จบพร้อมเงื่อนไขออก"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, % // ตัวดำเนินการทางคณิตศาสตร์","Assignment: =, +=, -=, *=, /=, %= // ตัวดำเนินการกำหนดค่า","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ","Logical: && (AND), || (OR), ! (NOT) // ตัวดำเนินการตรรกะ",". (component access) // เข้าถึง Component ของ Vector/Matrix (เช่น myVec.x, myMat[0][1])"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else) ใน Fragment Shader\\n@fragment\\nfn fs_conditional(\\n  @builtin(position) frag_coord : vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  if (frag_coord.x > 0.5) {\\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0); // สีแดง\\n  } else {\\n    return vec4<f32>(0.0, 1.0, 0.0, 1.0); // สีเขียว\\n  }\\n}\\n","// ตัวอย่างที่ 2: การใช้วงลูป for ใน Compute Shader (Conceptual)\\n@compute\\n@workgroup_size(64)\\nfn cs_blur_effect(\\n  @builtin(global_invocation_id) global_id : vec3<u32>\\n) {\\n  // จำลองการคำนวณ Blur Effect ง่ายๆ บน Pixel\\n  var sum_color: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  for (var i: i32 = -1; i <= 1; i = i + 1) {\\n    for (var j: i32 = -1; j <= 1; j = j + 1) {\\n      // sum_color = sum_color + textureLoad(my_texture, global_id.xy + vec2<i32>(i, j));\\n      // (การเข้าถึง Texture ใน compute shader จะซับซ้อนกว่านี้)\\n      sum_color = sum_color + vec4<f32>(0.1, 0.1, 0.1, 0.0); // จำลองการบวกสี\\n    }\\n  }\\n  // textureStore(output_texture, global_id.xy, sum_color / 9.0);\\n}\\n","// ตัวอย่างที่ 3: การทำงานกับ Vector และ Matrix\\nvar a_vec: vec3<f32> = vec3<f32>(1.0, 2.0, 3.0);\\nvar b_vec: vec3<f32> = vec3<f32>(4.0, 5.0, 6.0);\\nlet result_vec_add = a_vec + b_vec; // (5.0, 7.0, 9.0)\\nlet result_dot = dot(a_vec, b_vec); // 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32.0\\n\\nvar my_matrix: mat4x4<f32> = mat4x4<f32>( // Identity Matrix\\n  vec4<f32>(1.0, 0.0, 0.0, 0.0),\\n  vec4<f32>(0.0, 1.0, 0.0, 0.0),\\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\\n  vec4<f32>(0.0, 0.0, 0.0, 1.0)\\n);\\n\\nlet transformed_vec = my_matrix * vec4<f32>(1.0, 2.0, 3.0, 1.0); // การคูณ Matrix กับ Vector\\n"]}},{"id":47,"name":"Zig","slug":"zig","logo":"img/zig.png","desc":"Zig เป็นภาษาโปรแกรมที่ออกแบบมาเพื่อให้เป็นทางเลือกแทน C โดยเน้นที่ประสิทธิภาพ ความปลอดภัย และความโปร่งใสในการจัดการหน่วยความจำ เหมาะสำหรับงานระดับล่าง เช่น ระบบปฏิบัติการ, Embedded, และ Game Engine","by":"Andrew Kelley","yr":"2015","level":"5","par":["Procedural","Imperative","Low-level","No Hidden Control Flow"],"fields":["System","OS","Game"],"rank":"Top 5 ภาษาเกิดใหม่สาย Systems Programming","salary_range":"฿50,000-80,000 บาท/เดือน (Junior), ฿80,000-150,000 บาท/เดือน (Senior)","salary":["mid","high","veryhigh"],"pros":["ไม่มี hidden control flow (ทำให้เข้าใจ flow ได้ชัดเจน)","แทนที่ C ได้โดยตรงและมี performance ใกล้เคียง","Built-in dependency management และ cross-compilation","ใช้เป็น compiler frontend แทน GCC/Clang ได้ (zig cc)","เหมาะสำหรับ embedded, OS-level และ high-performance system"],"cons":["ยังไม่เป็นที่นิยมในวงกว้าง","เครื่องมือและ IDE รองรับยังน้อยเมื่อเทียบกับภาษาอื่น","การเรียนรู้สำหรับผู้เริ่มต้นอาจชันกว่าภาษา high-level","ไม่มี garbage collection ต้องจัดการ memory เองทั้งหมด"],"frameworks":["Zon (Package Manager)","Zig Build System"],"learn":["ziglang.org","Zig Learn","Ziglings","Zig YouTube Talks"],"variables":{"declaration (การประกาศ)":["var // สำหรับตัวแปรที่เปลี่ยนแปลงได้ (Mutable)","const // สำหรับค่าคงที่ (Immutable)"],"types (ประเภท)":["i8, i16, i32, i64, i128 // จำนวนเต็มแบบมีเครื่องหมาย (Signed Integers)","u8, u16, u32, u64, u128 // จำนวนเต็มแบบไม่มีเครื่องหมาย (Unsigned Integers)","f16, f32, f64, f128 // ทศนิยม (Floating-point)","bool // ค่าตรรกะ (true/false)","[]const u8 (string) // สตริง (เป็น Slice ของ Unsigned 8-bit Integer ที่ไม่สามารถเปลี่ยนแปลงได้)","struct // โครงสร้างข้อมูล (คล้าย Structs ใน C)","enum // Enumeration Type","union // Union Type"],"examples (ตัวอย่าง)":["const a: i32 = 10; // ค่าคงที่ a ประเภทจำนวนเต็ม 32 บิต\n","var name: []const u8 = \"Zig\"; // ตัวแปร name เก็บสตริง\n","var flag: bool = true; // ตัวแปร flag เก็บค่าตรรกะ\n","var count: u64 = 0; // ตัวแปร count เป็นจำนวนเต็มบวก 64 บิต\n","const numbers = [_]i32{1, 2, 3}; // Array ขนาดคงที่\n","var user = struct { name: []const u8, age: u8 }{ .name = \"Bob\", .age = 30 }; // Struct"]},"functions":{"declaration (การประกาศ)":["fn name(param: type) type { ... } // การประกาศฟังก์ชัน"],"examples (ตัวอย่าง)":["// ฟังก์ชันบวกเลขสองจำนวน\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n","// ฟังก์ชันทักทาย (คืนค่าเป็น void หรือไม่มีอะไรเลย)\nconst std = @import(\"std\");\nfn greet(name: []const u8) void {\n    std.debug.print(\"Hello, {}!\\n\", .{name});\n}\n","// การเรียกใช้ฟังก์ชัน:\n// var sum_result = add(10, 20); // sum_result จะมีค่า 30\n// greet(\"Zig User\"); // แสดงผล 'Hello, Zig User!'\n","// ฟังก์ชันที่คืนค่า Error Union (สำหรับการจัดการข้อผิดพลาด)\n// Zig ใช้ Error Union แทน Exception เพื่อการจัดการข้อผิดพลาดที่ชัดเจน\nconst MyError = error{\n    DivisionByZero,\n    NegativeInput\n};\n\nfn safeDivide(numerator: f32, denominator: f32) MyError!f32 {\n    if (denominator == 0.0) return MyError.DivisionByZero;\n    if (numerator < 0 or denominator < 0) return MyError.NegativeInput;\n    return numerator / denominator;\n}\n\n// การเรียกใช้และจัดการ Error\n// var result = safeDivide(10.0, 2.0);\n// if (result) |value| {\n//     std.debug.print(\"Result: {}\\n\", .{value});\n// } else |err| switch (err) {\n//     MyError.DivisionByZero => std.debug.print(\"Error: Cannot divide by zero!\\n\", .{}),\n//     MyError.NegativeInput => std.debug.print(\"Error: Input must be positive!\\n\", .{}),\n// };\n","// Asynchronous Programming (Conceptual - ผ่าน Context Switch หรือ Libraries)\n// Zig ไม่ได้มี Async/Await ในตัวแบบภาษาสมัยใหม่ แต่ใช้แนวคิดของ Coroutines\n// และ Promises ผ่าน Libraries หรือการจัดการ Context Switch ด้วยตนเอง\n// ซึ่งทำให้การเขียน Asynchronous Code เป็นไปได้ในระดับ Low-level\n\n// ตัวอย่างแนวคิดการเขียนโค้ดที่อาจจะทำงานในบริบทของ Fiber/Coroutine library\n// const std = @import(\"std\");\n// const sleep = std.time.sleep;\n\n// fn longTask(msg: []const u8) !void {\n//     std.debug.print(\"{} Starting long task...\\n\", .{msg});\n//     try sleep(1_000_000_000); // จำลองการหน่วงเวลา 1 วินาที\n//     std.debug.print(\"{} Finished long task!\\n\", .{msg});\n// }\n//\n// pub fn main() !void {\n//     std.debug.print(\"Main: Before tasks\\n\", .{});\n//     const task1 = @asyncCall longTask(\"Task A\"); // สร้าง Asynchronous Call\n//     const task2 = @asyncCall longTask(\"Task B\");\n//     std.debug.print(\"Main: After tasks, waiting...\\n\", .{});\n//     @await(task1); // รอให้ Task A เสร็จ\n//     @await(task2); // รอให้ Task B เสร็จ\n//     std.debug.print(\"Main: All tasks done\\n\", .{});\n// }"],"built_in (ในตัว)":["std.debug.print() // ใช้แสดงผลข้อมูลออกทาง Console","std.mem.copy() // ใช้คัดลอกหน่วยความจำ","std.fs.File.read() // ใช้สำหรับอ่านไฟล์","std.heap.page_allocator // Allocator สำหรับการจัดการหน่วยความจำ","std.testing.expect() // สำหรับการเขียน Test","std.fmt.format() // สำหรับจัดรูปแบบสตริง"]},"syntax":{"comments (คอมเมนต์)":["// Single line comment // คอมเมนต์บรรทัดเดียว","/* Multi line comment */ // คอมเมนต์หลายบรรทัด"],"conditions (เงื่อนไข)":["if (condition) { /* ... */ } else if (condition) { /* ... */ } else { /* ... */ } // คำสั่ง if-else if-else","switch (expression) { /* ... */ } // คำสั่ง switch"],"loops (การวนซ้ำ)":["while (condition) { /* ... */ } // ลูป while","for (array) |item, index| { /* ... */ } // ลูป for สำหรับวนซ้ำ Array/Slice"],"operators (ตัวดำเนินการ)":["Arithmetic: +, -, *, /, %, ** // ตัวดำเนินการทางคณิตศาสตร์: บวก, ลบ, คูณ, หาร, โมดูลัส, ยกกำลัง","Comparison: ==, !=, <, >, <=, >= // ตัวดำเนินการเปรียบเทียบ: เท่ากับ, ไม่เท่ากับ, น้อยกว่า, มากกว่า ฯลฯ","Logical: and (&&), or (||), not (!) // ตัวดำเนินการตรรกะ: และ, หรือ, ไม่","Bitwise: &, |, ^, ~, <<, >> // ตัวดำเนินการบิตไวส์",". // Field Access Operator (เข้าถึงสมาชิก Struct)","-> // Pointer Dereference (ในบางบริบท)","[] // Indexing (เข้าถึงสมาชิก Array/Slice)",": // Type Annotation",".{} // Anonymous Struct Literal (สำหรับ arguments ของ print)"],"examples (ตัวอย่าง)":["// ตัวอย่างที่ 1: การใช้เงื่อนไข (if-else)\nconst std = @import(\"std\");\nfn checkNumber(x: i32) void {\n    if (x > 10) {\n        std.debug.print(\"Big!\\n\", .{});\n    } else {\n        std.debug.print(\"Small!\\n\", .{});\n    }\n}\n// main: checkNumber(15); checkNumber(5);\n","// ตัวอย่างที่ 2: การใช้วงลูป for\nconst std = @import(\"std\");\nfn printArray(arr: []const i32) void {\n    for (arr) |item, index| {\n        std.debug.print(\"Index {}: {}\\n\", .{index, item});\n    }\n}\n// main: printArray(&[_]i32{10, 20, 30});\n","// ตัวอย่างที่ 3: การใช้ Switch Statement\nconst std = @import(\"std\");\nfn checkDay(day_num: u8) void {\n    switch (day_num) {\n        1 => std.debug.print(\"Monday\\n\", .{}),\n        5 => std.debug.print(\"Friday\\n\", .{}),\n        else => std.debug.print(\"Other day\\n\", .{}),\n    }\n}\n// main: checkDay(1); checkDay(5); checkDay(3);\n","// ตัวอย่างที่ 4: การใช้งาน Struct และ Pointer\nconst std = @import(\"std\");\nconst Person = struct {\n    name: []const u8,\n    age: u8,\n};\n\nfn modifyAge(p: *Person) void {\n    p.age += 1;\n}\n\npub fn main() !void {\n    var alice = Person{ .name = \"Alice\", .age = 25 };\n    std.debug.print(\"Initial age: {}\\n\", .{alice.age});\n    modifyAge(&alice); // ส่ง Address ของ Struct ไปให้ฟังก์ชัน\n    std.debug.print(\"New age: {}\\n\", .{alice.age});\n}\n","// ตัวอย่างที่ 5: การจัดการ Memory ด้วย Allocator (Manual Memory Management)\nconst std = @import(\"std\");\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    // จัดสรรหน่วยความจำสำหรับ Array 5 ints\n    var numbers = try allocator.alloc(i32, 5);\n    defer allocator.free(numbers); // รับประกันว่าจะถูก Free เมื่อออกจาก Scope\n\n    numbers[0] = 100;\n    numbers[1] = 200;\n    std.debug.print(\"Number at index 0: {}\\n\", .{numbers[0]});\n}\n"]}}]